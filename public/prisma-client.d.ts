
/**
 * Client
**/

import * as runtime from './library';

type UnwrapPromise<P extends any> = P extends Promise<infer R> ? R : P
type UnwrapTuple<Tuple extends readonly unknown[]> = {
  [K in keyof Tuple]: K extends `${number}` ? Tuple[K] extends Prisma.PrismaPromise<infer X> ? X : UnwrapPromise<Tuple[K]> : UnwrapPromise<Tuple[K]>
};

export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>


/**
 * Model drive
 * 
 */
export type drive = {
  id: string
  created: Date
  updated: Date
  unique_id: string
  type: number | null
  name: string
  remark: string | null
  avatar: string
  profile: string
  total_size: number | null
  used_size: number | null
  invalid: number | null
  latest_analysis: Date | null
  root_folder_name: string | null
  root_folder_id: string | null
  drive_token_id: string
  user_id: string
}

/**
 * Model drive_token
 * 
 */
export type drive_token = {
  id: string
  created: Date
  updated: Date
  data: string
  expired_at: number
}

/**
 * Model tv_profile
 * 
 */
export type tv_profile = {
  id: string
  created: Date
  updated: Date
  unique_id: string
  source: number | null
  sources: string | null
  name: string | null
  original_name: string | null
  overview: string | null
  poster_path: string | null
  backdrop_path: string | null
  first_air_date: string | null
  original_language: string | null
  origin_country: string | null
  genres: string | null
  popularity: number | null
  vote_average: number | null
  vote_count: number | null
  episode_count: number | null
  season_count: number | null
  status: string | null
  in_production: number | null
}

/**
 * Model season_profile
 * 
 */
export type season_profile = {
  id: string
  created: Date
  updated: Date
  unique_id: string
  source: number | null
  sources: string | null
  name: string | null
  overview: string | null
  poster_path: string | null
  season_number: number | null
  air_date: string | null
  episode_count: number | null
  vote_average: number | null
}

/**
 * Model episode_profile
 * 
 */
export type episode_profile = {
  id: string
  created: Date
  updated: Date
  unique_id: string
  source: number | null
  sources: string | null
  name: string | null
  overview: string | null
  air_date: string | null
  runtime: number | null
  episode_number: number | null
  season_number: number | null
}

/**
 * Model movie_profile
 * 
 */
export type movie_profile = {
  id: string
  created: Date
  updated: Date
  unique_id: string
  source: number | null
  sources: string | null
  name: string | null
  original_name: string | null
  overview: string | null
  poster_path: string | null
  backdrop_path: string | null
  air_date: string | null
  original_language: string | null
  popularity: number | null
  vote_average: number | null
  vote_count: number | null
  origin_country: string | null
  genres: string | null
  runtime: number | null
}

/**
 * Model subtitle
 * 
 */
export type subtitle = {
  id: string
  created: Date
  updated: Date
  file_id: string
  name: string
  language: string
  movie_id: string | null
  episode_id: string | null
  drive_id: string
  user_id: string
}

/**
 * Model parsed_tv
 * 
 */
export type parsed_tv = {
  id: string
  created: Date
  updated: Date
  name: string | null
  original_name: string | null
  file_id: string | null
  file_name: string | null
  can_search: number | null
  correct_name: string | null
  tmdb_id: number | null
  tv_id: string | null
  drive_id: string
  user_id: string
}

/**
 * Model parsed_season
 * 
 */
export type parsed_season = {
  id: string
  created: Date
  updated: Date
  season_number: string
  file_id: string | null
  file_name: string | null
  can_search: number | null
  correct_season_number: string | null
  season_id: string | null
  parsed_tv_id: string
  drive_id: string
  user_id: string
}

/**
 * Model parsed_episode
 * 
 */
export type parsed_episode = {
  id: string
  created: Date
  updated: Date
  episode_number: string
  season_number: string
  name: string
  file_id: string
  file_name: string
  parent_file_id: string
  parent_paths: string
  type: number
  size: number | null
  can_search: number | null
  episode_id: string | null
  parsed_tv_id: string
  parsed_season_id: string
  drive_id: string
  user_id: string
}

/**
 * Model parsed_movie
 * 
 */
export type parsed_movie = {
  id: string
  created: Date
  updated: Date
  name: string
  original_name: string | null
  correct_name: string | null
  file_id: string
  file_name: string
  parent_file_id: string
  parent_paths: string
  type: number
  size: number | null
  can_search: number | null
  movie_id: string | null
  drive_id: string
  user_id: string
}

/**
 * Model tv
 * 
 */
export type tv = {
  id: string
  created: Date
  updated: Date
  hidden: number | null
  profile_id: string
  collection_id: string | null
  user_id: string
}

/**
 * Model season
 * 
 */
export type season = {
  id: string
  created: Date
  updated: Date
  season_text: string
  season_number: number
  profile_id: string
  collection_id: string | null
  tv_id: string
  user_id: string
}

/**
 * Model episode
 * 
 */
export type episode = {
  id: string
  created: Date
  updated: Date
  episode_text: string
  season_text: string
  episode_number: number
  profile_id: string
  tv_id: string
  season_id: string
  user_id: string
}

/**
 * Model movie
 * 
 */
export type movie = {
  id: string
  created: Date
  updated: Date
  profile_id: string
  user_id: string
  collection_id: string | null
}

/**
 * Model collection
 * 
 */
export type collection = {
  id: string
  created: Date
  updated: Date
  title: string
  desc: string | null
  type: number
  rules: string | null
  sort: number
  styles: string | null
  user_id: string
}

/**
 * Model async_task
 * 
 */
export type async_task = {
  id: string
  created: Date
  updated: Date
  unique_id: string
  type: number | null
  desc: string | null
  status: number | null
  need_stop: number | null
  error: string | null
  output_id: string
  user_id: string
}

/**
 * Model output
 * 
 */
export type output = {
  id: string
  created: Date
  updated: Date
  user_id: string
}

/**
 * Model output_line
 * 
 */
export type output_line = {
  id: string
  created: Date
  updated: Date
  content: string
  output_id: string | null
}

/**
 * Model play_history
 * 
 */
export type play_history = {
  id: string
  created: Date
  updated: Date
  duration: number | null
  current_time: number | null
  thumbnail: string | null
  file_id: string | null
  tv_id: string | null
  season_id: string | null
  episode_id: string | null
  movie_id: string | null
  member_id: string
}

/**
 * Model tv_profile_quick
 * 
 */
export type tv_profile_quick = {
  id: string
  created: Date
  updated: Date
  name: string
  tv_profile_id: string
}

/**
 * Model shared_file
 * 
 */
export type shared_file = {
  id: string
  created: Date
  updated: Date
  title: string | null
  url: string
  user_id: string
}

/**
 * Model shared_file_in_progress
 * 
 */
export type shared_file_in_progress = {
  id: string
  created: Date
  updated: Date
  url: string
  file_id: string
  name: string
  drive_id: string
  user_id: string
}

/**
 * Model bind_for_parsed_tv
 * 
 */
export type bind_for_parsed_tv = {
  id: string
  created: Date
  updated: Date
  url: string
  file_id: string
  name: string
  file_id_link_resource: string
  file_name_link_resource: string
  in_production: number | null
  invalid: number | null
  season_id: string | null
  drive_id: string
  user_id: string
}

/**
 * Model drive_check_in
 * 
 */
export type drive_check_in = {
  id: string
  created: Date
  updated: Date
  checked_at: Date | null
  drive_id: string
}

/**
 * Model tmp_file
 * 
 */
export type tmp_file = {
  id: string
  created: Date
  updated: Date
  name: string
  type: number | null
  parent_paths: string
  drive_id: string
  user_id: string
}

/**
 * Model incomplete_tv
 * 
 */
export type incomplete_tv = {
  id: string
  created: Date
  updated: Date
  episode_count: number | null
  cur_count: number | null
  user_id: string
}

/**
 * Model file
 * 
 */
export type file = {
  id: string
  created: Date
  updated: Date
  file_id: string
  name: string
  parent_file_id: string
  parent_paths: string
  type: number
  size: number | null
  drive_id: string
  user_id: string
}

/**
 * Model log
 * 
 */
export type log = {
  id: string
  created: Date
  updated: Date
  title: string
}

/**
 * Model member
 * 
 */
export type member = {
  id: string
  created: Date
  updated: Date
  email: string | null
  name: string | null
  avatar: string | null
  remark: string
  permission: string | null
  disabled: number | null
  delete: number | null
  inviter_id: string | null
  user_id: string
}

/**
 * Model member_token
 * 
 */
export type member_token = {
  id: string
  created: Date
  updated: Date
  token: string
  used: number | null
  expired_at: string | null
  member_id: string
}

/**
 * Model member_setting
 * 
 */
export type member_setting = {
  id: string
  created: Date
  updated: Date
  data: string
  member_id: string
}

/**
 * Model permission
 * 
 */
export type permission = {
  id: string
  created: Date
  updated: Date
  desc: string
  code: string
  user_id: string
}

/**
 * Model member_notification
 * 
 */
export type member_notification = {
  id: string
  created: Date
  updated: Date
  unique_id: string
  content: string | null
  type: number | null
  status: number | null
  is_delete: number | null
  member_id: string
}

/**
 * Model notification
 * 
 */
export type notification = {
  id: string
  created: Date
  updated: Date
  unique_id: string
  content: string | null
  type: number | null
  status: number | null
  is_delete: number | null
  user_id: string
}

/**
 * Model report
 * 
 */
export type report = {
  id: string
  created: Date
  updated: Date
  type: number
  data: string
  answer: string
  tv_id: string | null
  season_id: string | null
  episode_id: string | null
  movie_id: string | null
  member_id: string
  user_id: string
}

/**
 * Model account
 * 
 */
export type account = {
  id: string
  type: string
  provider: string
  provider_account_id: string
  refresh_token: string | null
  access_token: string | null
  expires_at: number | null
  token_type: string | null
  scope: string | null
  id_token: string | null
  session_state: string | null
  user_id: string
}

/**
 * Model credential
 * 
 */
export type credential = {
  id: string
  password: string
  salt: string
  verified: boolean
  email: string
  user_id: string
}

/**
 * Model profile
 * 
 */
export type profile = {
  id: string
  nickname: string | null
  avatar: string | null
  user_id: string
}

/**
 * Model settings
 * 
 */
export type settings = {
  id: string
  created: Date
  updated: Date
  detail: string | null
  user_id: string
}

/**
 * Model user
 * 
 */
export type user = {
  id: string
  created: Date
  updated: Date
}

declare module 'test' {
  export function eat(): void;
}

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Drives
 * const drives = await prisma.drive.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  GlobalReject extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined = 'rejectOnNotFound' extends keyof T
    ? T['rejectOnNotFound']
    : false
      > {
    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Drives
   * const drives = await prisma.drive.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends (U | 'beforeExit')>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : V extends 'beforeExit' ? () => Promise<void> : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): Promise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): Promise<void>;

  /**
   * Add a middleware
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  // $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  // $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<this, "$connect" | "$disconnect" | "$on" | "$transaction" | "$use">) => Promise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): Promise<R>

      /**
   * `prisma.drive`: Exposes CRUD operations for the **drive** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drives
    * const drives = await prisma.drive.findMany()
    * ```
    */
  get drive(): Prisma.driveDelegate<GlobalReject>;

  /**
   * `prisma.drive_token`: Exposes CRUD operations for the **drive_token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drive_tokens
    * const drive_tokens = await prisma.drive_token.findMany()
    * ```
    */
  get drive_token(): Prisma.drive_tokenDelegate<GlobalReject>;

  /**
   * `prisma.tv_profile`: Exposes CRUD operations for the **tv_profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tv_profiles
    * const tv_profiles = await prisma.tv_profile.findMany()
    * ```
    */
  get tv_profile(): Prisma.tv_profileDelegate<GlobalReject>;

  /**
   * `prisma.season_profile`: Exposes CRUD operations for the **season_profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Season_profiles
    * const season_profiles = await prisma.season_profile.findMany()
    * ```
    */
  get season_profile(): Prisma.season_profileDelegate<GlobalReject>;

  /**
   * `prisma.episode_profile`: Exposes CRUD operations for the **episode_profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Episode_profiles
    * const episode_profiles = await prisma.episode_profile.findMany()
    * ```
    */
  get episode_profile(): Prisma.episode_profileDelegate<GlobalReject>;

  /**
   * `prisma.movie_profile`: Exposes CRUD operations for the **movie_profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movie_profiles
    * const movie_profiles = await prisma.movie_profile.findMany()
    * ```
    */
  get movie_profile(): Prisma.movie_profileDelegate<GlobalReject>;

  /**
   * `prisma.subtitle`: Exposes CRUD operations for the **subtitle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Subtitles
    * const subtitles = await prisma.subtitle.findMany()
    * ```
    */
  get subtitle(): Prisma.subtitleDelegate<GlobalReject>;

  /**
   * `prisma.parsed_tv`: Exposes CRUD operations for the **parsed_tv** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parsed_tvs
    * const parsed_tvs = await prisma.parsed_tv.findMany()
    * ```
    */
  get parsed_tv(): Prisma.parsed_tvDelegate<GlobalReject>;

  /**
   * `prisma.parsed_season`: Exposes CRUD operations for the **parsed_season** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parsed_seasons
    * const parsed_seasons = await prisma.parsed_season.findMany()
    * ```
    */
  get parsed_season(): Prisma.parsed_seasonDelegate<GlobalReject>;

  /**
   * `prisma.parsed_episode`: Exposes CRUD operations for the **parsed_episode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parsed_episodes
    * const parsed_episodes = await prisma.parsed_episode.findMany()
    * ```
    */
  get parsed_episode(): Prisma.parsed_episodeDelegate<GlobalReject>;

  /**
   * `prisma.parsed_movie`: Exposes CRUD operations for the **parsed_movie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Parsed_movies
    * const parsed_movies = await prisma.parsed_movie.findMany()
    * ```
    */
  get parsed_movie(): Prisma.parsed_movieDelegate<GlobalReject>;

  /**
   * `prisma.tv`: Exposes CRUD operations for the **tv** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tvs
    * const tvs = await prisma.tv.findMany()
    * ```
    */
  get tv(): Prisma.tvDelegate<GlobalReject>;

  /**
   * `prisma.season`: Exposes CRUD operations for the **season** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Seasons
    * const seasons = await prisma.season.findMany()
    * ```
    */
  get season(): Prisma.seasonDelegate<GlobalReject>;

  /**
   * `prisma.episode`: Exposes CRUD operations for the **episode** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Episodes
    * const episodes = await prisma.episode.findMany()
    * ```
    */
  get episode(): Prisma.episodeDelegate<GlobalReject>;

  /**
   * `prisma.movie`: Exposes CRUD operations for the **movie** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Movies
    * const movies = await prisma.movie.findMany()
    * ```
    */
  get movie(): Prisma.movieDelegate<GlobalReject>;

  /**
   * `prisma.collection`: Exposes CRUD operations for the **collection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Collections
    * const collections = await prisma.collection.findMany()
    * ```
    */
  get collection(): Prisma.collectionDelegate<GlobalReject>;

  /**
   * `prisma.async_task`: Exposes CRUD operations for the **async_task** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Async_tasks
    * const async_tasks = await prisma.async_task.findMany()
    * ```
    */
  get async_task(): Prisma.async_taskDelegate<GlobalReject>;

  /**
   * `prisma.output`: Exposes CRUD operations for the **output** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Outputs
    * const outputs = await prisma.output.findMany()
    * ```
    */
  get output(): Prisma.outputDelegate<GlobalReject>;

  /**
   * `prisma.output_line`: Exposes CRUD operations for the **output_line** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Output_lines
    * const output_lines = await prisma.output_line.findMany()
    * ```
    */
  get output_line(): Prisma.output_lineDelegate<GlobalReject>;

  /**
   * `prisma.play_history`: Exposes CRUD operations for the **play_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Play_histories
    * const play_histories = await prisma.play_history.findMany()
    * ```
    */
  get play_history(): Prisma.play_historyDelegate<GlobalReject>;

  /**
   * `prisma.tv_profile_quick`: Exposes CRUD operations for the **tv_profile_quick** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tv_profile_quicks
    * const tv_profile_quicks = await prisma.tv_profile_quick.findMany()
    * ```
    */
  get tv_profile_quick(): Prisma.tv_profile_quickDelegate<GlobalReject>;

  /**
   * `prisma.shared_file`: Exposes CRUD operations for the **shared_file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shared_files
    * const shared_files = await prisma.shared_file.findMany()
    * ```
    */
  get shared_file(): Prisma.shared_fileDelegate<GlobalReject>;

  /**
   * `prisma.shared_file_in_progress`: Exposes CRUD operations for the **shared_file_in_progress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shared_file_in_progresses
    * const shared_file_in_progresses = await prisma.shared_file_in_progress.findMany()
    * ```
    */
  get shared_file_in_progress(): Prisma.shared_file_in_progressDelegate<GlobalReject>;

  /**
   * `prisma.bind_for_parsed_tv`: Exposes CRUD operations for the **bind_for_parsed_tv** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bind_for_parsed_tvs
    * const bind_for_parsed_tvs = await prisma.bind_for_parsed_tv.findMany()
    * ```
    */
  get bind_for_parsed_tv(): Prisma.bind_for_parsed_tvDelegate<GlobalReject>;

  /**
   * `prisma.drive_check_in`: Exposes CRUD operations for the **drive_check_in** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Drive_check_ins
    * const drive_check_ins = await prisma.drive_check_in.findMany()
    * ```
    */
  get drive_check_in(): Prisma.drive_check_inDelegate<GlobalReject>;

  /**
   * `prisma.tmp_file`: Exposes CRUD operations for the **tmp_file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Tmp_files
    * const tmp_files = await prisma.tmp_file.findMany()
    * ```
    */
  get tmp_file(): Prisma.tmp_fileDelegate<GlobalReject>;

  /**
   * `prisma.incomplete_tv`: Exposes CRUD operations for the **incomplete_tv** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Incomplete_tvs
    * const incomplete_tvs = await prisma.incomplete_tv.findMany()
    * ```
    */
  get incomplete_tv(): Prisma.incomplete_tvDelegate<GlobalReject>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **file** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.fileDelegate<GlobalReject>;

  /**
   * `prisma.log`: Exposes CRUD operations for the **log** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Logs
    * const logs = await prisma.log.findMany()
    * ```
    */
  get log(): Prisma.logDelegate<GlobalReject>;

  /**
   * `prisma.member`: Exposes CRUD operations for the **member** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Members
    * const members = await prisma.member.findMany()
    * ```
    */
  get member(): Prisma.memberDelegate<GlobalReject>;

  /**
   * `prisma.member_token`: Exposes CRUD operations for the **member_token** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Member_tokens
    * const member_tokens = await prisma.member_token.findMany()
    * ```
    */
  get member_token(): Prisma.member_tokenDelegate<GlobalReject>;

  /**
   * `prisma.member_setting`: Exposes CRUD operations for the **member_setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Member_settings
    * const member_settings = await prisma.member_setting.findMany()
    * ```
    */
  get member_setting(): Prisma.member_settingDelegate<GlobalReject>;

  /**
   * `prisma.permission`: Exposes CRUD operations for the **permission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Permissions
    * const permissions = await prisma.permission.findMany()
    * ```
    */
  get permission(): Prisma.permissionDelegate<GlobalReject>;

  /**
   * `prisma.member_notification`: Exposes CRUD operations for the **member_notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Member_notifications
    * const member_notifications = await prisma.member_notification.findMany()
    * ```
    */
  get member_notification(): Prisma.member_notificationDelegate<GlobalReject>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.notificationDelegate<GlobalReject>;

  /**
   * `prisma.report`: Exposes CRUD operations for the **report** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Reports
    * const reports = await prisma.report.findMany()
    * ```
    */
  get report(): Prisma.reportDelegate<GlobalReject>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.accountDelegate<GlobalReject>;

  /**
   * `prisma.credential`: Exposes CRUD operations for the **credential** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Credentials
    * const credentials = await prisma.credential.findMany()
    * ```
    */
  get credential(): Prisma.credentialDelegate<GlobalReject>;

  /**
   * `prisma.profile`: Exposes CRUD operations for the **profile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Profiles
    * const profiles = await prisma.profile.findMany()
    * ```
    */
  get profile(): Prisma.profileDelegate<GlobalReject>;

  /**
   * `prisma.settings`: Exposes CRUD operations for the **settings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.settings.findMany()
    * ```
    */
  get settings(): Prisma.settingsDelegate<GlobalReject>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **user** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.userDelegate<GlobalReject>;
}

export namespace Prisma {
  // export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = runtime.Types.Public.PrismaPromise<T>

  /**
   * Prisma Errors
   */
  // export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  // export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  // export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  // export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  // export import PrismaClientValidationError = runtime.PrismaClientValidationError
  // export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  // export import sql = runtime.sqltag
  // export import empty = runtime.empty
  // export import join = runtime.join
  // export import raw = runtime.raw
  // export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  // export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket


  /**
   * Prisma Client JS version: 4.13.0
   * Query Engine version: d9a4c5988f480fa576d43970d5a23641aa77bc9c
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }
  type HasSelect = {
    select: any
  }
  type HasInclude = {
    include: any
  }
  type CheckSelect<T, S, U> = T extends SelectAndInclude
    ? 'Please either choose `select` or `include`'
    : T extends HasSelect
    ? U
    : T extends HasInclude
    ? U
    : S

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => Promise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;

  export function validator<V>(): <S>(select: runtime.Types.Utils.LegacyExact<S, V>) => S;

  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but with an array
   */
  type PickArray<T, K extends Array<keyof T>> = Prisma__Pick<T, TupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    drive: 'drive',
    drive_token: 'drive_token',
    tv_profile: 'tv_profile',
    season_profile: 'season_profile',
    episode_profile: 'episode_profile',
    movie_profile: 'movie_profile',
    subtitle: 'subtitle',
    parsed_tv: 'parsed_tv',
    parsed_season: 'parsed_season',
    parsed_episode: 'parsed_episode',
    parsed_movie: 'parsed_movie',
    tv: 'tv',
    season: 'season',
    episode: 'episode',
    movie: 'movie',
    collection: 'collection',
    async_task: 'async_task',
    output: 'output',
    output_line: 'output_line',
    play_history: 'play_history',
    tv_profile_quick: 'tv_profile_quick',
    shared_file: 'shared_file',
    shared_file_in_progress: 'shared_file_in_progress',
    bind_for_parsed_tv: 'bind_for_parsed_tv',
    drive_check_in: 'drive_check_in',
    tmp_file: 'tmp_file',
    incomplete_tv: 'incomplete_tv',
    file: 'file',
    log: 'log',
    member: 'member',
    member_token: 'member_token',
    member_setting: 'member_setting',
    permission: 'permission',
    member_notification: 'member_notification',
    notification: 'notification',
    report: 'report',
    account: 'account',
    credential: 'credential',
    profile: 'profile',
    settings: 'settings',
    user: 'user'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  export type DefaultPrismaClient = PrismaClient
  export type RejectOnNotFound = boolean | ((error: Error) => Error)
  export type RejectPerModel = { [P in ModelName]?: RejectOnNotFound }
  export type RejectPerOperation =  { [P in "findUnique" | "findFirst"]?: RejectPerModel | RejectOnNotFound } 
  type IsReject<T> = T extends true ? True : T extends (err: Error) => Error ? True : False
  export type HasReject<
    GlobalRejectSettings extends Prisma.PrismaClientOptions['rejectOnNotFound'],
    LocalRejectSettings,
    Action extends PrismaAction,
    Model extends ModelName
  > = LocalRejectSettings extends RejectOnNotFound
    ? IsReject<LocalRejectSettings>
    : GlobalRejectSettings extends RejectPerOperation
    ? Action extends keyof GlobalRejectSettings
      ? GlobalRejectSettings[Action] extends RejectOnNotFound
        ? IsReject<GlobalRejectSettings[Action]>
        : GlobalRejectSettings[Action] extends RejectPerModel
        ? Model extends keyof GlobalRejectSettings[Action]
          ? IsReject<GlobalRejectSettings[Action][Model]>
          : False
        : False
      : False
    : IsReject<GlobalRejectSettings>
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'

  export interface PrismaClientOptions {
    /**
     * Configure findUnique/findFirst to throw an error if the query returns null. 
     * @deprecated since 4.0.0. Use `findUniqueOrThrow`/`findFirstOrThrow` methods instead.
     * @example
     * ```
     * // Reject on both findUnique/findFirst
     * rejectOnNotFound: true
     * // Reject only on findFirst with a custom error
     * rejectOnNotFound: { findFirst: (err) => new Error("Custom Error")}
     * // Reject on user.findUnique with a custom error
     * rejectOnNotFound: { findUnique: {User: (err) => new Error("User not found")}}
     * ```
     */
    rejectOnNotFound?: RejectOnNotFound | RejectPerOperation
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources

    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat

    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: Array<LogLevel | LogDefinition>
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findMany'
    | 'findFirst'
    | 'create'
    | 'createMany'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => Promise<T>,
  ) => Promise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, '$connect' | '$disconnect' | '$on' | '$transaction' | '$use'>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type DriveCountOutputType
   */


  export type DriveCountOutputType = {
    parsed_tvs: number
    parsed_seasons: number
    parsed_episodes: number
    drive_check_in: number
    files: number
    tmp_files: number
    parsed_movies: number
    shared_file_in_progress: number
    subtitles: number
    sync_tasks: number
  }

  export type DriveCountOutputTypeSelect = {
    parsed_tvs?: boolean
    parsed_seasons?: boolean
    parsed_episodes?: boolean
    drive_check_in?: boolean
    files?: boolean
    tmp_files?: boolean
    parsed_movies?: boolean
    shared_file_in_progress?: boolean
    subtitles?: boolean
    sync_tasks?: boolean
  }

  export type DriveCountOutputTypeGetPayload<S extends boolean | null | undefined | DriveCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? DriveCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (DriveCountOutputTypeArgs)
    ? DriveCountOutputType 
    : S extends { select: any } & (DriveCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof DriveCountOutputType ? DriveCountOutputType[P] : never
  } 
      : DriveCountOutputType




  // Custom InputTypes

  /**
   * DriveCountOutputType without action
   */
  export type DriveCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the DriveCountOutputType
     */
    select?: DriveCountOutputTypeSelect | null
  }



  /**
   * Count Type Drive_tokenCountOutputType
   */


  export type Drive_tokenCountOutputType = {
    drives: number
  }

  export type Drive_tokenCountOutputTypeSelect = {
    drives?: boolean
  }

  export type Drive_tokenCountOutputTypeGetPayload<S extends boolean | null | undefined | Drive_tokenCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Drive_tokenCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Drive_tokenCountOutputTypeArgs)
    ? Drive_tokenCountOutputType 
    : S extends { select: any } & (Drive_tokenCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Drive_tokenCountOutputType ? Drive_tokenCountOutputType[P] : never
  } 
      : Drive_tokenCountOutputType




  // Custom InputTypes

  /**
   * Drive_tokenCountOutputType without action
   */
  export type Drive_tokenCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Drive_tokenCountOutputType
     */
    select?: Drive_tokenCountOutputTypeSelect | null
  }



  /**
   * Count Type Tv_profileCountOutputType
   */


  export type Tv_profileCountOutputType = {
    tvs: number
    snapshots: number
  }

  export type Tv_profileCountOutputTypeSelect = {
    tvs?: boolean
    snapshots?: boolean
  }

  export type Tv_profileCountOutputTypeGetPayload<S extends boolean | null | undefined | Tv_profileCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Tv_profileCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Tv_profileCountOutputTypeArgs)
    ? Tv_profileCountOutputType 
    : S extends { select: any } & (Tv_profileCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Tv_profileCountOutputType ? Tv_profileCountOutputType[P] : never
  } 
      : Tv_profileCountOutputType




  // Custom InputTypes

  /**
   * Tv_profileCountOutputType without action
   */
  export type Tv_profileCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Tv_profileCountOutputType
     */
    select?: Tv_profileCountOutputTypeSelect | null
  }



  /**
   * Count Type Season_profileCountOutputType
   */


  export type Season_profileCountOutputType = {
    seasons: number
  }

  export type Season_profileCountOutputTypeSelect = {
    seasons?: boolean
  }

  export type Season_profileCountOutputTypeGetPayload<S extends boolean | null | undefined | Season_profileCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Season_profileCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Season_profileCountOutputTypeArgs)
    ? Season_profileCountOutputType 
    : S extends { select: any } & (Season_profileCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Season_profileCountOutputType ? Season_profileCountOutputType[P] : never
  } 
      : Season_profileCountOutputType




  // Custom InputTypes

  /**
   * Season_profileCountOutputType without action
   */
  export type Season_profileCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Season_profileCountOutputType
     */
    select?: Season_profileCountOutputTypeSelect | null
  }



  /**
   * Count Type Episode_profileCountOutputType
   */


  export type Episode_profileCountOutputType = {
    episodes: number
  }

  export type Episode_profileCountOutputTypeSelect = {
    episodes?: boolean
  }

  export type Episode_profileCountOutputTypeGetPayload<S extends boolean | null | undefined | Episode_profileCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Episode_profileCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Episode_profileCountOutputTypeArgs)
    ? Episode_profileCountOutputType 
    : S extends { select: any } & (Episode_profileCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Episode_profileCountOutputType ? Episode_profileCountOutputType[P] : never
  } 
      : Episode_profileCountOutputType




  // Custom InputTypes

  /**
   * Episode_profileCountOutputType without action
   */
  export type Episode_profileCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Episode_profileCountOutputType
     */
    select?: Episode_profileCountOutputTypeSelect | null
  }



  /**
   * Count Type Movie_profileCountOutputType
   */


  export type Movie_profileCountOutputType = {
    movies: number
  }

  export type Movie_profileCountOutputTypeSelect = {
    movies?: boolean
  }

  export type Movie_profileCountOutputTypeGetPayload<S extends boolean | null | undefined | Movie_profileCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Movie_profileCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Movie_profileCountOutputTypeArgs)
    ? Movie_profileCountOutputType 
    : S extends { select: any } & (Movie_profileCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Movie_profileCountOutputType ? Movie_profileCountOutputType[P] : never
  } 
      : Movie_profileCountOutputType




  // Custom InputTypes

  /**
   * Movie_profileCountOutputType without action
   */
  export type Movie_profileCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Movie_profileCountOutputType
     */
    select?: Movie_profileCountOutputTypeSelect | null
  }



  /**
   * Count Type Parsed_tvCountOutputType
   */


  export type Parsed_tvCountOutputType = {
    parsed_episodes: number
    parsed_seasons: number
  }

  export type Parsed_tvCountOutputTypeSelect = {
    parsed_episodes?: boolean
    parsed_seasons?: boolean
  }

  export type Parsed_tvCountOutputTypeGetPayload<S extends boolean | null | undefined | Parsed_tvCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Parsed_tvCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Parsed_tvCountOutputTypeArgs)
    ? Parsed_tvCountOutputType 
    : S extends { select: any } & (Parsed_tvCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Parsed_tvCountOutputType ? Parsed_tvCountOutputType[P] : never
  } 
      : Parsed_tvCountOutputType




  // Custom InputTypes

  /**
   * Parsed_tvCountOutputType without action
   */
  export type Parsed_tvCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Parsed_tvCountOutputType
     */
    select?: Parsed_tvCountOutputTypeSelect | null
  }



  /**
   * Count Type Parsed_seasonCountOutputType
   */


  export type Parsed_seasonCountOutputType = {
    parsed_episodes: number
  }

  export type Parsed_seasonCountOutputTypeSelect = {
    parsed_episodes?: boolean
  }

  export type Parsed_seasonCountOutputTypeGetPayload<S extends boolean | null | undefined | Parsed_seasonCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? Parsed_seasonCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (Parsed_seasonCountOutputTypeArgs)
    ? Parsed_seasonCountOutputType 
    : S extends { select: any } & (Parsed_seasonCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof Parsed_seasonCountOutputType ? Parsed_seasonCountOutputType[P] : never
  } 
      : Parsed_seasonCountOutputType




  // Custom InputTypes

  /**
   * Parsed_seasonCountOutputType without action
   */
  export type Parsed_seasonCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the Parsed_seasonCountOutputType
     */
    select?: Parsed_seasonCountOutputTypeSelect | null
  }



  /**
   * Count Type TvCountOutputType
   */


  export type TvCountOutputType = {
    seasons: number
    episodes: number
    play_histories: number
    parsed_tvs: number
    reports: number
  }

  export type TvCountOutputTypeSelect = {
    seasons?: boolean
    episodes?: boolean
    play_histories?: boolean
    parsed_tvs?: boolean
    reports?: boolean
  }

  export type TvCountOutputTypeGetPayload<S extends boolean | null | undefined | TvCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? TvCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (TvCountOutputTypeArgs)
    ? TvCountOutputType 
    : S extends { select: any } & (TvCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof TvCountOutputType ? TvCountOutputType[P] : never
  } 
      : TvCountOutputType




  // Custom InputTypes

  /**
   * TvCountOutputType without action
   */
  export type TvCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the TvCountOutputType
     */
    select?: TvCountOutputTypeSelect | null
  }



  /**
   * Count Type SeasonCountOutputType
   */


  export type SeasonCountOutputType = {
    parsed_season: number
    play_histories: number
    episodes: number
    reports: number
    sync_tasks: number
  }

  export type SeasonCountOutputTypeSelect = {
    parsed_season?: boolean
    play_histories?: boolean
    episodes?: boolean
    reports?: boolean
    sync_tasks?: boolean
  }

  export type SeasonCountOutputTypeGetPayload<S extends boolean | null | undefined | SeasonCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? SeasonCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (SeasonCountOutputTypeArgs)
    ? SeasonCountOutputType 
    : S extends { select: any } & (SeasonCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof SeasonCountOutputType ? SeasonCountOutputType[P] : never
  } 
      : SeasonCountOutputType




  // Custom InputTypes

  /**
   * SeasonCountOutputType without action
   */
  export type SeasonCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the SeasonCountOutputType
     */
    select?: SeasonCountOutputTypeSelect | null
  }



  /**
   * Count Type EpisodeCountOutputType
   */


  export type EpisodeCountOutputType = {
    parsed_episodes: number
    play_histories: number
    reports: number
    subtitles: number
  }

  export type EpisodeCountOutputTypeSelect = {
    parsed_episodes?: boolean
    play_histories?: boolean
    reports?: boolean
    subtitles?: boolean
  }

  export type EpisodeCountOutputTypeGetPayload<S extends boolean | null | undefined | EpisodeCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? EpisodeCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (EpisodeCountOutputTypeArgs)
    ? EpisodeCountOutputType 
    : S extends { select: any } & (EpisodeCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof EpisodeCountOutputType ? EpisodeCountOutputType[P] : never
  } 
      : EpisodeCountOutputType




  // Custom InputTypes

  /**
   * EpisodeCountOutputType without action
   */
  export type EpisodeCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the EpisodeCountOutputType
     */
    select?: EpisodeCountOutputTypeSelect | null
  }



  /**
   * Count Type MovieCountOutputType
   */


  export type MovieCountOutputType = {
    play_histories: number
    parsed_movies: number
    reports: number
    subtitles: number
  }

  export type MovieCountOutputTypeSelect = {
    play_histories?: boolean
    parsed_movies?: boolean
    reports?: boolean
    subtitles?: boolean
  }

  export type MovieCountOutputTypeGetPayload<S extends boolean | null | undefined | MovieCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MovieCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MovieCountOutputTypeArgs)
    ? MovieCountOutputType 
    : S extends { select: any } & (MovieCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MovieCountOutputType ? MovieCountOutputType[P] : never
  } 
      : MovieCountOutputType




  // Custom InputTypes

  /**
   * MovieCountOutputType without action
   */
  export type MovieCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MovieCountOutputType
     */
    select?: MovieCountOutputTypeSelect | null
  }



  /**
   * Count Type CollectionCountOutputType
   */


  export type CollectionCountOutputType = {
    tvs: number
    seasons: number
    movies: number
  }

  export type CollectionCountOutputTypeSelect = {
    tvs?: boolean
    seasons?: boolean
    movies?: boolean
  }

  export type CollectionCountOutputTypeGetPayload<S extends boolean | null | undefined | CollectionCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? CollectionCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (CollectionCountOutputTypeArgs)
    ? CollectionCountOutputType 
    : S extends { select: any } & (CollectionCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof CollectionCountOutputType ? CollectionCountOutputType[P] : never
  } 
      : CollectionCountOutputType




  // Custom InputTypes

  /**
   * CollectionCountOutputType without action
   */
  export type CollectionCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the CollectionCountOutputType
     */
    select?: CollectionCountOutputTypeSelect | null
  }



  /**
   * Count Type OutputCountOutputType
   */


  export type OutputCountOutputType = {
    lines: number
  }

  export type OutputCountOutputTypeSelect = {
    lines?: boolean
  }

  export type OutputCountOutputTypeGetPayload<S extends boolean | null | undefined | OutputCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? OutputCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (OutputCountOutputTypeArgs)
    ? OutputCountOutputType 
    : S extends { select: any } & (OutputCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof OutputCountOutputType ? OutputCountOutputType[P] : never
  } 
      : OutputCountOutputType




  // Custom InputTypes

  /**
   * OutputCountOutputType without action
   */
  export type OutputCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the OutputCountOutputType
     */
    select?: OutputCountOutputTypeSelect | null
  }



  /**
   * Count Type MemberCountOutputType
   */


  export type MemberCountOutputType = {
    member_tokens: number
    play_histories: number
    reports: number
    invitees: number
    notifications: number
  }

  export type MemberCountOutputTypeSelect = {
    member_tokens?: boolean
    play_histories?: boolean
    reports?: boolean
    invitees?: boolean
    notifications?: boolean
  }

  export type MemberCountOutputTypeGetPayload<S extends boolean | null | undefined | MemberCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? MemberCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (MemberCountOutputTypeArgs)
    ? MemberCountOutputType 
    : S extends { select: any } & (MemberCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof MemberCountOutputType ? MemberCountOutputType[P] : never
  } 
      : MemberCountOutputType




  // Custom InputTypes

  /**
   * MemberCountOutputType without action
   */
  export type MemberCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the MemberCountOutputType
     */
    select?: MemberCountOutputTypeSelect | null
  }



  /**
   * Count Type UserCountOutputType
   */


  export type UserCountOutputType = {
    accounts: number
    drives: number
    tv: number
    seasons: number
    episode: number
    movie: number
    parsed_tvs: number
    parsed_seasons: number
    parsed_episodes: number
    parsed_movies: number
    tv_need_complete: number
    async_task: number
    files: number
    members: number
    shared_files: number
    shared_file_in_progress: number
    tmp_files: number
    sync_tasks: number
    notifications: number
    outputs: number
    reports: number
    collections: number
    subtitles: number
    permission: number
  }

  export type UserCountOutputTypeSelect = {
    accounts?: boolean
    drives?: boolean
    tv?: boolean
    seasons?: boolean
    episode?: boolean
    movie?: boolean
    parsed_tvs?: boolean
    parsed_seasons?: boolean
    parsed_episodes?: boolean
    parsed_movies?: boolean
    tv_need_complete?: boolean
    async_task?: boolean
    files?: boolean
    members?: boolean
    shared_files?: boolean
    shared_file_in_progress?: boolean
    tmp_files?: boolean
    sync_tasks?: boolean
    notifications?: boolean
    outputs?: boolean
    reports?: boolean
    collections?: boolean
    subtitles?: boolean
    permission?: boolean
  }

  export type UserCountOutputTypeGetPayload<S extends boolean | null | undefined | UserCountOutputTypeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? UserCountOutputType :
    S extends undefined ? never :
    S extends { include: any } & (UserCountOutputTypeArgs)
    ? UserCountOutputType 
    : S extends { select: any } & (UserCountOutputTypeArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof UserCountOutputType ? UserCountOutputType[P] : never
  } 
      : UserCountOutputType




  // Custom InputTypes

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeArgs = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect | null
  }



  /**
   * Models
   */

  /**
   * Model drive
   */


  export type AggregateDrive = {
    _count: DriveCountAggregateOutputType | null
    _avg: DriveAvgAggregateOutputType | null
    _sum: DriveSumAggregateOutputType | null
    _min: DriveMinAggregateOutputType | null
    _max: DriveMaxAggregateOutputType | null
  }

  export type DriveAvgAggregateOutputType = {
    type: number | null
    total_size: number | null
    used_size: number | null
    invalid: number | null
  }

  export type DriveSumAggregateOutputType = {
    type: number | null
    total_size: number | null
    used_size: number | null
    invalid: number | null
  }

  export type DriveMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    type: number | null
    name: string | null
    remark: string | null
    avatar: string | null
    profile: string | null
    total_size: number | null
    used_size: number | null
    invalid: number | null
    latest_analysis: Date | null
    root_folder_name: string | null
    root_folder_id: string | null
    drive_token_id: string | null
    user_id: string | null
  }

  export type DriveMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    type: number | null
    name: string | null
    remark: string | null
    avatar: string | null
    profile: string | null
    total_size: number | null
    used_size: number | null
    invalid: number | null
    latest_analysis: Date | null
    root_folder_name: string | null
    root_folder_id: string | null
    drive_token_id: string | null
    user_id: string | null
  }

  export type DriveCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    unique_id: number
    type: number
    name: number
    remark: number
    avatar: number
    profile: number
    total_size: number
    used_size: number
    invalid: number
    latest_analysis: number
    root_folder_name: number
    root_folder_id: number
    drive_token_id: number
    user_id: number
    _all: number
  }


  export type DriveAvgAggregateInputType = {
    type?: true
    total_size?: true
    used_size?: true
    invalid?: true
  }

  export type DriveSumAggregateInputType = {
    type?: true
    total_size?: true
    used_size?: true
    invalid?: true
  }

  export type DriveMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    type?: true
    name?: true
    remark?: true
    avatar?: true
    profile?: true
    total_size?: true
    used_size?: true
    invalid?: true
    latest_analysis?: true
    root_folder_name?: true
    root_folder_id?: true
    drive_token_id?: true
    user_id?: true
  }

  export type DriveMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    type?: true
    name?: true
    remark?: true
    avatar?: true
    profile?: true
    total_size?: true
    used_size?: true
    invalid?: true
    latest_analysis?: true
    root_folder_name?: true
    root_folder_id?: true
    drive_token_id?: true
    user_id?: true
  }

  export type DriveCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    type?: true
    name?: true
    remark?: true
    avatar?: true
    profile?: true
    total_size?: true
    used_size?: true
    invalid?: true
    latest_analysis?: true
    root_folder_name?: true
    root_folder_id?: true
    drive_token_id?: true
    user_id?: true
    _all?: true
  }

  export type DriveAggregateArgs = {
    /**
     * Filter which drive to aggregate.
     */
    where?: driveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drives to fetch.
     */
    orderBy?: Enumerable<driveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: driveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drives
    **/
    _count?: true | DriveCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DriveAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DriveSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DriveMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DriveMaxAggregateInputType
  }

  export type GetDriveAggregateType<T extends DriveAggregateArgs> = {
        [P in keyof T & keyof AggregateDrive]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrive[P]>
      : GetScalarType<T[P], AggregateDrive[P]>
  }




  export type DriveGroupByArgs = {
    where?: driveWhereInput
    orderBy?: Enumerable<driveOrderByWithAggregationInput>
    by: DriveScalarFieldEnum[]
    having?: driveScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DriveCountAggregateInputType | true
    _avg?: DriveAvgAggregateInputType
    _sum?: DriveSumAggregateInputType
    _min?: DriveMinAggregateInputType
    _max?: DriveMaxAggregateInputType
  }


  export type DriveGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    unique_id: string
    type: number | null
    name: string
    remark: string | null
    avatar: string
    profile: string
    total_size: number | null
    used_size: number | null
    invalid: number | null
    latest_analysis: Date | null
    root_folder_name: string | null
    root_folder_id: string | null
    drive_token_id: string
    user_id: string
    _count: DriveCountAggregateOutputType | null
    _avg: DriveAvgAggregateOutputType | null
    _sum: DriveSumAggregateOutputType | null
    _min: DriveMinAggregateOutputType | null
    _max: DriveMaxAggregateOutputType | null
  }

  type GetDriveGroupByPayload<T extends DriveGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<DriveGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DriveGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DriveGroupByOutputType[P]>
            : GetScalarType<T[P], DriveGroupByOutputType[P]>
        }
      >
    >


  export type driveSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    unique_id?: boolean
    type?: boolean
    name?: boolean
    remark?: boolean
    avatar?: boolean
    profile?: boolean
    total_size?: boolean
    used_size?: boolean
    invalid?: boolean
    latest_analysis?: boolean
    root_folder_name?: boolean
    root_folder_id?: boolean
    drive_token_id?: boolean
    user_id?: boolean
    drive_token?: boolean | drive_tokenArgs
    user?: boolean | userArgs
    parsed_tvs?: boolean | drive$parsed_tvsArgs
    parsed_seasons?: boolean | drive$parsed_seasonsArgs
    parsed_episodes?: boolean | drive$parsed_episodesArgs
    drive_check_in?: boolean | drive$drive_check_inArgs
    files?: boolean | drive$filesArgs
    tmp_files?: boolean | drive$tmp_filesArgs
    parsed_movies?: boolean | drive$parsed_moviesArgs
    shared_file_in_progress?: boolean | drive$shared_file_in_progressArgs
    subtitles?: boolean | drive$subtitlesArgs
    sync_tasks?: boolean | drive$sync_tasksArgs
    _count?: boolean | DriveCountOutputTypeArgs
  }


  export type driveInclude = {
    drive_token?: boolean | drive_tokenArgs
    user?: boolean | userArgs
    parsed_tvs?: boolean | drive$parsed_tvsArgs
    parsed_seasons?: boolean | drive$parsed_seasonsArgs
    parsed_episodes?: boolean | drive$parsed_episodesArgs
    drive_check_in?: boolean | drive$drive_check_inArgs
    files?: boolean | drive$filesArgs
    tmp_files?: boolean | drive$tmp_filesArgs
    parsed_movies?: boolean | drive$parsed_moviesArgs
    shared_file_in_progress?: boolean | drive$shared_file_in_progressArgs
    subtitles?: boolean | drive$subtitlesArgs
    sync_tasks?: boolean | drive$sync_tasksArgs
    _count?: boolean | DriveCountOutputTypeArgs
  }

  export type driveGetPayload<S extends boolean | null | undefined | driveArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? drive :
    S extends undefined ? never :
    S extends { include: any } & (driveArgs | driveFindManyArgs)
    ? drive  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'drive_token' ? drive_tokenGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends 'parsed_tvs' ? Array < parsed_tvGetPayload<S['include'][P]>>  :
        P extends 'parsed_seasons' ? Array < parsed_seasonGetPayload<S['include'][P]>>  :
        P extends 'parsed_episodes' ? Array < parsed_episodeGetPayload<S['include'][P]>>  :
        P extends 'drive_check_in' ? Array < drive_check_inGetPayload<S['include'][P]>>  :
        P extends 'files' ? Array < fileGetPayload<S['include'][P]>>  :
        P extends 'tmp_files' ? Array < tmp_fileGetPayload<S['include'][P]>>  :
        P extends 'parsed_movies' ? Array < parsed_movieGetPayload<S['include'][P]>>  :
        P extends 'shared_file_in_progress' ? Array < shared_file_in_progressGetPayload<S['include'][P]>>  :
        P extends 'subtitles' ? Array < subtitleGetPayload<S['include'][P]>>  :
        P extends 'sync_tasks' ? Array < bind_for_parsed_tvGetPayload<S['include'][P]>>  :
        P extends '_count' ? DriveCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (driveArgs | driveFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'drive_token' ? drive_tokenGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends 'parsed_tvs' ? Array < parsed_tvGetPayload<S['select'][P]>>  :
        P extends 'parsed_seasons' ? Array < parsed_seasonGetPayload<S['select'][P]>>  :
        P extends 'parsed_episodes' ? Array < parsed_episodeGetPayload<S['select'][P]>>  :
        P extends 'drive_check_in' ? Array < drive_check_inGetPayload<S['select'][P]>>  :
        P extends 'files' ? Array < fileGetPayload<S['select'][P]>>  :
        P extends 'tmp_files' ? Array < tmp_fileGetPayload<S['select'][P]>>  :
        P extends 'parsed_movies' ? Array < parsed_movieGetPayload<S['select'][P]>>  :
        P extends 'shared_file_in_progress' ? Array < shared_file_in_progressGetPayload<S['select'][P]>>  :
        P extends 'subtitles' ? Array < subtitleGetPayload<S['select'][P]>>  :
        P extends 'sync_tasks' ? Array < bind_for_parsed_tvGetPayload<S['select'][P]>>  :
        P extends '_count' ? DriveCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof drive ? drive[P] : never
  } 
      : drive


  type driveCountArgs = 
    Omit<driveFindManyArgs, 'select' | 'include'> & {
      select?: DriveCountAggregateInputType | true
    }

  export interface driveDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Drive that matches the filter.
     * @param {driveFindUniqueArgs} args - Arguments to find a Drive
     * @example
     * // Get one Drive
     * const drive = await prisma.drive.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends driveFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, driveFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'drive'> extends True ? Prisma__driveClient<driveGetPayload<T>> : Prisma__driveClient<driveGetPayload<T> | null, null>

    /**
     * Find one Drive that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {driveFindUniqueOrThrowArgs} args - Arguments to find a Drive
     * @example
     * // Get one Drive
     * const drive = await prisma.drive.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends driveFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, driveFindUniqueOrThrowArgs>
    ): Prisma__driveClient<driveGetPayload<T>>

    /**
     * Find the first Drive that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driveFindFirstArgs} args - Arguments to find a Drive
     * @example
     * // Get one Drive
     * const drive = await prisma.drive.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends driveFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, driveFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'drive'> extends True ? Prisma__driveClient<driveGetPayload<T>> : Prisma__driveClient<driveGetPayload<T> | null, null>

    /**
     * Find the first Drive that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driveFindFirstOrThrowArgs} args - Arguments to find a Drive
     * @example
     * // Get one Drive
     * const drive = await prisma.drive.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends driveFindFirstOrThrowArgs>(
      args?: SelectSubset<T, driveFindFirstOrThrowArgs>
    ): Prisma__driveClient<driveGetPayload<T>>

    /**
     * Find zero or more Drives that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driveFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drives
     * const drives = await prisma.drive.findMany()
     * 
     * // Get first 10 Drives
     * const drives = await prisma.drive.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const driveWithIdOnly = await prisma.drive.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends driveFindManyArgs>(
      args?: SelectSubset<T, driveFindManyArgs>
    ): Prisma.PrismaPromise<Array<driveGetPayload<T>>>

    /**
     * Create a Drive.
     * @param {driveCreateArgs} args - Arguments to create a Drive.
     * @example
     * // Create one Drive
     * const Drive = await prisma.drive.create({
     *   data: {
     *     // ... data to create a Drive
     *   }
     * })
     * 
    **/
    create<T extends driveCreateArgs>(
      args: SelectSubset<T, driveCreateArgs>
    ): Prisma__driveClient<driveGetPayload<T>>

    /**
     * Delete a Drive.
     * @param {driveDeleteArgs} args - Arguments to delete one Drive.
     * @example
     * // Delete one Drive
     * const Drive = await prisma.drive.delete({
     *   where: {
     *     // ... filter to delete one Drive
     *   }
     * })
     * 
    **/
    delete<T extends driveDeleteArgs>(
      args: SelectSubset<T, driveDeleteArgs>
    ): Prisma__driveClient<driveGetPayload<T>>

    /**
     * Update one Drive.
     * @param {driveUpdateArgs} args - Arguments to update one Drive.
     * @example
     * // Update one Drive
     * const drive = await prisma.drive.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends driveUpdateArgs>(
      args: SelectSubset<T, driveUpdateArgs>
    ): Prisma__driveClient<driveGetPayload<T>>

    /**
     * Delete zero or more Drives.
     * @param {driveDeleteManyArgs} args - Arguments to filter Drives to delete.
     * @example
     * // Delete a few Drives
     * const { count } = await prisma.drive.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends driveDeleteManyArgs>(
      args?: SelectSubset<T, driveDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driveUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drives
     * const drive = await prisma.drive.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends driveUpdateManyArgs>(
      args: SelectSubset<T, driveUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Drive.
     * @param {driveUpsertArgs} args - Arguments to update or create a Drive.
     * @example
     * // Update or create a Drive
     * const drive = await prisma.drive.upsert({
     *   create: {
     *     // ... data to create a Drive
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drive we want to update
     *   }
     * })
    **/
    upsert<T extends driveUpsertArgs>(
      args: SelectSubset<T, driveUpsertArgs>
    ): Prisma__driveClient<driveGetPayload<T>>

    /**
     * Count the number of Drives.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {driveCountArgs} args - Arguments to filter Drives to count.
     * @example
     * // Count the number of Drives
     * const count = await prisma.drive.count({
     *   where: {
     *     // ... the filter for the Drives we want to count
     *   }
     * })
    **/
    count<T extends driveCountArgs>(
      args?: Subset<T, driveCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DriveCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DriveAggregateArgs>(args: Subset<T, DriveAggregateArgs>): Prisma.PrismaPromise<GetDriveAggregateType<T>>

    /**
     * Group by Drive.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DriveGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DriveGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DriveGroupByArgs['orderBy'] }
        : { orderBy?: DriveGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DriveGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDriveGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for drive.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__driveClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    drive_token<T extends drive_tokenArgs= {}>(args?: Subset<T, drive_tokenArgs>): Prisma__drive_tokenClient<drive_tokenGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    parsed_tvs<T extends drive$parsed_tvsArgs= {}>(args?: Subset<T, drive$parsed_tvsArgs>): Prisma.PrismaPromise<Array<parsed_tvGetPayload<T>>| Null>;

    parsed_seasons<T extends drive$parsed_seasonsArgs= {}>(args?: Subset<T, drive$parsed_seasonsArgs>): Prisma.PrismaPromise<Array<parsed_seasonGetPayload<T>>| Null>;

    parsed_episodes<T extends drive$parsed_episodesArgs= {}>(args?: Subset<T, drive$parsed_episodesArgs>): Prisma.PrismaPromise<Array<parsed_episodeGetPayload<T>>| Null>;

    drive_check_in<T extends drive$drive_check_inArgs= {}>(args?: Subset<T, drive$drive_check_inArgs>): Prisma.PrismaPromise<Array<drive_check_inGetPayload<T>>| Null>;

    files<T extends drive$filesArgs= {}>(args?: Subset<T, drive$filesArgs>): Prisma.PrismaPromise<Array<fileGetPayload<T>>| Null>;

    tmp_files<T extends drive$tmp_filesArgs= {}>(args?: Subset<T, drive$tmp_filesArgs>): Prisma.PrismaPromise<Array<tmp_fileGetPayload<T>>| Null>;

    parsed_movies<T extends drive$parsed_moviesArgs= {}>(args?: Subset<T, drive$parsed_moviesArgs>): Prisma.PrismaPromise<Array<parsed_movieGetPayload<T>>| Null>;

    shared_file_in_progress<T extends drive$shared_file_in_progressArgs= {}>(args?: Subset<T, drive$shared_file_in_progressArgs>): Prisma.PrismaPromise<Array<shared_file_in_progressGetPayload<T>>| Null>;

    subtitles<T extends drive$subtitlesArgs= {}>(args?: Subset<T, drive$subtitlesArgs>): Prisma.PrismaPromise<Array<subtitleGetPayload<T>>| Null>;

    sync_tasks<T extends drive$sync_tasksArgs= {}>(args?: Subset<T, drive$sync_tasksArgs>): Prisma.PrismaPromise<Array<bind_for_parsed_tvGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * drive base type for findUnique actions
   */
  export type driveFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
    /**
     * Filter, which drive to fetch.
     */
    where: driveWhereUniqueInput
  }

  /**
   * drive findUnique
   */
  export interface driveFindUniqueArgs extends driveFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * drive findUniqueOrThrow
   */
  export type driveFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
    /**
     * Filter, which drive to fetch.
     */
    where: driveWhereUniqueInput
  }


  /**
   * drive base type for findFirst actions
   */
  export type driveFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
    /**
     * Filter, which drive to fetch.
     */
    where?: driveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drives to fetch.
     */
    orderBy?: Enumerable<driveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drives.
     */
    cursor?: driveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drives.
     */
    distinct?: Enumerable<DriveScalarFieldEnum>
  }

  /**
   * drive findFirst
   */
  export interface driveFindFirstArgs extends driveFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * drive findFirstOrThrow
   */
  export type driveFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
    /**
     * Filter, which drive to fetch.
     */
    where?: driveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drives to fetch.
     */
    orderBy?: Enumerable<driveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drives.
     */
    cursor?: driveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drives.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drives.
     */
    distinct?: Enumerable<DriveScalarFieldEnum>
  }


  /**
   * drive findMany
   */
  export type driveFindManyArgs = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
    /**
     * Filter, which drives to fetch.
     */
    where?: driveWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drives to fetch.
     */
    orderBy?: Enumerable<driveOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drives.
     */
    cursor?: driveWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drives from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drives.
     */
    skip?: number
    distinct?: Enumerable<DriveScalarFieldEnum>
  }


  /**
   * drive create
   */
  export type driveCreateArgs = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
    /**
     * The data needed to create a drive.
     */
    data: XOR<driveCreateInput, driveUncheckedCreateInput>
  }


  /**
   * drive update
   */
  export type driveUpdateArgs = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
    /**
     * The data needed to update a drive.
     */
    data: XOR<driveUpdateInput, driveUncheckedUpdateInput>
    /**
     * Choose, which drive to update.
     */
    where: driveWhereUniqueInput
  }


  /**
   * drive updateMany
   */
  export type driveUpdateManyArgs = {
    /**
     * The data used to update drives.
     */
    data: XOR<driveUpdateManyMutationInput, driveUncheckedUpdateManyInput>
    /**
     * Filter which drives to update
     */
    where?: driveWhereInput
  }


  /**
   * drive upsert
   */
  export type driveUpsertArgs = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
    /**
     * The filter to search for the drive to update in case it exists.
     */
    where: driveWhereUniqueInput
    /**
     * In case the drive found by the `where` argument doesn't exist, create a new drive with this data.
     */
    create: XOR<driveCreateInput, driveUncheckedCreateInput>
    /**
     * In case the drive was found with the provided `where` argument, update it with this data.
     */
    update: XOR<driveUpdateInput, driveUncheckedUpdateInput>
  }


  /**
   * drive delete
   */
  export type driveDeleteArgs = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
    /**
     * Filter which drive to delete.
     */
    where: driveWhereUniqueInput
  }


  /**
   * drive deleteMany
   */
  export type driveDeleteManyArgs = {
    /**
     * Filter which drives to delete
     */
    where?: driveWhereInput
  }


  /**
   * drive.parsed_tvs
   */
  export type drive$parsed_tvsArgs = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    where?: parsed_tvWhereInput
    orderBy?: Enumerable<parsed_tvOrderByWithRelationInput>
    cursor?: parsed_tvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_tvScalarFieldEnum>
  }


  /**
   * drive.parsed_seasons
   */
  export type drive$parsed_seasonsArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    where?: parsed_seasonWhereInput
    orderBy?: Enumerable<parsed_seasonOrderByWithRelationInput>
    cursor?: parsed_seasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_seasonScalarFieldEnum>
  }


  /**
   * drive.parsed_episodes
   */
  export type drive$parsed_episodesArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    where?: parsed_episodeWhereInput
    orderBy?: Enumerable<parsed_episodeOrderByWithRelationInput>
    cursor?: parsed_episodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_episodeScalarFieldEnum>
  }


  /**
   * drive.drive_check_in
   */
  export type drive$drive_check_inArgs = {
    /**
     * Select specific fields to fetch from the drive_check_in
     */
    select?: drive_check_inSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_check_inInclude | null
    where?: drive_check_inWhereInput
    orderBy?: Enumerable<drive_check_inOrderByWithRelationInput>
    cursor?: drive_check_inWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Drive_check_inScalarFieldEnum>
  }


  /**
   * drive.files
   */
  export type drive$filesArgs = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
    where?: fileWhereInput
    orderBy?: Enumerable<fileOrderByWithRelationInput>
    cursor?: fileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FileScalarFieldEnum>
  }


  /**
   * drive.tmp_files
   */
  export type drive$tmp_filesArgs = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
    where?: tmp_fileWhereInput
    orderBy?: Enumerable<tmp_fileOrderByWithRelationInput>
    cursor?: tmp_fileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Tmp_fileScalarFieldEnum>
  }


  /**
   * drive.parsed_movies
   */
  export type drive$parsed_moviesArgs = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    where?: parsed_movieWhereInput
    orderBy?: Enumerable<parsed_movieOrderByWithRelationInput>
    cursor?: parsed_movieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_movieScalarFieldEnum>
  }


  /**
   * drive.shared_file_in_progress
   */
  export type drive$shared_file_in_progressArgs = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
    where?: shared_file_in_progressWhereInput
    orderBy?: Enumerable<shared_file_in_progressOrderByWithRelationInput>
    cursor?: shared_file_in_progressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Shared_file_in_progressScalarFieldEnum>
  }


  /**
   * drive.subtitles
   */
  export type drive$subtitlesArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    where?: subtitleWhereInput
    orderBy?: Enumerable<subtitleOrderByWithRelationInput>
    cursor?: subtitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubtitleScalarFieldEnum>
  }


  /**
   * drive.sync_tasks
   */
  export type drive$sync_tasksArgs = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    where?: bind_for_parsed_tvWhereInput
    orderBy?: Enumerable<bind_for_parsed_tvOrderByWithRelationInput>
    cursor?: bind_for_parsed_tvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Bind_for_parsed_tvScalarFieldEnum>
  }


  /**
   * drive without action
   */
  export type driveArgs = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
  }



  /**
   * Model drive_token
   */


  export type AggregateDrive_token = {
    _count: Drive_tokenCountAggregateOutputType | null
    _avg: Drive_tokenAvgAggregateOutputType | null
    _sum: Drive_tokenSumAggregateOutputType | null
    _min: Drive_tokenMinAggregateOutputType | null
    _max: Drive_tokenMaxAggregateOutputType | null
  }

  export type Drive_tokenAvgAggregateOutputType = {
    expired_at: number | null
  }

  export type Drive_tokenSumAggregateOutputType = {
    expired_at: number | null
  }

  export type Drive_tokenMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    data: string | null
    expired_at: number | null
  }

  export type Drive_tokenMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    data: string | null
    expired_at: number | null
  }

  export type Drive_tokenCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    data: number
    expired_at: number
    _all: number
  }


  export type Drive_tokenAvgAggregateInputType = {
    expired_at?: true
  }

  export type Drive_tokenSumAggregateInputType = {
    expired_at?: true
  }

  export type Drive_tokenMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    data?: true
    expired_at?: true
  }

  export type Drive_tokenMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    data?: true
    expired_at?: true
  }

  export type Drive_tokenCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    data?: true
    expired_at?: true
    _all?: true
  }

  export type Drive_tokenAggregateArgs = {
    /**
     * Filter which drive_token to aggregate.
     */
    where?: drive_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drive_tokens to fetch.
     */
    orderBy?: Enumerable<drive_tokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: drive_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drive_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drive_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drive_tokens
    **/
    _count?: true | Drive_tokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Drive_tokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Drive_tokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Drive_tokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Drive_tokenMaxAggregateInputType
  }

  export type GetDrive_tokenAggregateType<T extends Drive_tokenAggregateArgs> = {
        [P in keyof T & keyof AggregateDrive_token]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrive_token[P]>
      : GetScalarType<T[P], AggregateDrive_token[P]>
  }




  export type Drive_tokenGroupByArgs = {
    where?: drive_tokenWhereInput
    orderBy?: Enumerable<drive_tokenOrderByWithAggregationInput>
    by: Drive_tokenScalarFieldEnum[]
    having?: drive_tokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Drive_tokenCountAggregateInputType | true
    _avg?: Drive_tokenAvgAggregateInputType
    _sum?: Drive_tokenSumAggregateInputType
    _min?: Drive_tokenMinAggregateInputType
    _max?: Drive_tokenMaxAggregateInputType
  }


  export type Drive_tokenGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    data: string
    expired_at: number
    _count: Drive_tokenCountAggregateOutputType | null
    _avg: Drive_tokenAvgAggregateOutputType | null
    _sum: Drive_tokenSumAggregateOutputType | null
    _min: Drive_tokenMinAggregateOutputType | null
    _max: Drive_tokenMaxAggregateOutputType | null
  }

  type GetDrive_tokenGroupByPayload<T extends Drive_tokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Drive_tokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Drive_tokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Drive_tokenGroupByOutputType[P]>
            : GetScalarType<T[P], Drive_tokenGroupByOutputType[P]>
        }
      >
    >


  export type drive_tokenSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    data?: boolean
    expired_at?: boolean
    drives?: boolean | drive_token$drivesArgs
    _count?: boolean | Drive_tokenCountOutputTypeArgs
  }


  export type drive_tokenInclude = {
    drives?: boolean | drive_token$drivesArgs
    _count?: boolean | Drive_tokenCountOutputTypeArgs
  }

  export type drive_tokenGetPayload<S extends boolean | null | undefined | drive_tokenArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? drive_token :
    S extends undefined ? never :
    S extends { include: any } & (drive_tokenArgs | drive_tokenFindManyArgs)
    ? drive_token  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'drives' ? Array < driveGetPayload<S['include'][P]>>  :
        P extends '_count' ? Drive_tokenCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (drive_tokenArgs | drive_tokenFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'drives' ? Array < driveGetPayload<S['select'][P]>>  :
        P extends '_count' ? Drive_tokenCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof drive_token ? drive_token[P] : never
  } 
      : drive_token


  type drive_tokenCountArgs = 
    Omit<drive_tokenFindManyArgs, 'select' | 'include'> & {
      select?: Drive_tokenCountAggregateInputType | true
    }

  export interface drive_tokenDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Drive_token that matches the filter.
     * @param {drive_tokenFindUniqueArgs} args - Arguments to find a Drive_token
     * @example
     * // Get one Drive_token
     * const drive_token = await prisma.drive_token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends drive_tokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, drive_tokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'drive_token'> extends True ? Prisma__drive_tokenClient<drive_tokenGetPayload<T>> : Prisma__drive_tokenClient<drive_tokenGetPayload<T> | null, null>

    /**
     * Find one Drive_token that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {drive_tokenFindUniqueOrThrowArgs} args - Arguments to find a Drive_token
     * @example
     * // Get one Drive_token
     * const drive_token = await prisma.drive_token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends drive_tokenFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, drive_tokenFindUniqueOrThrowArgs>
    ): Prisma__drive_tokenClient<drive_tokenGetPayload<T>>

    /**
     * Find the first Drive_token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drive_tokenFindFirstArgs} args - Arguments to find a Drive_token
     * @example
     * // Get one Drive_token
     * const drive_token = await prisma.drive_token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends drive_tokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, drive_tokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'drive_token'> extends True ? Prisma__drive_tokenClient<drive_tokenGetPayload<T>> : Prisma__drive_tokenClient<drive_tokenGetPayload<T> | null, null>

    /**
     * Find the first Drive_token that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drive_tokenFindFirstOrThrowArgs} args - Arguments to find a Drive_token
     * @example
     * // Get one Drive_token
     * const drive_token = await prisma.drive_token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends drive_tokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, drive_tokenFindFirstOrThrowArgs>
    ): Prisma__drive_tokenClient<drive_tokenGetPayload<T>>

    /**
     * Find zero or more Drive_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drive_tokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drive_tokens
     * const drive_tokens = await prisma.drive_token.findMany()
     * 
     * // Get first 10 Drive_tokens
     * const drive_tokens = await prisma.drive_token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drive_tokenWithIdOnly = await prisma.drive_token.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends drive_tokenFindManyArgs>(
      args?: SelectSubset<T, drive_tokenFindManyArgs>
    ): Prisma.PrismaPromise<Array<drive_tokenGetPayload<T>>>

    /**
     * Create a Drive_token.
     * @param {drive_tokenCreateArgs} args - Arguments to create a Drive_token.
     * @example
     * // Create one Drive_token
     * const Drive_token = await prisma.drive_token.create({
     *   data: {
     *     // ... data to create a Drive_token
     *   }
     * })
     * 
    **/
    create<T extends drive_tokenCreateArgs>(
      args: SelectSubset<T, drive_tokenCreateArgs>
    ): Prisma__drive_tokenClient<drive_tokenGetPayload<T>>

    /**
     * Delete a Drive_token.
     * @param {drive_tokenDeleteArgs} args - Arguments to delete one Drive_token.
     * @example
     * // Delete one Drive_token
     * const Drive_token = await prisma.drive_token.delete({
     *   where: {
     *     // ... filter to delete one Drive_token
     *   }
     * })
     * 
    **/
    delete<T extends drive_tokenDeleteArgs>(
      args: SelectSubset<T, drive_tokenDeleteArgs>
    ): Prisma__drive_tokenClient<drive_tokenGetPayload<T>>

    /**
     * Update one Drive_token.
     * @param {drive_tokenUpdateArgs} args - Arguments to update one Drive_token.
     * @example
     * // Update one Drive_token
     * const drive_token = await prisma.drive_token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends drive_tokenUpdateArgs>(
      args: SelectSubset<T, drive_tokenUpdateArgs>
    ): Prisma__drive_tokenClient<drive_tokenGetPayload<T>>

    /**
     * Delete zero or more Drive_tokens.
     * @param {drive_tokenDeleteManyArgs} args - Arguments to filter Drive_tokens to delete.
     * @example
     * // Delete a few Drive_tokens
     * const { count } = await prisma.drive_token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends drive_tokenDeleteManyArgs>(
      args?: SelectSubset<T, drive_tokenDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drive_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drive_tokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drive_tokens
     * const drive_token = await prisma.drive_token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends drive_tokenUpdateManyArgs>(
      args: SelectSubset<T, drive_tokenUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Drive_token.
     * @param {drive_tokenUpsertArgs} args - Arguments to update or create a Drive_token.
     * @example
     * // Update or create a Drive_token
     * const drive_token = await prisma.drive_token.upsert({
     *   create: {
     *     // ... data to create a Drive_token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drive_token we want to update
     *   }
     * })
    **/
    upsert<T extends drive_tokenUpsertArgs>(
      args: SelectSubset<T, drive_tokenUpsertArgs>
    ): Prisma__drive_tokenClient<drive_tokenGetPayload<T>>

    /**
     * Count the number of Drive_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drive_tokenCountArgs} args - Arguments to filter Drive_tokens to count.
     * @example
     * // Count the number of Drive_tokens
     * const count = await prisma.drive_token.count({
     *   where: {
     *     // ... the filter for the Drive_tokens we want to count
     *   }
     * })
    **/
    count<T extends drive_tokenCountArgs>(
      args?: Subset<T, drive_tokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Drive_tokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drive_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Drive_tokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Drive_tokenAggregateArgs>(args: Subset<T, Drive_tokenAggregateArgs>): Prisma.PrismaPromise<GetDrive_tokenAggregateType<T>>

    /**
     * Group by Drive_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Drive_tokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Drive_tokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Drive_tokenGroupByArgs['orderBy'] }
        : { orderBy?: Drive_tokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Drive_tokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrive_tokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for drive_token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__drive_tokenClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    drives<T extends drive_token$drivesArgs= {}>(args?: Subset<T, drive_token$drivesArgs>): Prisma.PrismaPromise<Array<driveGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * drive_token base type for findUnique actions
   */
  export type drive_tokenFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the drive_token
     */
    select?: drive_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_tokenInclude | null
    /**
     * Filter, which drive_token to fetch.
     */
    where: drive_tokenWhereUniqueInput
  }

  /**
   * drive_token findUnique
   */
  export interface drive_tokenFindUniqueArgs extends drive_tokenFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * drive_token findUniqueOrThrow
   */
  export type drive_tokenFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the drive_token
     */
    select?: drive_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_tokenInclude | null
    /**
     * Filter, which drive_token to fetch.
     */
    where: drive_tokenWhereUniqueInput
  }


  /**
   * drive_token base type for findFirst actions
   */
  export type drive_tokenFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the drive_token
     */
    select?: drive_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_tokenInclude | null
    /**
     * Filter, which drive_token to fetch.
     */
    where?: drive_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drive_tokens to fetch.
     */
    orderBy?: Enumerable<drive_tokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drive_tokens.
     */
    cursor?: drive_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drive_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drive_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drive_tokens.
     */
    distinct?: Enumerable<Drive_tokenScalarFieldEnum>
  }

  /**
   * drive_token findFirst
   */
  export interface drive_tokenFindFirstArgs extends drive_tokenFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * drive_token findFirstOrThrow
   */
  export type drive_tokenFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the drive_token
     */
    select?: drive_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_tokenInclude | null
    /**
     * Filter, which drive_token to fetch.
     */
    where?: drive_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drive_tokens to fetch.
     */
    orderBy?: Enumerable<drive_tokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drive_tokens.
     */
    cursor?: drive_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drive_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drive_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drive_tokens.
     */
    distinct?: Enumerable<Drive_tokenScalarFieldEnum>
  }


  /**
   * drive_token findMany
   */
  export type drive_tokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the drive_token
     */
    select?: drive_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_tokenInclude | null
    /**
     * Filter, which drive_tokens to fetch.
     */
    where?: drive_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drive_tokens to fetch.
     */
    orderBy?: Enumerable<drive_tokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drive_tokens.
     */
    cursor?: drive_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drive_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drive_tokens.
     */
    skip?: number
    distinct?: Enumerable<Drive_tokenScalarFieldEnum>
  }


  /**
   * drive_token create
   */
  export type drive_tokenCreateArgs = {
    /**
     * Select specific fields to fetch from the drive_token
     */
    select?: drive_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_tokenInclude | null
    /**
     * The data needed to create a drive_token.
     */
    data: XOR<drive_tokenCreateInput, drive_tokenUncheckedCreateInput>
  }


  /**
   * drive_token update
   */
  export type drive_tokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the drive_token
     */
    select?: drive_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_tokenInclude | null
    /**
     * The data needed to update a drive_token.
     */
    data: XOR<drive_tokenUpdateInput, drive_tokenUncheckedUpdateInput>
    /**
     * Choose, which drive_token to update.
     */
    where: drive_tokenWhereUniqueInput
  }


  /**
   * drive_token updateMany
   */
  export type drive_tokenUpdateManyArgs = {
    /**
     * The data used to update drive_tokens.
     */
    data: XOR<drive_tokenUpdateManyMutationInput, drive_tokenUncheckedUpdateManyInput>
    /**
     * Filter which drive_tokens to update
     */
    where?: drive_tokenWhereInput
  }


  /**
   * drive_token upsert
   */
  export type drive_tokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the drive_token
     */
    select?: drive_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_tokenInclude | null
    /**
     * The filter to search for the drive_token to update in case it exists.
     */
    where: drive_tokenWhereUniqueInput
    /**
     * In case the drive_token found by the `where` argument doesn't exist, create a new drive_token with this data.
     */
    create: XOR<drive_tokenCreateInput, drive_tokenUncheckedCreateInput>
    /**
     * In case the drive_token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<drive_tokenUpdateInput, drive_tokenUncheckedUpdateInput>
  }


  /**
   * drive_token delete
   */
  export type drive_tokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the drive_token
     */
    select?: drive_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_tokenInclude | null
    /**
     * Filter which drive_token to delete.
     */
    where: drive_tokenWhereUniqueInput
  }


  /**
   * drive_token deleteMany
   */
  export type drive_tokenDeleteManyArgs = {
    /**
     * Filter which drive_tokens to delete
     */
    where?: drive_tokenWhereInput
  }


  /**
   * drive_token.drives
   */
  export type drive_token$drivesArgs = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
    where?: driveWhereInput
    orderBy?: Enumerable<driveOrderByWithRelationInput>
    cursor?: driveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DriveScalarFieldEnum>
  }


  /**
   * drive_token without action
   */
  export type drive_tokenArgs = {
    /**
     * Select specific fields to fetch from the drive_token
     */
    select?: drive_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_tokenInclude | null
  }



  /**
   * Model tv_profile
   */


  export type AggregateTv_profile = {
    _count: Tv_profileCountAggregateOutputType | null
    _avg: Tv_profileAvgAggregateOutputType | null
    _sum: Tv_profileSumAggregateOutputType | null
    _min: Tv_profileMinAggregateOutputType | null
    _max: Tv_profileMaxAggregateOutputType | null
  }

  export type Tv_profileAvgAggregateOutputType = {
    source: number | null
    popularity: number | null
    vote_average: number | null
    vote_count: number | null
    episode_count: number | null
    season_count: number | null
    in_production: number | null
  }

  export type Tv_profileSumAggregateOutputType = {
    source: number | null
    popularity: number | null
    vote_average: number | null
    vote_count: number | null
    episode_count: number | null
    season_count: number | null
    in_production: number | null
  }

  export type Tv_profileMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    source: number | null
    sources: string | null
    name: string | null
    original_name: string | null
    overview: string | null
    poster_path: string | null
    backdrop_path: string | null
    first_air_date: string | null
    original_language: string | null
    origin_country: string | null
    genres: string | null
    popularity: number | null
    vote_average: number | null
    vote_count: number | null
    episode_count: number | null
    season_count: number | null
    status: string | null
    in_production: number | null
  }

  export type Tv_profileMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    source: number | null
    sources: string | null
    name: string | null
    original_name: string | null
    overview: string | null
    poster_path: string | null
    backdrop_path: string | null
    first_air_date: string | null
    original_language: string | null
    origin_country: string | null
    genres: string | null
    popularity: number | null
    vote_average: number | null
    vote_count: number | null
    episode_count: number | null
    season_count: number | null
    status: string | null
    in_production: number | null
  }

  export type Tv_profileCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    unique_id: number
    source: number
    sources: number
    name: number
    original_name: number
    overview: number
    poster_path: number
    backdrop_path: number
    first_air_date: number
    original_language: number
    origin_country: number
    genres: number
    popularity: number
    vote_average: number
    vote_count: number
    episode_count: number
    season_count: number
    status: number
    in_production: number
    _all: number
  }


  export type Tv_profileAvgAggregateInputType = {
    source?: true
    popularity?: true
    vote_average?: true
    vote_count?: true
    episode_count?: true
    season_count?: true
    in_production?: true
  }

  export type Tv_profileSumAggregateInputType = {
    source?: true
    popularity?: true
    vote_average?: true
    vote_count?: true
    episode_count?: true
    season_count?: true
    in_production?: true
  }

  export type Tv_profileMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    original_name?: true
    overview?: true
    poster_path?: true
    backdrop_path?: true
    first_air_date?: true
    original_language?: true
    origin_country?: true
    genres?: true
    popularity?: true
    vote_average?: true
    vote_count?: true
    episode_count?: true
    season_count?: true
    status?: true
    in_production?: true
  }

  export type Tv_profileMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    original_name?: true
    overview?: true
    poster_path?: true
    backdrop_path?: true
    first_air_date?: true
    original_language?: true
    origin_country?: true
    genres?: true
    popularity?: true
    vote_average?: true
    vote_count?: true
    episode_count?: true
    season_count?: true
    status?: true
    in_production?: true
  }

  export type Tv_profileCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    original_name?: true
    overview?: true
    poster_path?: true
    backdrop_path?: true
    first_air_date?: true
    original_language?: true
    origin_country?: true
    genres?: true
    popularity?: true
    vote_average?: true
    vote_count?: true
    episode_count?: true
    season_count?: true
    status?: true
    in_production?: true
    _all?: true
  }

  export type Tv_profileAggregateArgs = {
    /**
     * Filter which tv_profile to aggregate.
     */
    where?: tv_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tv_profiles to fetch.
     */
    orderBy?: Enumerable<tv_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tv_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tv_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tv_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tv_profiles
    **/
    _count?: true | Tv_profileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tv_profileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tv_profileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tv_profileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tv_profileMaxAggregateInputType
  }

  export type GetTv_profileAggregateType<T extends Tv_profileAggregateArgs> = {
        [P in keyof T & keyof AggregateTv_profile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTv_profile[P]>
      : GetScalarType<T[P], AggregateTv_profile[P]>
  }




  export type Tv_profileGroupByArgs = {
    where?: tv_profileWhereInput
    orderBy?: Enumerable<tv_profileOrderByWithAggregationInput>
    by: Tv_profileScalarFieldEnum[]
    having?: tv_profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tv_profileCountAggregateInputType | true
    _avg?: Tv_profileAvgAggregateInputType
    _sum?: Tv_profileSumAggregateInputType
    _min?: Tv_profileMinAggregateInputType
    _max?: Tv_profileMaxAggregateInputType
  }


  export type Tv_profileGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    unique_id: string
    source: number | null
    sources: string | null
    name: string | null
    original_name: string | null
    overview: string | null
    poster_path: string | null
    backdrop_path: string | null
    first_air_date: string | null
    original_language: string | null
    origin_country: string | null
    genres: string | null
    popularity: number | null
    vote_average: number | null
    vote_count: number | null
    episode_count: number | null
    season_count: number | null
    status: string | null
    in_production: number | null
    _count: Tv_profileCountAggregateOutputType | null
    _avg: Tv_profileAvgAggregateOutputType | null
    _sum: Tv_profileSumAggregateOutputType | null
    _min: Tv_profileMinAggregateOutputType | null
    _max: Tv_profileMaxAggregateOutputType | null
  }

  type GetTv_profileGroupByPayload<T extends Tv_profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tv_profileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tv_profileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tv_profileGroupByOutputType[P]>
            : GetScalarType<T[P], Tv_profileGroupByOutputType[P]>
        }
      >
    >


  export type tv_profileSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    unique_id?: boolean
    source?: boolean
    sources?: boolean
    name?: boolean
    original_name?: boolean
    overview?: boolean
    poster_path?: boolean
    backdrop_path?: boolean
    first_air_date?: boolean
    original_language?: boolean
    origin_country?: boolean
    genres?: boolean
    popularity?: boolean
    vote_average?: boolean
    vote_count?: boolean
    episode_count?: boolean
    season_count?: boolean
    status?: boolean
    in_production?: boolean
    tvs?: boolean | tv_profile$tvsArgs
    snapshots?: boolean | tv_profile$snapshotsArgs
    _count?: boolean | Tv_profileCountOutputTypeArgs
  }


  export type tv_profileInclude = {
    tvs?: boolean | tv_profile$tvsArgs
    snapshots?: boolean | tv_profile$snapshotsArgs
    _count?: boolean | Tv_profileCountOutputTypeArgs
  }

  export type tv_profileGetPayload<S extends boolean | null | undefined | tv_profileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tv_profile :
    S extends undefined ? never :
    S extends { include: any } & (tv_profileArgs | tv_profileFindManyArgs)
    ? tv_profile  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tvs' ? Array < tvGetPayload<S['include'][P]>>  :
        P extends 'snapshots' ? Array < tv_profile_quickGetPayload<S['include'][P]>>  :
        P extends '_count' ? Tv_profileCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (tv_profileArgs | tv_profileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tvs' ? Array < tvGetPayload<S['select'][P]>>  :
        P extends 'snapshots' ? Array < tv_profile_quickGetPayload<S['select'][P]>>  :
        P extends '_count' ? Tv_profileCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof tv_profile ? tv_profile[P] : never
  } 
      : tv_profile


  type tv_profileCountArgs = 
    Omit<tv_profileFindManyArgs, 'select' | 'include'> & {
      select?: Tv_profileCountAggregateInputType | true
    }

  export interface tv_profileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tv_profile that matches the filter.
     * @param {tv_profileFindUniqueArgs} args - Arguments to find a Tv_profile
     * @example
     * // Get one Tv_profile
     * const tv_profile = await prisma.tv_profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tv_profileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tv_profileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tv_profile'> extends True ? Prisma__tv_profileClient<tv_profileGetPayload<T>> : Prisma__tv_profileClient<tv_profileGetPayload<T> | null, null>

    /**
     * Find one Tv_profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tv_profileFindUniqueOrThrowArgs} args - Arguments to find a Tv_profile
     * @example
     * // Get one Tv_profile
     * const tv_profile = await prisma.tv_profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tv_profileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tv_profileFindUniqueOrThrowArgs>
    ): Prisma__tv_profileClient<tv_profileGetPayload<T>>

    /**
     * Find the first Tv_profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tv_profileFindFirstArgs} args - Arguments to find a Tv_profile
     * @example
     * // Get one Tv_profile
     * const tv_profile = await prisma.tv_profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tv_profileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tv_profileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tv_profile'> extends True ? Prisma__tv_profileClient<tv_profileGetPayload<T>> : Prisma__tv_profileClient<tv_profileGetPayload<T> | null, null>

    /**
     * Find the first Tv_profile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tv_profileFindFirstOrThrowArgs} args - Arguments to find a Tv_profile
     * @example
     * // Get one Tv_profile
     * const tv_profile = await prisma.tv_profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tv_profileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tv_profileFindFirstOrThrowArgs>
    ): Prisma__tv_profileClient<tv_profileGetPayload<T>>

    /**
     * Find zero or more Tv_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tv_profileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tv_profiles
     * const tv_profiles = await prisma.tv_profile.findMany()
     * 
     * // Get first 10 Tv_profiles
     * const tv_profiles = await prisma.tv_profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tv_profileWithIdOnly = await prisma.tv_profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tv_profileFindManyArgs>(
      args?: SelectSubset<T, tv_profileFindManyArgs>
    ): Prisma.PrismaPromise<Array<tv_profileGetPayload<T>>>

    /**
     * Create a Tv_profile.
     * @param {tv_profileCreateArgs} args - Arguments to create a Tv_profile.
     * @example
     * // Create one Tv_profile
     * const Tv_profile = await prisma.tv_profile.create({
     *   data: {
     *     // ... data to create a Tv_profile
     *   }
     * })
     * 
    **/
    create<T extends tv_profileCreateArgs>(
      args: SelectSubset<T, tv_profileCreateArgs>
    ): Prisma__tv_profileClient<tv_profileGetPayload<T>>

    /**
     * Delete a Tv_profile.
     * @param {tv_profileDeleteArgs} args - Arguments to delete one Tv_profile.
     * @example
     * // Delete one Tv_profile
     * const Tv_profile = await prisma.tv_profile.delete({
     *   where: {
     *     // ... filter to delete one Tv_profile
     *   }
     * })
     * 
    **/
    delete<T extends tv_profileDeleteArgs>(
      args: SelectSubset<T, tv_profileDeleteArgs>
    ): Prisma__tv_profileClient<tv_profileGetPayload<T>>

    /**
     * Update one Tv_profile.
     * @param {tv_profileUpdateArgs} args - Arguments to update one Tv_profile.
     * @example
     * // Update one Tv_profile
     * const tv_profile = await prisma.tv_profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tv_profileUpdateArgs>(
      args: SelectSubset<T, tv_profileUpdateArgs>
    ): Prisma__tv_profileClient<tv_profileGetPayload<T>>

    /**
     * Delete zero or more Tv_profiles.
     * @param {tv_profileDeleteManyArgs} args - Arguments to filter Tv_profiles to delete.
     * @example
     * // Delete a few Tv_profiles
     * const { count } = await prisma.tv_profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tv_profileDeleteManyArgs>(
      args?: SelectSubset<T, tv_profileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tv_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tv_profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tv_profiles
     * const tv_profile = await prisma.tv_profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tv_profileUpdateManyArgs>(
      args: SelectSubset<T, tv_profileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tv_profile.
     * @param {tv_profileUpsertArgs} args - Arguments to update or create a Tv_profile.
     * @example
     * // Update or create a Tv_profile
     * const tv_profile = await prisma.tv_profile.upsert({
     *   create: {
     *     // ... data to create a Tv_profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tv_profile we want to update
     *   }
     * })
    **/
    upsert<T extends tv_profileUpsertArgs>(
      args: SelectSubset<T, tv_profileUpsertArgs>
    ): Prisma__tv_profileClient<tv_profileGetPayload<T>>

    /**
     * Count the number of Tv_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tv_profileCountArgs} args - Arguments to filter Tv_profiles to count.
     * @example
     * // Count the number of Tv_profiles
     * const count = await prisma.tv_profile.count({
     *   where: {
     *     // ... the filter for the Tv_profiles we want to count
     *   }
     * })
    **/
    count<T extends tv_profileCountArgs>(
      args?: Subset<T, tv_profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tv_profileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tv_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tv_profileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tv_profileAggregateArgs>(args: Subset<T, Tv_profileAggregateArgs>): Prisma.PrismaPromise<GetTv_profileAggregateType<T>>

    /**
     * Group by Tv_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tv_profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tv_profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tv_profileGroupByArgs['orderBy'] }
        : { orderBy?: Tv_profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tv_profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTv_profileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tv_profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tv_profileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tvs<T extends tv_profile$tvsArgs= {}>(args?: Subset<T, tv_profile$tvsArgs>): Prisma.PrismaPromise<Array<tvGetPayload<T>>| Null>;

    snapshots<T extends tv_profile$snapshotsArgs= {}>(args?: Subset<T, tv_profile$snapshotsArgs>): Prisma.PrismaPromise<Array<tv_profile_quickGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tv_profile base type for findUnique actions
   */
  export type tv_profileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tv_profile
     */
    select?: tv_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profileInclude | null
    /**
     * Filter, which tv_profile to fetch.
     */
    where: tv_profileWhereUniqueInput
  }

  /**
   * tv_profile findUnique
   */
  export interface tv_profileFindUniqueArgs extends tv_profileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tv_profile findUniqueOrThrow
   */
  export type tv_profileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tv_profile
     */
    select?: tv_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profileInclude | null
    /**
     * Filter, which tv_profile to fetch.
     */
    where: tv_profileWhereUniqueInput
  }


  /**
   * tv_profile base type for findFirst actions
   */
  export type tv_profileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tv_profile
     */
    select?: tv_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profileInclude | null
    /**
     * Filter, which tv_profile to fetch.
     */
    where?: tv_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tv_profiles to fetch.
     */
    orderBy?: Enumerable<tv_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tv_profiles.
     */
    cursor?: tv_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tv_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tv_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tv_profiles.
     */
    distinct?: Enumerable<Tv_profileScalarFieldEnum>
  }

  /**
   * tv_profile findFirst
   */
  export interface tv_profileFindFirstArgs extends tv_profileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tv_profile findFirstOrThrow
   */
  export type tv_profileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tv_profile
     */
    select?: tv_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profileInclude | null
    /**
     * Filter, which tv_profile to fetch.
     */
    where?: tv_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tv_profiles to fetch.
     */
    orderBy?: Enumerable<tv_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tv_profiles.
     */
    cursor?: tv_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tv_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tv_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tv_profiles.
     */
    distinct?: Enumerable<Tv_profileScalarFieldEnum>
  }


  /**
   * tv_profile findMany
   */
  export type tv_profileFindManyArgs = {
    /**
     * Select specific fields to fetch from the tv_profile
     */
    select?: tv_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profileInclude | null
    /**
     * Filter, which tv_profiles to fetch.
     */
    where?: tv_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tv_profiles to fetch.
     */
    orderBy?: Enumerable<tv_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tv_profiles.
     */
    cursor?: tv_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tv_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tv_profiles.
     */
    skip?: number
    distinct?: Enumerable<Tv_profileScalarFieldEnum>
  }


  /**
   * tv_profile create
   */
  export type tv_profileCreateArgs = {
    /**
     * Select specific fields to fetch from the tv_profile
     */
    select?: tv_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profileInclude | null
    /**
     * The data needed to create a tv_profile.
     */
    data: XOR<tv_profileCreateInput, tv_profileUncheckedCreateInput>
  }


  /**
   * tv_profile update
   */
  export type tv_profileUpdateArgs = {
    /**
     * Select specific fields to fetch from the tv_profile
     */
    select?: tv_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profileInclude | null
    /**
     * The data needed to update a tv_profile.
     */
    data: XOR<tv_profileUpdateInput, tv_profileUncheckedUpdateInput>
    /**
     * Choose, which tv_profile to update.
     */
    where: tv_profileWhereUniqueInput
  }


  /**
   * tv_profile updateMany
   */
  export type tv_profileUpdateManyArgs = {
    /**
     * The data used to update tv_profiles.
     */
    data: XOR<tv_profileUpdateManyMutationInput, tv_profileUncheckedUpdateManyInput>
    /**
     * Filter which tv_profiles to update
     */
    where?: tv_profileWhereInput
  }


  /**
   * tv_profile upsert
   */
  export type tv_profileUpsertArgs = {
    /**
     * Select specific fields to fetch from the tv_profile
     */
    select?: tv_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profileInclude | null
    /**
     * The filter to search for the tv_profile to update in case it exists.
     */
    where: tv_profileWhereUniqueInput
    /**
     * In case the tv_profile found by the `where` argument doesn't exist, create a new tv_profile with this data.
     */
    create: XOR<tv_profileCreateInput, tv_profileUncheckedCreateInput>
    /**
     * In case the tv_profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tv_profileUpdateInput, tv_profileUncheckedUpdateInput>
  }


  /**
   * tv_profile delete
   */
  export type tv_profileDeleteArgs = {
    /**
     * Select specific fields to fetch from the tv_profile
     */
    select?: tv_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profileInclude | null
    /**
     * Filter which tv_profile to delete.
     */
    where: tv_profileWhereUniqueInput
  }


  /**
   * tv_profile deleteMany
   */
  export type tv_profileDeleteManyArgs = {
    /**
     * Filter which tv_profiles to delete
     */
    where?: tv_profileWhereInput
  }


  /**
   * tv_profile.tvs
   */
  export type tv_profile$tvsArgs = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    where?: tvWhereInput
    orderBy?: Enumerable<tvOrderByWithRelationInput>
    cursor?: tvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TvScalarFieldEnum>
  }


  /**
   * tv_profile.snapshots
   */
  export type tv_profile$snapshotsArgs = {
    /**
     * Select specific fields to fetch from the tv_profile_quick
     */
    select?: tv_profile_quickSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profile_quickInclude | null
    where?: tv_profile_quickWhereInput
    orderBy?: Enumerable<tv_profile_quickOrderByWithRelationInput>
    cursor?: tv_profile_quickWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Tv_profile_quickScalarFieldEnum>
  }


  /**
   * tv_profile without action
   */
  export type tv_profileArgs = {
    /**
     * Select specific fields to fetch from the tv_profile
     */
    select?: tv_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profileInclude | null
  }



  /**
   * Model season_profile
   */


  export type AggregateSeason_profile = {
    _count: Season_profileCountAggregateOutputType | null
    _avg: Season_profileAvgAggregateOutputType | null
    _sum: Season_profileSumAggregateOutputType | null
    _min: Season_profileMinAggregateOutputType | null
    _max: Season_profileMaxAggregateOutputType | null
  }

  export type Season_profileAvgAggregateOutputType = {
    source: number | null
    season_number: number | null
    episode_count: number | null
    vote_average: number | null
  }

  export type Season_profileSumAggregateOutputType = {
    source: number | null
    season_number: number | null
    episode_count: number | null
    vote_average: number | null
  }

  export type Season_profileMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    source: number | null
    sources: string | null
    name: string | null
    overview: string | null
    poster_path: string | null
    season_number: number | null
    air_date: string | null
    episode_count: number | null
    vote_average: number | null
  }

  export type Season_profileMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    source: number | null
    sources: string | null
    name: string | null
    overview: string | null
    poster_path: string | null
    season_number: number | null
    air_date: string | null
    episode_count: number | null
    vote_average: number | null
  }

  export type Season_profileCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    unique_id: number
    source: number
    sources: number
    name: number
    overview: number
    poster_path: number
    season_number: number
    air_date: number
    episode_count: number
    vote_average: number
    _all: number
  }


  export type Season_profileAvgAggregateInputType = {
    source?: true
    season_number?: true
    episode_count?: true
    vote_average?: true
  }

  export type Season_profileSumAggregateInputType = {
    source?: true
    season_number?: true
    episode_count?: true
    vote_average?: true
  }

  export type Season_profileMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    overview?: true
    poster_path?: true
    season_number?: true
    air_date?: true
    episode_count?: true
    vote_average?: true
  }

  export type Season_profileMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    overview?: true
    poster_path?: true
    season_number?: true
    air_date?: true
    episode_count?: true
    vote_average?: true
  }

  export type Season_profileCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    overview?: true
    poster_path?: true
    season_number?: true
    air_date?: true
    episode_count?: true
    vote_average?: true
    _all?: true
  }

  export type Season_profileAggregateArgs = {
    /**
     * Filter which season_profile to aggregate.
     */
    where?: season_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of season_profiles to fetch.
     */
    orderBy?: Enumerable<season_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: season_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` season_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` season_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned season_profiles
    **/
    _count?: true | Season_profileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Season_profileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Season_profileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Season_profileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Season_profileMaxAggregateInputType
  }

  export type GetSeason_profileAggregateType<T extends Season_profileAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason_profile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason_profile[P]>
      : GetScalarType<T[P], AggregateSeason_profile[P]>
  }




  export type Season_profileGroupByArgs = {
    where?: season_profileWhereInput
    orderBy?: Enumerable<season_profileOrderByWithAggregationInput>
    by: Season_profileScalarFieldEnum[]
    having?: season_profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Season_profileCountAggregateInputType | true
    _avg?: Season_profileAvgAggregateInputType
    _sum?: Season_profileSumAggregateInputType
    _min?: Season_profileMinAggregateInputType
    _max?: Season_profileMaxAggregateInputType
  }


  export type Season_profileGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    unique_id: string
    source: number | null
    sources: string | null
    name: string | null
    overview: string | null
    poster_path: string | null
    season_number: number | null
    air_date: string | null
    episode_count: number | null
    vote_average: number | null
    _count: Season_profileCountAggregateOutputType | null
    _avg: Season_profileAvgAggregateOutputType | null
    _sum: Season_profileSumAggregateOutputType | null
    _min: Season_profileMinAggregateOutputType | null
    _max: Season_profileMaxAggregateOutputType | null
  }

  type GetSeason_profileGroupByPayload<T extends Season_profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Season_profileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Season_profileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Season_profileGroupByOutputType[P]>
            : GetScalarType<T[P], Season_profileGroupByOutputType[P]>
        }
      >
    >


  export type season_profileSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    unique_id?: boolean
    source?: boolean
    sources?: boolean
    name?: boolean
    overview?: boolean
    poster_path?: boolean
    season_number?: boolean
    air_date?: boolean
    episode_count?: boolean
    vote_average?: boolean
    seasons?: boolean | season_profile$seasonsArgs
    _count?: boolean | Season_profileCountOutputTypeArgs
  }


  export type season_profileInclude = {
    seasons?: boolean | season_profile$seasonsArgs
    _count?: boolean | Season_profileCountOutputTypeArgs
  }

  export type season_profileGetPayload<S extends boolean | null | undefined | season_profileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? season_profile :
    S extends undefined ? never :
    S extends { include: any } & (season_profileArgs | season_profileFindManyArgs)
    ? season_profile  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'seasons' ? Array < seasonGetPayload<S['include'][P]>>  :
        P extends '_count' ? Season_profileCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (season_profileArgs | season_profileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'seasons' ? Array < seasonGetPayload<S['select'][P]>>  :
        P extends '_count' ? Season_profileCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof season_profile ? season_profile[P] : never
  } 
      : season_profile


  type season_profileCountArgs = 
    Omit<season_profileFindManyArgs, 'select' | 'include'> & {
      select?: Season_profileCountAggregateInputType | true
    }

  export interface season_profileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Season_profile that matches the filter.
     * @param {season_profileFindUniqueArgs} args - Arguments to find a Season_profile
     * @example
     * // Get one Season_profile
     * const season_profile = await prisma.season_profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends season_profileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, season_profileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'season_profile'> extends True ? Prisma__season_profileClient<season_profileGetPayload<T>> : Prisma__season_profileClient<season_profileGetPayload<T> | null, null>

    /**
     * Find one Season_profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {season_profileFindUniqueOrThrowArgs} args - Arguments to find a Season_profile
     * @example
     * // Get one Season_profile
     * const season_profile = await prisma.season_profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends season_profileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, season_profileFindUniqueOrThrowArgs>
    ): Prisma__season_profileClient<season_profileGetPayload<T>>

    /**
     * Find the first Season_profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {season_profileFindFirstArgs} args - Arguments to find a Season_profile
     * @example
     * // Get one Season_profile
     * const season_profile = await prisma.season_profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends season_profileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, season_profileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'season_profile'> extends True ? Prisma__season_profileClient<season_profileGetPayload<T>> : Prisma__season_profileClient<season_profileGetPayload<T> | null, null>

    /**
     * Find the first Season_profile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {season_profileFindFirstOrThrowArgs} args - Arguments to find a Season_profile
     * @example
     * // Get one Season_profile
     * const season_profile = await prisma.season_profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends season_profileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, season_profileFindFirstOrThrowArgs>
    ): Prisma__season_profileClient<season_profileGetPayload<T>>

    /**
     * Find zero or more Season_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {season_profileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Season_profiles
     * const season_profiles = await prisma.season_profile.findMany()
     * 
     * // Get first 10 Season_profiles
     * const season_profiles = await prisma.season_profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const season_profileWithIdOnly = await prisma.season_profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends season_profileFindManyArgs>(
      args?: SelectSubset<T, season_profileFindManyArgs>
    ): Prisma.PrismaPromise<Array<season_profileGetPayload<T>>>

    /**
     * Create a Season_profile.
     * @param {season_profileCreateArgs} args - Arguments to create a Season_profile.
     * @example
     * // Create one Season_profile
     * const Season_profile = await prisma.season_profile.create({
     *   data: {
     *     // ... data to create a Season_profile
     *   }
     * })
     * 
    **/
    create<T extends season_profileCreateArgs>(
      args: SelectSubset<T, season_profileCreateArgs>
    ): Prisma__season_profileClient<season_profileGetPayload<T>>

    /**
     * Delete a Season_profile.
     * @param {season_profileDeleteArgs} args - Arguments to delete one Season_profile.
     * @example
     * // Delete one Season_profile
     * const Season_profile = await prisma.season_profile.delete({
     *   where: {
     *     // ... filter to delete one Season_profile
     *   }
     * })
     * 
    **/
    delete<T extends season_profileDeleteArgs>(
      args: SelectSubset<T, season_profileDeleteArgs>
    ): Prisma__season_profileClient<season_profileGetPayload<T>>

    /**
     * Update one Season_profile.
     * @param {season_profileUpdateArgs} args - Arguments to update one Season_profile.
     * @example
     * // Update one Season_profile
     * const season_profile = await prisma.season_profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends season_profileUpdateArgs>(
      args: SelectSubset<T, season_profileUpdateArgs>
    ): Prisma__season_profileClient<season_profileGetPayload<T>>

    /**
     * Delete zero or more Season_profiles.
     * @param {season_profileDeleteManyArgs} args - Arguments to filter Season_profiles to delete.
     * @example
     * // Delete a few Season_profiles
     * const { count } = await prisma.season_profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends season_profileDeleteManyArgs>(
      args?: SelectSubset<T, season_profileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Season_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {season_profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Season_profiles
     * const season_profile = await prisma.season_profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends season_profileUpdateManyArgs>(
      args: SelectSubset<T, season_profileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Season_profile.
     * @param {season_profileUpsertArgs} args - Arguments to update or create a Season_profile.
     * @example
     * // Update or create a Season_profile
     * const season_profile = await prisma.season_profile.upsert({
     *   create: {
     *     // ... data to create a Season_profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season_profile we want to update
     *   }
     * })
    **/
    upsert<T extends season_profileUpsertArgs>(
      args: SelectSubset<T, season_profileUpsertArgs>
    ): Prisma__season_profileClient<season_profileGetPayload<T>>

    /**
     * Count the number of Season_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {season_profileCountArgs} args - Arguments to filter Season_profiles to count.
     * @example
     * // Count the number of Season_profiles
     * const count = await prisma.season_profile.count({
     *   where: {
     *     // ... the filter for the Season_profiles we want to count
     *   }
     * })
    **/
    count<T extends season_profileCountArgs>(
      args?: Subset<T, season_profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Season_profileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Season_profileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Season_profileAggregateArgs>(args: Subset<T, Season_profileAggregateArgs>): Prisma.PrismaPromise<GetSeason_profileAggregateType<T>>

    /**
     * Group by Season_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Season_profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Season_profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Season_profileGroupByArgs['orderBy'] }
        : { orderBy?: Season_profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Season_profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeason_profileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for season_profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__season_profileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    seasons<T extends season_profile$seasonsArgs= {}>(args?: Subset<T, season_profile$seasonsArgs>): Prisma.PrismaPromise<Array<seasonGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * season_profile base type for findUnique actions
   */
  export type season_profileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the season_profile
     */
    select?: season_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: season_profileInclude | null
    /**
     * Filter, which season_profile to fetch.
     */
    where: season_profileWhereUniqueInput
  }

  /**
   * season_profile findUnique
   */
  export interface season_profileFindUniqueArgs extends season_profileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * season_profile findUniqueOrThrow
   */
  export type season_profileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the season_profile
     */
    select?: season_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: season_profileInclude | null
    /**
     * Filter, which season_profile to fetch.
     */
    where: season_profileWhereUniqueInput
  }


  /**
   * season_profile base type for findFirst actions
   */
  export type season_profileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the season_profile
     */
    select?: season_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: season_profileInclude | null
    /**
     * Filter, which season_profile to fetch.
     */
    where?: season_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of season_profiles to fetch.
     */
    orderBy?: Enumerable<season_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for season_profiles.
     */
    cursor?: season_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` season_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` season_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of season_profiles.
     */
    distinct?: Enumerable<Season_profileScalarFieldEnum>
  }

  /**
   * season_profile findFirst
   */
  export interface season_profileFindFirstArgs extends season_profileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * season_profile findFirstOrThrow
   */
  export type season_profileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the season_profile
     */
    select?: season_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: season_profileInclude | null
    /**
     * Filter, which season_profile to fetch.
     */
    where?: season_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of season_profiles to fetch.
     */
    orderBy?: Enumerable<season_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for season_profiles.
     */
    cursor?: season_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` season_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` season_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of season_profiles.
     */
    distinct?: Enumerable<Season_profileScalarFieldEnum>
  }


  /**
   * season_profile findMany
   */
  export type season_profileFindManyArgs = {
    /**
     * Select specific fields to fetch from the season_profile
     */
    select?: season_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: season_profileInclude | null
    /**
     * Filter, which season_profiles to fetch.
     */
    where?: season_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of season_profiles to fetch.
     */
    orderBy?: Enumerable<season_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing season_profiles.
     */
    cursor?: season_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` season_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` season_profiles.
     */
    skip?: number
    distinct?: Enumerable<Season_profileScalarFieldEnum>
  }


  /**
   * season_profile create
   */
  export type season_profileCreateArgs = {
    /**
     * Select specific fields to fetch from the season_profile
     */
    select?: season_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: season_profileInclude | null
    /**
     * The data needed to create a season_profile.
     */
    data: XOR<season_profileCreateInput, season_profileUncheckedCreateInput>
  }


  /**
   * season_profile update
   */
  export type season_profileUpdateArgs = {
    /**
     * Select specific fields to fetch from the season_profile
     */
    select?: season_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: season_profileInclude | null
    /**
     * The data needed to update a season_profile.
     */
    data: XOR<season_profileUpdateInput, season_profileUncheckedUpdateInput>
    /**
     * Choose, which season_profile to update.
     */
    where: season_profileWhereUniqueInput
  }


  /**
   * season_profile updateMany
   */
  export type season_profileUpdateManyArgs = {
    /**
     * The data used to update season_profiles.
     */
    data: XOR<season_profileUpdateManyMutationInput, season_profileUncheckedUpdateManyInput>
    /**
     * Filter which season_profiles to update
     */
    where?: season_profileWhereInput
  }


  /**
   * season_profile upsert
   */
  export type season_profileUpsertArgs = {
    /**
     * Select specific fields to fetch from the season_profile
     */
    select?: season_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: season_profileInclude | null
    /**
     * The filter to search for the season_profile to update in case it exists.
     */
    where: season_profileWhereUniqueInput
    /**
     * In case the season_profile found by the `where` argument doesn't exist, create a new season_profile with this data.
     */
    create: XOR<season_profileCreateInput, season_profileUncheckedCreateInput>
    /**
     * In case the season_profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<season_profileUpdateInput, season_profileUncheckedUpdateInput>
  }


  /**
   * season_profile delete
   */
  export type season_profileDeleteArgs = {
    /**
     * Select specific fields to fetch from the season_profile
     */
    select?: season_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: season_profileInclude | null
    /**
     * Filter which season_profile to delete.
     */
    where: season_profileWhereUniqueInput
  }


  /**
   * season_profile deleteMany
   */
  export type season_profileDeleteManyArgs = {
    /**
     * Filter which season_profiles to delete
     */
    where?: season_profileWhereInput
  }


  /**
   * season_profile.seasons
   */
  export type season_profile$seasonsArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    where?: seasonWhereInput
    orderBy?: Enumerable<seasonOrderByWithRelationInput>
    cursor?: seasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SeasonScalarFieldEnum>
  }


  /**
   * season_profile without action
   */
  export type season_profileArgs = {
    /**
     * Select specific fields to fetch from the season_profile
     */
    select?: season_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: season_profileInclude | null
  }



  /**
   * Model episode_profile
   */


  export type AggregateEpisode_profile = {
    _count: Episode_profileCountAggregateOutputType | null
    _avg: Episode_profileAvgAggregateOutputType | null
    _sum: Episode_profileSumAggregateOutputType | null
    _min: Episode_profileMinAggregateOutputType | null
    _max: Episode_profileMaxAggregateOutputType | null
  }

  export type Episode_profileAvgAggregateOutputType = {
    source: number | null
    runtime: number | null
    episode_number: number | null
    season_number: number | null
  }

  export type Episode_profileSumAggregateOutputType = {
    source: number | null
    runtime: number | null
    episode_number: number | null
    season_number: number | null
  }

  export type Episode_profileMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    source: number | null
    sources: string | null
    name: string | null
    overview: string | null
    air_date: string | null
    runtime: number | null
    episode_number: number | null
    season_number: number | null
  }

  export type Episode_profileMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    source: number | null
    sources: string | null
    name: string | null
    overview: string | null
    air_date: string | null
    runtime: number | null
    episode_number: number | null
    season_number: number | null
  }

  export type Episode_profileCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    unique_id: number
    source: number
    sources: number
    name: number
    overview: number
    air_date: number
    runtime: number
    episode_number: number
    season_number: number
    _all: number
  }


  export type Episode_profileAvgAggregateInputType = {
    source?: true
    runtime?: true
    episode_number?: true
    season_number?: true
  }

  export type Episode_profileSumAggregateInputType = {
    source?: true
    runtime?: true
    episode_number?: true
    season_number?: true
  }

  export type Episode_profileMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    overview?: true
    air_date?: true
    runtime?: true
    episode_number?: true
    season_number?: true
  }

  export type Episode_profileMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    overview?: true
    air_date?: true
    runtime?: true
    episode_number?: true
    season_number?: true
  }

  export type Episode_profileCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    overview?: true
    air_date?: true
    runtime?: true
    episode_number?: true
    season_number?: true
    _all?: true
  }

  export type Episode_profileAggregateArgs = {
    /**
     * Filter which episode_profile to aggregate.
     */
    where?: episode_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episode_profiles to fetch.
     */
    orderBy?: Enumerable<episode_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: episode_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episode_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episode_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned episode_profiles
    **/
    _count?: true | Episode_profileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Episode_profileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Episode_profileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Episode_profileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Episode_profileMaxAggregateInputType
  }

  export type GetEpisode_profileAggregateType<T extends Episode_profileAggregateArgs> = {
        [P in keyof T & keyof AggregateEpisode_profile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpisode_profile[P]>
      : GetScalarType<T[P], AggregateEpisode_profile[P]>
  }




  export type Episode_profileGroupByArgs = {
    where?: episode_profileWhereInput
    orderBy?: Enumerable<episode_profileOrderByWithAggregationInput>
    by: Episode_profileScalarFieldEnum[]
    having?: episode_profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Episode_profileCountAggregateInputType | true
    _avg?: Episode_profileAvgAggregateInputType
    _sum?: Episode_profileSumAggregateInputType
    _min?: Episode_profileMinAggregateInputType
    _max?: Episode_profileMaxAggregateInputType
  }


  export type Episode_profileGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    unique_id: string
    source: number | null
    sources: string | null
    name: string | null
    overview: string | null
    air_date: string | null
    runtime: number | null
    episode_number: number | null
    season_number: number | null
    _count: Episode_profileCountAggregateOutputType | null
    _avg: Episode_profileAvgAggregateOutputType | null
    _sum: Episode_profileSumAggregateOutputType | null
    _min: Episode_profileMinAggregateOutputType | null
    _max: Episode_profileMaxAggregateOutputType | null
  }

  type GetEpisode_profileGroupByPayload<T extends Episode_profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Episode_profileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Episode_profileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Episode_profileGroupByOutputType[P]>
            : GetScalarType<T[P], Episode_profileGroupByOutputType[P]>
        }
      >
    >


  export type episode_profileSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    unique_id?: boolean
    source?: boolean
    sources?: boolean
    name?: boolean
    overview?: boolean
    air_date?: boolean
    runtime?: boolean
    episode_number?: boolean
    season_number?: boolean
    episodes?: boolean | episode_profile$episodesArgs
    _count?: boolean | Episode_profileCountOutputTypeArgs
  }


  export type episode_profileInclude = {
    episodes?: boolean | episode_profile$episodesArgs
    _count?: boolean | Episode_profileCountOutputTypeArgs
  }

  export type episode_profileGetPayload<S extends boolean | null | undefined | episode_profileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? episode_profile :
    S extends undefined ? never :
    S extends { include: any } & (episode_profileArgs | episode_profileFindManyArgs)
    ? episode_profile  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'episodes' ? Array < episodeGetPayload<S['include'][P]>>  :
        P extends '_count' ? Episode_profileCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (episode_profileArgs | episode_profileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'episodes' ? Array < episodeGetPayload<S['select'][P]>>  :
        P extends '_count' ? Episode_profileCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof episode_profile ? episode_profile[P] : never
  } 
      : episode_profile


  type episode_profileCountArgs = 
    Omit<episode_profileFindManyArgs, 'select' | 'include'> & {
      select?: Episode_profileCountAggregateInputType | true
    }

  export interface episode_profileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Episode_profile that matches the filter.
     * @param {episode_profileFindUniqueArgs} args - Arguments to find a Episode_profile
     * @example
     * // Get one Episode_profile
     * const episode_profile = await prisma.episode_profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends episode_profileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, episode_profileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'episode_profile'> extends True ? Prisma__episode_profileClient<episode_profileGetPayload<T>> : Prisma__episode_profileClient<episode_profileGetPayload<T> | null, null>

    /**
     * Find one Episode_profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {episode_profileFindUniqueOrThrowArgs} args - Arguments to find a Episode_profile
     * @example
     * // Get one Episode_profile
     * const episode_profile = await prisma.episode_profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends episode_profileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, episode_profileFindUniqueOrThrowArgs>
    ): Prisma__episode_profileClient<episode_profileGetPayload<T>>

    /**
     * Find the first Episode_profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_profileFindFirstArgs} args - Arguments to find a Episode_profile
     * @example
     * // Get one Episode_profile
     * const episode_profile = await prisma.episode_profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends episode_profileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, episode_profileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'episode_profile'> extends True ? Prisma__episode_profileClient<episode_profileGetPayload<T>> : Prisma__episode_profileClient<episode_profileGetPayload<T> | null, null>

    /**
     * Find the first Episode_profile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_profileFindFirstOrThrowArgs} args - Arguments to find a Episode_profile
     * @example
     * // Get one Episode_profile
     * const episode_profile = await prisma.episode_profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends episode_profileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, episode_profileFindFirstOrThrowArgs>
    ): Prisma__episode_profileClient<episode_profileGetPayload<T>>

    /**
     * Find zero or more Episode_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_profileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Episode_profiles
     * const episode_profiles = await prisma.episode_profile.findMany()
     * 
     * // Get first 10 Episode_profiles
     * const episode_profiles = await prisma.episode_profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const episode_profileWithIdOnly = await prisma.episode_profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends episode_profileFindManyArgs>(
      args?: SelectSubset<T, episode_profileFindManyArgs>
    ): Prisma.PrismaPromise<Array<episode_profileGetPayload<T>>>

    /**
     * Create a Episode_profile.
     * @param {episode_profileCreateArgs} args - Arguments to create a Episode_profile.
     * @example
     * // Create one Episode_profile
     * const Episode_profile = await prisma.episode_profile.create({
     *   data: {
     *     // ... data to create a Episode_profile
     *   }
     * })
     * 
    **/
    create<T extends episode_profileCreateArgs>(
      args: SelectSubset<T, episode_profileCreateArgs>
    ): Prisma__episode_profileClient<episode_profileGetPayload<T>>

    /**
     * Delete a Episode_profile.
     * @param {episode_profileDeleteArgs} args - Arguments to delete one Episode_profile.
     * @example
     * // Delete one Episode_profile
     * const Episode_profile = await prisma.episode_profile.delete({
     *   where: {
     *     // ... filter to delete one Episode_profile
     *   }
     * })
     * 
    **/
    delete<T extends episode_profileDeleteArgs>(
      args: SelectSubset<T, episode_profileDeleteArgs>
    ): Prisma__episode_profileClient<episode_profileGetPayload<T>>

    /**
     * Update one Episode_profile.
     * @param {episode_profileUpdateArgs} args - Arguments to update one Episode_profile.
     * @example
     * // Update one Episode_profile
     * const episode_profile = await prisma.episode_profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends episode_profileUpdateArgs>(
      args: SelectSubset<T, episode_profileUpdateArgs>
    ): Prisma__episode_profileClient<episode_profileGetPayload<T>>

    /**
     * Delete zero or more Episode_profiles.
     * @param {episode_profileDeleteManyArgs} args - Arguments to filter Episode_profiles to delete.
     * @example
     * // Delete a few Episode_profiles
     * const { count } = await prisma.episode_profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends episode_profileDeleteManyArgs>(
      args?: SelectSubset<T, episode_profileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Episode_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Episode_profiles
     * const episode_profile = await prisma.episode_profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends episode_profileUpdateManyArgs>(
      args: SelectSubset<T, episode_profileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Episode_profile.
     * @param {episode_profileUpsertArgs} args - Arguments to update or create a Episode_profile.
     * @example
     * // Update or create a Episode_profile
     * const episode_profile = await prisma.episode_profile.upsert({
     *   create: {
     *     // ... data to create a Episode_profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Episode_profile we want to update
     *   }
     * })
    **/
    upsert<T extends episode_profileUpsertArgs>(
      args: SelectSubset<T, episode_profileUpsertArgs>
    ): Prisma__episode_profileClient<episode_profileGetPayload<T>>

    /**
     * Count the number of Episode_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episode_profileCountArgs} args - Arguments to filter Episode_profiles to count.
     * @example
     * // Count the number of Episode_profiles
     * const count = await prisma.episode_profile.count({
     *   where: {
     *     // ... the filter for the Episode_profiles we want to count
     *   }
     * })
    **/
    count<T extends episode_profileCountArgs>(
      args?: Subset<T, episode_profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Episode_profileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Episode_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Episode_profileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Episode_profileAggregateArgs>(args: Subset<T, Episode_profileAggregateArgs>): Prisma.PrismaPromise<GetEpisode_profileAggregateType<T>>

    /**
     * Group by Episode_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Episode_profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Episode_profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Episode_profileGroupByArgs['orderBy'] }
        : { orderBy?: Episode_profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Episode_profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpisode_profileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for episode_profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__episode_profileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    episodes<T extends episode_profile$episodesArgs= {}>(args?: Subset<T, episode_profile$episodesArgs>): Prisma.PrismaPromise<Array<episodeGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * episode_profile base type for findUnique actions
   */
  export type episode_profileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the episode_profile
     */
    select?: episode_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episode_profileInclude | null
    /**
     * Filter, which episode_profile to fetch.
     */
    where: episode_profileWhereUniqueInput
  }

  /**
   * episode_profile findUnique
   */
  export interface episode_profileFindUniqueArgs extends episode_profileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * episode_profile findUniqueOrThrow
   */
  export type episode_profileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the episode_profile
     */
    select?: episode_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episode_profileInclude | null
    /**
     * Filter, which episode_profile to fetch.
     */
    where: episode_profileWhereUniqueInput
  }


  /**
   * episode_profile base type for findFirst actions
   */
  export type episode_profileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the episode_profile
     */
    select?: episode_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episode_profileInclude | null
    /**
     * Filter, which episode_profile to fetch.
     */
    where?: episode_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episode_profiles to fetch.
     */
    orderBy?: Enumerable<episode_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for episode_profiles.
     */
    cursor?: episode_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episode_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episode_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of episode_profiles.
     */
    distinct?: Enumerable<Episode_profileScalarFieldEnum>
  }

  /**
   * episode_profile findFirst
   */
  export interface episode_profileFindFirstArgs extends episode_profileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * episode_profile findFirstOrThrow
   */
  export type episode_profileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the episode_profile
     */
    select?: episode_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episode_profileInclude | null
    /**
     * Filter, which episode_profile to fetch.
     */
    where?: episode_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episode_profiles to fetch.
     */
    orderBy?: Enumerable<episode_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for episode_profiles.
     */
    cursor?: episode_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episode_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episode_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of episode_profiles.
     */
    distinct?: Enumerable<Episode_profileScalarFieldEnum>
  }


  /**
   * episode_profile findMany
   */
  export type episode_profileFindManyArgs = {
    /**
     * Select specific fields to fetch from the episode_profile
     */
    select?: episode_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episode_profileInclude | null
    /**
     * Filter, which episode_profiles to fetch.
     */
    where?: episode_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episode_profiles to fetch.
     */
    orderBy?: Enumerable<episode_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing episode_profiles.
     */
    cursor?: episode_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episode_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episode_profiles.
     */
    skip?: number
    distinct?: Enumerable<Episode_profileScalarFieldEnum>
  }


  /**
   * episode_profile create
   */
  export type episode_profileCreateArgs = {
    /**
     * Select specific fields to fetch from the episode_profile
     */
    select?: episode_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episode_profileInclude | null
    /**
     * The data needed to create a episode_profile.
     */
    data: XOR<episode_profileCreateInput, episode_profileUncheckedCreateInput>
  }


  /**
   * episode_profile update
   */
  export type episode_profileUpdateArgs = {
    /**
     * Select specific fields to fetch from the episode_profile
     */
    select?: episode_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episode_profileInclude | null
    /**
     * The data needed to update a episode_profile.
     */
    data: XOR<episode_profileUpdateInput, episode_profileUncheckedUpdateInput>
    /**
     * Choose, which episode_profile to update.
     */
    where: episode_profileWhereUniqueInput
  }


  /**
   * episode_profile updateMany
   */
  export type episode_profileUpdateManyArgs = {
    /**
     * The data used to update episode_profiles.
     */
    data: XOR<episode_profileUpdateManyMutationInput, episode_profileUncheckedUpdateManyInput>
    /**
     * Filter which episode_profiles to update
     */
    where?: episode_profileWhereInput
  }


  /**
   * episode_profile upsert
   */
  export type episode_profileUpsertArgs = {
    /**
     * Select specific fields to fetch from the episode_profile
     */
    select?: episode_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episode_profileInclude | null
    /**
     * The filter to search for the episode_profile to update in case it exists.
     */
    where: episode_profileWhereUniqueInput
    /**
     * In case the episode_profile found by the `where` argument doesn't exist, create a new episode_profile with this data.
     */
    create: XOR<episode_profileCreateInput, episode_profileUncheckedCreateInput>
    /**
     * In case the episode_profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<episode_profileUpdateInput, episode_profileUncheckedUpdateInput>
  }


  /**
   * episode_profile delete
   */
  export type episode_profileDeleteArgs = {
    /**
     * Select specific fields to fetch from the episode_profile
     */
    select?: episode_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episode_profileInclude | null
    /**
     * Filter which episode_profile to delete.
     */
    where: episode_profileWhereUniqueInput
  }


  /**
   * episode_profile deleteMany
   */
  export type episode_profileDeleteManyArgs = {
    /**
     * Filter which episode_profiles to delete
     */
    where?: episode_profileWhereInput
  }


  /**
   * episode_profile.episodes
   */
  export type episode_profile$episodesArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    where?: episodeWhereInput
    orderBy?: Enumerable<episodeOrderByWithRelationInput>
    cursor?: episodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EpisodeScalarFieldEnum>
  }


  /**
   * episode_profile without action
   */
  export type episode_profileArgs = {
    /**
     * Select specific fields to fetch from the episode_profile
     */
    select?: episode_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episode_profileInclude | null
  }



  /**
   * Model movie_profile
   */


  export type AggregateMovie_profile = {
    _count: Movie_profileCountAggregateOutputType | null
    _avg: Movie_profileAvgAggregateOutputType | null
    _sum: Movie_profileSumAggregateOutputType | null
    _min: Movie_profileMinAggregateOutputType | null
    _max: Movie_profileMaxAggregateOutputType | null
  }

  export type Movie_profileAvgAggregateOutputType = {
    source: number | null
    popularity: number | null
    vote_average: number | null
    vote_count: number | null
    runtime: number | null
  }

  export type Movie_profileSumAggregateOutputType = {
    source: number | null
    popularity: number | null
    vote_average: number | null
    vote_count: number | null
    runtime: number | null
  }

  export type Movie_profileMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    source: number | null
    sources: string | null
    name: string | null
    original_name: string | null
    overview: string | null
    poster_path: string | null
    backdrop_path: string | null
    air_date: string | null
    original_language: string | null
    popularity: number | null
    vote_average: number | null
    vote_count: number | null
    origin_country: string | null
    genres: string | null
    runtime: number | null
  }

  export type Movie_profileMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    source: number | null
    sources: string | null
    name: string | null
    original_name: string | null
    overview: string | null
    poster_path: string | null
    backdrop_path: string | null
    air_date: string | null
    original_language: string | null
    popularity: number | null
    vote_average: number | null
    vote_count: number | null
    origin_country: string | null
    genres: string | null
    runtime: number | null
  }

  export type Movie_profileCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    unique_id: number
    source: number
    sources: number
    name: number
    original_name: number
    overview: number
    poster_path: number
    backdrop_path: number
    air_date: number
    original_language: number
    popularity: number
    vote_average: number
    vote_count: number
    origin_country: number
    genres: number
    runtime: number
    _all: number
  }


  export type Movie_profileAvgAggregateInputType = {
    source?: true
    popularity?: true
    vote_average?: true
    vote_count?: true
    runtime?: true
  }

  export type Movie_profileSumAggregateInputType = {
    source?: true
    popularity?: true
    vote_average?: true
    vote_count?: true
    runtime?: true
  }

  export type Movie_profileMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    original_name?: true
    overview?: true
    poster_path?: true
    backdrop_path?: true
    air_date?: true
    original_language?: true
    popularity?: true
    vote_average?: true
    vote_count?: true
    origin_country?: true
    genres?: true
    runtime?: true
  }

  export type Movie_profileMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    original_name?: true
    overview?: true
    poster_path?: true
    backdrop_path?: true
    air_date?: true
    original_language?: true
    popularity?: true
    vote_average?: true
    vote_count?: true
    origin_country?: true
    genres?: true
    runtime?: true
  }

  export type Movie_profileCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    source?: true
    sources?: true
    name?: true
    original_name?: true
    overview?: true
    poster_path?: true
    backdrop_path?: true
    air_date?: true
    original_language?: true
    popularity?: true
    vote_average?: true
    vote_count?: true
    origin_country?: true
    genres?: true
    runtime?: true
    _all?: true
  }

  export type Movie_profileAggregateArgs = {
    /**
     * Filter which movie_profile to aggregate.
     */
    where?: movie_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movie_profiles to fetch.
     */
    orderBy?: Enumerable<movie_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: movie_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movie_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movie_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned movie_profiles
    **/
    _count?: true | Movie_profileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Movie_profileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Movie_profileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Movie_profileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Movie_profileMaxAggregateInputType
  }

  export type GetMovie_profileAggregateType<T extends Movie_profileAggregateArgs> = {
        [P in keyof T & keyof AggregateMovie_profile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovie_profile[P]>
      : GetScalarType<T[P], AggregateMovie_profile[P]>
  }




  export type Movie_profileGroupByArgs = {
    where?: movie_profileWhereInput
    orderBy?: Enumerable<movie_profileOrderByWithAggregationInput>
    by: Movie_profileScalarFieldEnum[]
    having?: movie_profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Movie_profileCountAggregateInputType | true
    _avg?: Movie_profileAvgAggregateInputType
    _sum?: Movie_profileSumAggregateInputType
    _min?: Movie_profileMinAggregateInputType
    _max?: Movie_profileMaxAggregateInputType
  }


  export type Movie_profileGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    unique_id: string
    source: number | null
    sources: string | null
    name: string | null
    original_name: string | null
    overview: string | null
    poster_path: string | null
    backdrop_path: string | null
    air_date: string | null
    original_language: string | null
    popularity: number | null
    vote_average: number | null
    vote_count: number | null
    origin_country: string | null
    genres: string | null
    runtime: number | null
    _count: Movie_profileCountAggregateOutputType | null
    _avg: Movie_profileAvgAggregateOutputType | null
    _sum: Movie_profileSumAggregateOutputType | null
    _min: Movie_profileMinAggregateOutputType | null
    _max: Movie_profileMaxAggregateOutputType | null
  }

  type GetMovie_profileGroupByPayload<T extends Movie_profileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Movie_profileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Movie_profileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Movie_profileGroupByOutputType[P]>
            : GetScalarType<T[P], Movie_profileGroupByOutputType[P]>
        }
      >
    >


  export type movie_profileSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    unique_id?: boolean
    source?: boolean
    sources?: boolean
    name?: boolean
    original_name?: boolean
    overview?: boolean
    poster_path?: boolean
    backdrop_path?: boolean
    air_date?: boolean
    original_language?: boolean
    popularity?: boolean
    vote_average?: boolean
    vote_count?: boolean
    origin_country?: boolean
    genres?: boolean
    runtime?: boolean
    movies?: boolean | movie_profile$moviesArgs
    _count?: boolean | Movie_profileCountOutputTypeArgs
  }


  export type movie_profileInclude = {
    movies?: boolean | movie_profile$moviesArgs
    _count?: boolean | Movie_profileCountOutputTypeArgs
  }

  export type movie_profileGetPayload<S extends boolean | null | undefined | movie_profileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? movie_profile :
    S extends undefined ? never :
    S extends { include: any } & (movie_profileArgs | movie_profileFindManyArgs)
    ? movie_profile  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'movies' ? Array < movieGetPayload<S['include'][P]>>  :
        P extends '_count' ? Movie_profileCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (movie_profileArgs | movie_profileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'movies' ? Array < movieGetPayload<S['select'][P]>>  :
        P extends '_count' ? Movie_profileCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof movie_profile ? movie_profile[P] : never
  } 
      : movie_profile


  type movie_profileCountArgs = 
    Omit<movie_profileFindManyArgs, 'select' | 'include'> & {
      select?: Movie_profileCountAggregateInputType | true
    }

  export interface movie_profileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Movie_profile that matches the filter.
     * @param {movie_profileFindUniqueArgs} args - Arguments to find a Movie_profile
     * @example
     * // Get one Movie_profile
     * const movie_profile = await prisma.movie_profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends movie_profileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, movie_profileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'movie_profile'> extends True ? Prisma__movie_profileClient<movie_profileGetPayload<T>> : Prisma__movie_profileClient<movie_profileGetPayload<T> | null, null>

    /**
     * Find one Movie_profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {movie_profileFindUniqueOrThrowArgs} args - Arguments to find a Movie_profile
     * @example
     * // Get one Movie_profile
     * const movie_profile = await prisma.movie_profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends movie_profileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, movie_profileFindUniqueOrThrowArgs>
    ): Prisma__movie_profileClient<movie_profileGetPayload<T>>

    /**
     * Find the first Movie_profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movie_profileFindFirstArgs} args - Arguments to find a Movie_profile
     * @example
     * // Get one Movie_profile
     * const movie_profile = await prisma.movie_profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends movie_profileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, movie_profileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'movie_profile'> extends True ? Prisma__movie_profileClient<movie_profileGetPayload<T>> : Prisma__movie_profileClient<movie_profileGetPayload<T> | null, null>

    /**
     * Find the first Movie_profile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movie_profileFindFirstOrThrowArgs} args - Arguments to find a Movie_profile
     * @example
     * // Get one Movie_profile
     * const movie_profile = await prisma.movie_profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends movie_profileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, movie_profileFindFirstOrThrowArgs>
    ): Prisma__movie_profileClient<movie_profileGetPayload<T>>

    /**
     * Find zero or more Movie_profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movie_profileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movie_profiles
     * const movie_profiles = await prisma.movie_profile.findMany()
     * 
     * // Get first 10 Movie_profiles
     * const movie_profiles = await prisma.movie_profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movie_profileWithIdOnly = await prisma.movie_profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends movie_profileFindManyArgs>(
      args?: SelectSubset<T, movie_profileFindManyArgs>
    ): Prisma.PrismaPromise<Array<movie_profileGetPayload<T>>>

    /**
     * Create a Movie_profile.
     * @param {movie_profileCreateArgs} args - Arguments to create a Movie_profile.
     * @example
     * // Create one Movie_profile
     * const Movie_profile = await prisma.movie_profile.create({
     *   data: {
     *     // ... data to create a Movie_profile
     *   }
     * })
     * 
    **/
    create<T extends movie_profileCreateArgs>(
      args: SelectSubset<T, movie_profileCreateArgs>
    ): Prisma__movie_profileClient<movie_profileGetPayload<T>>

    /**
     * Delete a Movie_profile.
     * @param {movie_profileDeleteArgs} args - Arguments to delete one Movie_profile.
     * @example
     * // Delete one Movie_profile
     * const Movie_profile = await prisma.movie_profile.delete({
     *   where: {
     *     // ... filter to delete one Movie_profile
     *   }
     * })
     * 
    **/
    delete<T extends movie_profileDeleteArgs>(
      args: SelectSubset<T, movie_profileDeleteArgs>
    ): Prisma__movie_profileClient<movie_profileGetPayload<T>>

    /**
     * Update one Movie_profile.
     * @param {movie_profileUpdateArgs} args - Arguments to update one Movie_profile.
     * @example
     * // Update one Movie_profile
     * const movie_profile = await prisma.movie_profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends movie_profileUpdateArgs>(
      args: SelectSubset<T, movie_profileUpdateArgs>
    ): Prisma__movie_profileClient<movie_profileGetPayload<T>>

    /**
     * Delete zero or more Movie_profiles.
     * @param {movie_profileDeleteManyArgs} args - Arguments to filter Movie_profiles to delete.
     * @example
     * // Delete a few Movie_profiles
     * const { count } = await prisma.movie_profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends movie_profileDeleteManyArgs>(
      args?: SelectSubset<T, movie_profileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movie_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movie_profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movie_profiles
     * const movie_profile = await prisma.movie_profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends movie_profileUpdateManyArgs>(
      args: SelectSubset<T, movie_profileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Movie_profile.
     * @param {movie_profileUpsertArgs} args - Arguments to update or create a Movie_profile.
     * @example
     * // Update or create a Movie_profile
     * const movie_profile = await prisma.movie_profile.upsert({
     *   create: {
     *     // ... data to create a Movie_profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movie_profile we want to update
     *   }
     * })
    **/
    upsert<T extends movie_profileUpsertArgs>(
      args: SelectSubset<T, movie_profileUpsertArgs>
    ): Prisma__movie_profileClient<movie_profileGetPayload<T>>

    /**
     * Count the number of Movie_profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movie_profileCountArgs} args - Arguments to filter Movie_profiles to count.
     * @example
     * // Count the number of Movie_profiles
     * const count = await prisma.movie_profile.count({
     *   where: {
     *     // ... the filter for the Movie_profiles we want to count
     *   }
     * })
    **/
    count<T extends movie_profileCountArgs>(
      args?: Subset<T, movie_profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Movie_profileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movie_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Movie_profileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Movie_profileAggregateArgs>(args: Subset<T, Movie_profileAggregateArgs>): Prisma.PrismaPromise<GetMovie_profileAggregateType<T>>

    /**
     * Group by Movie_profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Movie_profileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Movie_profileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Movie_profileGroupByArgs['orderBy'] }
        : { orderBy?: Movie_profileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Movie_profileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovie_profileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for movie_profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__movie_profileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    movies<T extends movie_profile$moviesArgs= {}>(args?: Subset<T, movie_profile$moviesArgs>): Prisma.PrismaPromise<Array<movieGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * movie_profile base type for findUnique actions
   */
  export type movie_profileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the movie_profile
     */
    select?: movie_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movie_profileInclude | null
    /**
     * Filter, which movie_profile to fetch.
     */
    where: movie_profileWhereUniqueInput
  }

  /**
   * movie_profile findUnique
   */
  export interface movie_profileFindUniqueArgs extends movie_profileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * movie_profile findUniqueOrThrow
   */
  export type movie_profileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the movie_profile
     */
    select?: movie_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movie_profileInclude | null
    /**
     * Filter, which movie_profile to fetch.
     */
    where: movie_profileWhereUniqueInput
  }


  /**
   * movie_profile base type for findFirst actions
   */
  export type movie_profileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the movie_profile
     */
    select?: movie_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movie_profileInclude | null
    /**
     * Filter, which movie_profile to fetch.
     */
    where?: movie_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movie_profiles to fetch.
     */
    orderBy?: Enumerable<movie_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for movie_profiles.
     */
    cursor?: movie_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movie_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movie_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of movie_profiles.
     */
    distinct?: Enumerable<Movie_profileScalarFieldEnum>
  }

  /**
   * movie_profile findFirst
   */
  export interface movie_profileFindFirstArgs extends movie_profileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * movie_profile findFirstOrThrow
   */
  export type movie_profileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the movie_profile
     */
    select?: movie_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movie_profileInclude | null
    /**
     * Filter, which movie_profile to fetch.
     */
    where?: movie_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movie_profiles to fetch.
     */
    orderBy?: Enumerable<movie_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for movie_profiles.
     */
    cursor?: movie_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movie_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movie_profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of movie_profiles.
     */
    distinct?: Enumerable<Movie_profileScalarFieldEnum>
  }


  /**
   * movie_profile findMany
   */
  export type movie_profileFindManyArgs = {
    /**
     * Select specific fields to fetch from the movie_profile
     */
    select?: movie_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movie_profileInclude | null
    /**
     * Filter, which movie_profiles to fetch.
     */
    where?: movie_profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movie_profiles to fetch.
     */
    orderBy?: Enumerable<movie_profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing movie_profiles.
     */
    cursor?: movie_profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movie_profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movie_profiles.
     */
    skip?: number
    distinct?: Enumerable<Movie_profileScalarFieldEnum>
  }


  /**
   * movie_profile create
   */
  export type movie_profileCreateArgs = {
    /**
     * Select specific fields to fetch from the movie_profile
     */
    select?: movie_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movie_profileInclude | null
    /**
     * The data needed to create a movie_profile.
     */
    data: XOR<movie_profileCreateInput, movie_profileUncheckedCreateInput>
  }


  /**
   * movie_profile update
   */
  export type movie_profileUpdateArgs = {
    /**
     * Select specific fields to fetch from the movie_profile
     */
    select?: movie_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movie_profileInclude | null
    /**
     * The data needed to update a movie_profile.
     */
    data: XOR<movie_profileUpdateInput, movie_profileUncheckedUpdateInput>
    /**
     * Choose, which movie_profile to update.
     */
    where: movie_profileWhereUniqueInput
  }


  /**
   * movie_profile updateMany
   */
  export type movie_profileUpdateManyArgs = {
    /**
     * The data used to update movie_profiles.
     */
    data: XOR<movie_profileUpdateManyMutationInput, movie_profileUncheckedUpdateManyInput>
    /**
     * Filter which movie_profiles to update
     */
    where?: movie_profileWhereInput
  }


  /**
   * movie_profile upsert
   */
  export type movie_profileUpsertArgs = {
    /**
     * Select specific fields to fetch from the movie_profile
     */
    select?: movie_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movie_profileInclude | null
    /**
     * The filter to search for the movie_profile to update in case it exists.
     */
    where: movie_profileWhereUniqueInput
    /**
     * In case the movie_profile found by the `where` argument doesn't exist, create a new movie_profile with this data.
     */
    create: XOR<movie_profileCreateInput, movie_profileUncheckedCreateInput>
    /**
     * In case the movie_profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<movie_profileUpdateInput, movie_profileUncheckedUpdateInput>
  }


  /**
   * movie_profile delete
   */
  export type movie_profileDeleteArgs = {
    /**
     * Select specific fields to fetch from the movie_profile
     */
    select?: movie_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movie_profileInclude | null
    /**
     * Filter which movie_profile to delete.
     */
    where: movie_profileWhereUniqueInput
  }


  /**
   * movie_profile deleteMany
   */
  export type movie_profileDeleteManyArgs = {
    /**
     * Filter which movie_profiles to delete
     */
    where?: movie_profileWhereInput
  }


  /**
   * movie_profile.movies
   */
  export type movie_profile$moviesArgs = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    where?: movieWhereInput
    orderBy?: Enumerable<movieOrderByWithRelationInput>
    cursor?: movieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MovieScalarFieldEnum>
  }


  /**
   * movie_profile without action
   */
  export type movie_profileArgs = {
    /**
     * Select specific fields to fetch from the movie_profile
     */
    select?: movie_profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movie_profileInclude | null
  }



  /**
   * Model subtitle
   */


  export type AggregateSubtitle = {
    _count: SubtitleCountAggregateOutputType | null
    _min: SubtitleMinAggregateOutputType | null
    _max: SubtitleMaxAggregateOutputType | null
  }

  export type SubtitleMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    file_id: string | null
    name: string | null
    language: string | null
    movie_id: string | null
    episode_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type SubtitleMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    file_id: string | null
    name: string | null
    language: string | null
    movie_id: string | null
    episode_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type SubtitleCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    file_id: number
    name: number
    language: number
    movie_id: number
    episode_id: number
    drive_id: number
    user_id: number
    _all: number
  }


  export type SubtitleMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    file_id?: true
    name?: true
    language?: true
    movie_id?: true
    episode_id?: true
    drive_id?: true
    user_id?: true
  }

  export type SubtitleMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    file_id?: true
    name?: true
    language?: true
    movie_id?: true
    episode_id?: true
    drive_id?: true
    user_id?: true
  }

  export type SubtitleCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    file_id?: true
    name?: true
    language?: true
    movie_id?: true
    episode_id?: true
    drive_id?: true
    user_id?: true
    _all?: true
  }

  export type SubtitleAggregateArgs = {
    /**
     * Filter which subtitle to aggregate.
     */
    where?: subtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subtitles to fetch.
     */
    orderBy?: Enumerable<subtitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: subtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subtitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned subtitles
    **/
    _count?: true | SubtitleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubtitleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubtitleMaxAggregateInputType
  }

  export type GetSubtitleAggregateType<T extends SubtitleAggregateArgs> = {
        [P in keyof T & keyof AggregateSubtitle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubtitle[P]>
      : GetScalarType<T[P], AggregateSubtitle[P]>
  }




  export type SubtitleGroupByArgs = {
    where?: subtitleWhereInput
    orderBy?: Enumerable<subtitleOrderByWithAggregationInput>
    by: SubtitleScalarFieldEnum[]
    having?: subtitleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubtitleCountAggregateInputType | true
    _min?: SubtitleMinAggregateInputType
    _max?: SubtitleMaxAggregateInputType
  }


  export type SubtitleGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    file_id: string
    name: string
    language: string
    movie_id: string | null
    episode_id: string | null
    drive_id: string
    user_id: string
    _count: SubtitleCountAggregateOutputType | null
    _min: SubtitleMinAggregateOutputType | null
    _max: SubtitleMaxAggregateOutputType | null
  }

  type GetSubtitleGroupByPayload<T extends SubtitleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SubtitleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubtitleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubtitleGroupByOutputType[P]>
            : GetScalarType<T[P], SubtitleGroupByOutputType[P]>
        }
      >
    >


  export type subtitleSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    file_id?: boolean
    name?: boolean
    language?: boolean
    movie_id?: boolean
    episode_id?: boolean
    drive_id?: boolean
    user_id?: boolean
    movie?: boolean | movieArgs
    episode?: boolean | episodeArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }


  export type subtitleInclude = {
    movie?: boolean | movieArgs
    episode?: boolean | episodeArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }

  export type subtitleGetPayload<S extends boolean | null | undefined | subtitleArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? subtitle :
    S extends undefined ? never :
    S extends { include: any } & (subtitleArgs | subtitleFindManyArgs)
    ? subtitle  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'movie' ? movieGetPayload<S['include'][P]> | null :
        P extends 'episode' ? episodeGetPayload<S['include'][P]> | null :
        P extends 'drive' ? driveGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (subtitleArgs | subtitleFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'movie' ? movieGetPayload<S['select'][P]> | null :
        P extends 'episode' ? episodeGetPayload<S['select'][P]> | null :
        P extends 'drive' ? driveGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof subtitle ? subtitle[P] : never
  } 
      : subtitle


  type subtitleCountArgs = 
    Omit<subtitleFindManyArgs, 'select' | 'include'> & {
      select?: SubtitleCountAggregateInputType | true
    }

  export interface subtitleDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Subtitle that matches the filter.
     * @param {subtitleFindUniqueArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends subtitleFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, subtitleFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'subtitle'> extends True ? Prisma__subtitleClient<subtitleGetPayload<T>> : Prisma__subtitleClient<subtitleGetPayload<T> | null, null>

    /**
     * Find one Subtitle that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {subtitleFindUniqueOrThrowArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends subtitleFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, subtitleFindUniqueOrThrowArgs>
    ): Prisma__subtitleClient<subtitleGetPayload<T>>

    /**
     * Find the first Subtitle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtitleFindFirstArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends subtitleFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, subtitleFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'subtitle'> extends True ? Prisma__subtitleClient<subtitleGetPayload<T>> : Prisma__subtitleClient<subtitleGetPayload<T> | null, null>

    /**
     * Find the first Subtitle that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtitleFindFirstOrThrowArgs} args - Arguments to find a Subtitle
     * @example
     * // Get one Subtitle
     * const subtitle = await prisma.subtitle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends subtitleFindFirstOrThrowArgs>(
      args?: SelectSubset<T, subtitleFindFirstOrThrowArgs>
    ): Prisma__subtitleClient<subtitleGetPayload<T>>

    /**
     * Find zero or more Subtitles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtitleFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Subtitles
     * const subtitles = await prisma.subtitle.findMany()
     * 
     * // Get first 10 Subtitles
     * const subtitles = await prisma.subtitle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subtitleWithIdOnly = await prisma.subtitle.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends subtitleFindManyArgs>(
      args?: SelectSubset<T, subtitleFindManyArgs>
    ): Prisma.PrismaPromise<Array<subtitleGetPayload<T>>>

    /**
     * Create a Subtitle.
     * @param {subtitleCreateArgs} args - Arguments to create a Subtitle.
     * @example
     * // Create one Subtitle
     * const Subtitle = await prisma.subtitle.create({
     *   data: {
     *     // ... data to create a Subtitle
     *   }
     * })
     * 
    **/
    create<T extends subtitleCreateArgs>(
      args: SelectSubset<T, subtitleCreateArgs>
    ): Prisma__subtitleClient<subtitleGetPayload<T>>

    /**
     * Delete a Subtitle.
     * @param {subtitleDeleteArgs} args - Arguments to delete one Subtitle.
     * @example
     * // Delete one Subtitle
     * const Subtitle = await prisma.subtitle.delete({
     *   where: {
     *     // ... filter to delete one Subtitle
     *   }
     * })
     * 
    **/
    delete<T extends subtitleDeleteArgs>(
      args: SelectSubset<T, subtitleDeleteArgs>
    ): Prisma__subtitleClient<subtitleGetPayload<T>>

    /**
     * Update one Subtitle.
     * @param {subtitleUpdateArgs} args - Arguments to update one Subtitle.
     * @example
     * // Update one Subtitle
     * const subtitle = await prisma.subtitle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends subtitleUpdateArgs>(
      args: SelectSubset<T, subtitleUpdateArgs>
    ): Prisma__subtitleClient<subtitleGetPayload<T>>

    /**
     * Delete zero or more Subtitles.
     * @param {subtitleDeleteManyArgs} args - Arguments to filter Subtitles to delete.
     * @example
     * // Delete a few Subtitles
     * const { count } = await prisma.subtitle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends subtitleDeleteManyArgs>(
      args?: SelectSubset<T, subtitleDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Subtitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtitleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Subtitles
     * const subtitle = await prisma.subtitle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends subtitleUpdateManyArgs>(
      args: SelectSubset<T, subtitleUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Subtitle.
     * @param {subtitleUpsertArgs} args - Arguments to update or create a Subtitle.
     * @example
     * // Update or create a Subtitle
     * const subtitle = await prisma.subtitle.upsert({
     *   create: {
     *     // ... data to create a Subtitle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Subtitle we want to update
     *   }
     * })
    **/
    upsert<T extends subtitleUpsertArgs>(
      args: SelectSubset<T, subtitleUpsertArgs>
    ): Prisma__subtitleClient<subtitleGetPayload<T>>

    /**
     * Count the number of Subtitles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {subtitleCountArgs} args - Arguments to filter Subtitles to count.
     * @example
     * // Count the number of Subtitles
     * const count = await prisma.subtitle.count({
     *   where: {
     *     // ... the filter for the Subtitles we want to count
     *   }
     * })
    **/
    count<T extends subtitleCountArgs>(
      args?: Subset<T, subtitleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubtitleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Subtitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubtitleAggregateArgs>(args: Subset<T, SubtitleAggregateArgs>): Prisma.PrismaPromise<GetSubtitleAggregateType<T>>

    /**
     * Group by Subtitle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubtitleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubtitleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubtitleGroupByArgs['orderBy'] }
        : { orderBy?: SubtitleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubtitleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubtitleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for subtitle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__subtitleClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    movie<T extends movieArgs= {}>(args?: Subset<T, movieArgs>): Prisma__movieClient<movieGetPayload<T> | Null>;

    episode<T extends episodeArgs= {}>(args?: Subset<T, episodeArgs>): Prisma__episodeClient<episodeGetPayload<T> | Null>;

    drive<T extends driveArgs= {}>(args?: Subset<T, driveArgs>): Prisma__driveClient<driveGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * subtitle base type for findUnique actions
   */
  export type subtitleFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    /**
     * Filter, which subtitle to fetch.
     */
    where: subtitleWhereUniqueInput
  }

  /**
   * subtitle findUnique
   */
  export interface subtitleFindUniqueArgs extends subtitleFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subtitle findUniqueOrThrow
   */
  export type subtitleFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    /**
     * Filter, which subtitle to fetch.
     */
    where: subtitleWhereUniqueInput
  }


  /**
   * subtitle base type for findFirst actions
   */
  export type subtitleFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    /**
     * Filter, which subtitle to fetch.
     */
    where?: subtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subtitles to fetch.
     */
    orderBy?: Enumerable<subtitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subtitles.
     */
    cursor?: subtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subtitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subtitles.
     */
    distinct?: Enumerable<SubtitleScalarFieldEnum>
  }

  /**
   * subtitle findFirst
   */
  export interface subtitleFindFirstArgs extends subtitleFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * subtitle findFirstOrThrow
   */
  export type subtitleFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    /**
     * Filter, which subtitle to fetch.
     */
    where?: subtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subtitles to fetch.
     */
    orderBy?: Enumerable<subtitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for subtitles.
     */
    cursor?: subtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subtitles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of subtitles.
     */
    distinct?: Enumerable<SubtitleScalarFieldEnum>
  }


  /**
   * subtitle findMany
   */
  export type subtitleFindManyArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    /**
     * Filter, which subtitles to fetch.
     */
    where?: subtitleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of subtitles to fetch.
     */
    orderBy?: Enumerable<subtitleOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing subtitles.
     */
    cursor?: subtitleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` subtitles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` subtitles.
     */
    skip?: number
    distinct?: Enumerable<SubtitleScalarFieldEnum>
  }


  /**
   * subtitle create
   */
  export type subtitleCreateArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    /**
     * The data needed to create a subtitle.
     */
    data: XOR<subtitleCreateInput, subtitleUncheckedCreateInput>
  }


  /**
   * subtitle update
   */
  export type subtitleUpdateArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    /**
     * The data needed to update a subtitle.
     */
    data: XOR<subtitleUpdateInput, subtitleUncheckedUpdateInput>
    /**
     * Choose, which subtitle to update.
     */
    where: subtitleWhereUniqueInput
  }


  /**
   * subtitle updateMany
   */
  export type subtitleUpdateManyArgs = {
    /**
     * The data used to update subtitles.
     */
    data: XOR<subtitleUpdateManyMutationInput, subtitleUncheckedUpdateManyInput>
    /**
     * Filter which subtitles to update
     */
    where?: subtitleWhereInput
  }


  /**
   * subtitle upsert
   */
  export type subtitleUpsertArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    /**
     * The filter to search for the subtitle to update in case it exists.
     */
    where: subtitleWhereUniqueInput
    /**
     * In case the subtitle found by the `where` argument doesn't exist, create a new subtitle with this data.
     */
    create: XOR<subtitleCreateInput, subtitleUncheckedCreateInput>
    /**
     * In case the subtitle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<subtitleUpdateInput, subtitleUncheckedUpdateInput>
  }


  /**
   * subtitle delete
   */
  export type subtitleDeleteArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    /**
     * Filter which subtitle to delete.
     */
    where: subtitleWhereUniqueInput
  }


  /**
   * subtitle deleteMany
   */
  export type subtitleDeleteManyArgs = {
    /**
     * Filter which subtitles to delete
     */
    where?: subtitleWhereInput
  }


  /**
   * subtitle without action
   */
  export type subtitleArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
  }



  /**
   * Model parsed_tv
   */


  export type AggregateParsed_tv = {
    _count: Parsed_tvCountAggregateOutputType | null
    _avg: Parsed_tvAvgAggregateOutputType | null
    _sum: Parsed_tvSumAggregateOutputType | null
    _min: Parsed_tvMinAggregateOutputType | null
    _max: Parsed_tvMaxAggregateOutputType | null
  }

  export type Parsed_tvAvgAggregateOutputType = {
    can_search: number | null
    tmdb_id: number | null
  }

  export type Parsed_tvSumAggregateOutputType = {
    can_search: number | null
    tmdb_id: number | null
  }

  export type Parsed_tvMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    name: string | null
    original_name: string | null
    file_id: string | null
    file_name: string | null
    can_search: number | null
    correct_name: string | null
    tmdb_id: number | null
    tv_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Parsed_tvMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    name: string | null
    original_name: string | null
    file_id: string | null
    file_name: string | null
    can_search: number | null
    correct_name: string | null
    tmdb_id: number | null
    tv_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Parsed_tvCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    name: number
    original_name: number
    file_id: number
    file_name: number
    can_search: number
    correct_name: number
    tmdb_id: number
    tv_id: number
    drive_id: number
    user_id: number
    _all: number
  }


  export type Parsed_tvAvgAggregateInputType = {
    can_search?: true
    tmdb_id?: true
  }

  export type Parsed_tvSumAggregateInputType = {
    can_search?: true
    tmdb_id?: true
  }

  export type Parsed_tvMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    original_name?: true
    file_id?: true
    file_name?: true
    can_search?: true
    correct_name?: true
    tmdb_id?: true
    tv_id?: true
    drive_id?: true
    user_id?: true
  }

  export type Parsed_tvMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    original_name?: true
    file_id?: true
    file_name?: true
    can_search?: true
    correct_name?: true
    tmdb_id?: true
    tv_id?: true
    drive_id?: true
    user_id?: true
  }

  export type Parsed_tvCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    original_name?: true
    file_id?: true
    file_name?: true
    can_search?: true
    correct_name?: true
    tmdb_id?: true
    tv_id?: true
    drive_id?: true
    user_id?: true
    _all?: true
  }

  export type Parsed_tvAggregateArgs = {
    /**
     * Filter which parsed_tv to aggregate.
     */
    where?: parsed_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_tvs to fetch.
     */
    orderBy?: Enumerable<parsed_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parsed_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parsed_tvs
    **/
    _count?: true | Parsed_tvCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Parsed_tvAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Parsed_tvSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Parsed_tvMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Parsed_tvMaxAggregateInputType
  }

  export type GetParsed_tvAggregateType<T extends Parsed_tvAggregateArgs> = {
        [P in keyof T & keyof AggregateParsed_tv]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsed_tv[P]>
      : GetScalarType<T[P], AggregateParsed_tv[P]>
  }




  export type Parsed_tvGroupByArgs = {
    where?: parsed_tvWhereInput
    orderBy?: Enumerable<parsed_tvOrderByWithAggregationInput>
    by: Parsed_tvScalarFieldEnum[]
    having?: parsed_tvScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Parsed_tvCountAggregateInputType | true
    _avg?: Parsed_tvAvgAggregateInputType
    _sum?: Parsed_tvSumAggregateInputType
    _min?: Parsed_tvMinAggregateInputType
    _max?: Parsed_tvMaxAggregateInputType
  }


  export type Parsed_tvGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    name: string | null
    original_name: string | null
    file_id: string | null
    file_name: string | null
    can_search: number | null
    correct_name: string | null
    tmdb_id: number | null
    tv_id: string | null
    drive_id: string
    user_id: string
    _count: Parsed_tvCountAggregateOutputType | null
    _avg: Parsed_tvAvgAggregateOutputType | null
    _sum: Parsed_tvSumAggregateOutputType | null
    _min: Parsed_tvMinAggregateOutputType | null
    _max: Parsed_tvMaxAggregateOutputType | null
  }

  type GetParsed_tvGroupByPayload<T extends Parsed_tvGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Parsed_tvGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Parsed_tvGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Parsed_tvGroupByOutputType[P]>
            : GetScalarType<T[P], Parsed_tvGroupByOutputType[P]>
        }
      >
    >


  export type parsed_tvSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    name?: boolean
    original_name?: boolean
    file_id?: boolean
    file_name?: boolean
    can_search?: boolean
    correct_name?: boolean
    tmdb_id?: boolean
    tv_id?: boolean
    drive_id?: boolean
    user_id?: boolean
    tv?: boolean | tvArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
    parsed_episodes?: boolean | parsed_tv$parsed_episodesArgs
    parsed_seasons?: boolean | parsed_tv$parsed_seasonsArgs
    _count?: boolean | Parsed_tvCountOutputTypeArgs
  }


  export type parsed_tvInclude = {
    tv?: boolean | tvArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
    parsed_episodes?: boolean | parsed_tv$parsed_episodesArgs
    parsed_seasons?: boolean | parsed_tv$parsed_seasonsArgs
    _count?: boolean | Parsed_tvCountOutputTypeArgs
  }

  export type parsed_tvGetPayload<S extends boolean | null | undefined | parsed_tvArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? parsed_tv :
    S extends undefined ? never :
    S extends { include: any } & (parsed_tvArgs | parsed_tvFindManyArgs)
    ? parsed_tv  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tv' ? tvGetPayload<S['include'][P]> | null :
        P extends 'drive' ? driveGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends 'parsed_episodes' ? Array < parsed_episodeGetPayload<S['include'][P]>>  :
        P extends 'parsed_seasons' ? Array < parsed_seasonGetPayload<S['include'][P]>>  :
        P extends '_count' ? Parsed_tvCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (parsed_tvArgs | parsed_tvFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tv' ? tvGetPayload<S['select'][P]> | null :
        P extends 'drive' ? driveGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends 'parsed_episodes' ? Array < parsed_episodeGetPayload<S['select'][P]>>  :
        P extends 'parsed_seasons' ? Array < parsed_seasonGetPayload<S['select'][P]>>  :
        P extends '_count' ? Parsed_tvCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof parsed_tv ? parsed_tv[P] : never
  } 
      : parsed_tv


  type parsed_tvCountArgs = 
    Omit<parsed_tvFindManyArgs, 'select' | 'include'> & {
      select?: Parsed_tvCountAggregateInputType | true
    }

  export interface parsed_tvDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Parsed_tv that matches the filter.
     * @param {parsed_tvFindUniqueArgs} args - Arguments to find a Parsed_tv
     * @example
     * // Get one Parsed_tv
     * const parsed_tv = await prisma.parsed_tv.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends parsed_tvFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, parsed_tvFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'parsed_tv'> extends True ? Prisma__parsed_tvClient<parsed_tvGetPayload<T>> : Prisma__parsed_tvClient<parsed_tvGetPayload<T> | null, null>

    /**
     * Find one Parsed_tv that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {parsed_tvFindUniqueOrThrowArgs} args - Arguments to find a Parsed_tv
     * @example
     * // Get one Parsed_tv
     * const parsed_tv = await prisma.parsed_tv.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends parsed_tvFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, parsed_tvFindUniqueOrThrowArgs>
    ): Prisma__parsed_tvClient<parsed_tvGetPayload<T>>

    /**
     * Find the first Parsed_tv that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_tvFindFirstArgs} args - Arguments to find a Parsed_tv
     * @example
     * // Get one Parsed_tv
     * const parsed_tv = await prisma.parsed_tv.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends parsed_tvFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, parsed_tvFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'parsed_tv'> extends True ? Prisma__parsed_tvClient<parsed_tvGetPayload<T>> : Prisma__parsed_tvClient<parsed_tvGetPayload<T> | null, null>

    /**
     * Find the first Parsed_tv that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_tvFindFirstOrThrowArgs} args - Arguments to find a Parsed_tv
     * @example
     * // Get one Parsed_tv
     * const parsed_tv = await prisma.parsed_tv.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends parsed_tvFindFirstOrThrowArgs>(
      args?: SelectSubset<T, parsed_tvFindFirstOrThrowArgs>
    ): Prisma__parsed_tvClient<parsed_tvGetPayload<T>>

    /**
     * Find zero or more Parsed_tvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_tvFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parsed_tvs
     * const parsed_tvs = await prisma.parsed_tv.findMany()
     * 
     * // Get first 10 Parsed_tvs
     * const parsed_tvs = await prisma.parsed_tv.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsed_tvWithIdOnly = await prisma.parsed_tv.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends parsed_tvFindManyArgs>(
      args?: SelectSubset<T, parsed_tvFindManyArgs>
    ): Prisma.PrismaPromise<Array<parsed_tvGetPayload<T>>>

    /**
     * Create a Parsed_tv.
     * @param {parsed_tvCreateArgs} args - Arguments to create a Parsed_tv.
     * @example
     * // Create one Parsed_tv
     * const Parsed_tv = await prisma.parsed_tv.create({
     *   data: {
     *     // ... data to create a Parsed_tv
     *   }
     * })
     * 
    **/
    create<T extends parsed_tvCreateArgs>(
      args: SelectSubset<T, parsed_tvCreateArgs>
    ): Prisma__parsed_tvClient<parsed_tvGetPayload<T>>

    /**
     * Delete a Parsed_tv.
     * @param {parsed_tvDeleteArgs} args - Arguments to delete one Parsed_tv.
     * @example
     * // Delete one Parsed_tv
     * const Parsed_tv = await prisma.parsed_tv.delete({
     *   where: {
     *     // ... filter to delete one Parsed_tv
     *   }
     * })
     * 
    **/
    delete<T extends parsed_tvDeleteArgs>(
      args: SelectSubset<T, parsed_tvDeleteArgs>
    ): Prisma__parsed_tvClient<parsed_tvGetPayload<T>>

    /**
     * Update one Parsed_tv.
     * @param {parsed_tvUpdateArgs} args - Arguments to update one Parsed_tv.
     * @example
     * // Update one Parsed_tv
     * const parsed_tv = await prisma.parsed_tv.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends parsed_tvUpdateArgs>(
      args: SelectSubset<T, parsed_tvUpdateArgs>
    ): Prisma__parsed_tvClient<parsed_tvGetPayload<T>>

    /**
     * Delete zero or more Parsed_tvs.
     * @param {parsed_tvDeleteManyArgs} args - Arguments to filter Parsed_tvs to delete.
     * @example
     * // Delete a few Parsed_tvs
     * const { count } = await prisma.parsed_tv.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends parsed_tvDeleteManyArgs>(
      args?: SelectSubset<T, parsed_tvDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parsed_tvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_tvUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parsed_tvs
     * const parsed_tv = await prisma.parsed_tv.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends parsed_tvUpdateManyArgs>(
      args: SelectSubset<T, parsed_tvUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parsed_tv.
     * @param {parsed_tvUpsertArgs} args - Arguments to update or create a Parsed_tv.
     * @example
     * // Update or create a Parsed_tv
     * const parsed_tv = await prisma.parsed_tv.upsert({
     *   create: {
     *     // ... data to create a Parsed_tv
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parsed_tv we want to update
     *   }
     * })
    **/
    upsert<T extends parsed_tvUpsertArgs>(
      args: SelectSubset<T, parsed_tvUpsertArgs>
    ): Prisma__parsed_tvClient<parsed_tvGetPayload<T>>

    /**
     * Count the number of Parsed_tvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_tvCountArgs} args - Arguments to filter Parsed_tvs to count.
     * @example
     * // Count the number of Parsed_tvs
     * const count = await prisma.parsed_tv.count({
     *   where: {
     *     // ... the filter for the Parsed_tvs we want to count
     *   }
     * })
    **/
    count<T extends parsed_tvCountArgs>(
      args?: Subset<T, parsed_tvCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Parsed_tvCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parsed_tv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parsed_tvAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Parsed_tvAggregateArgs>(args: Subset<T, Parsed_tvAggregateArgs>): Prisma.PrismaPromise<GetParsed_tvAggregateType<T>>

    /**
     * Group by Parsed_tv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parsed_tvGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Parsed_tvGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Parsed_tvGroupByArgs['orderBy'] }
        : { orderBy?: Parsed_tvGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Parsed_tvGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsed_tvGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for parsed_tv.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__parsed_tvClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tv<T extends tvArgs= {}>(args?: Subset<T, tvArgs>): Prisma__tvClient<tvGetPayload<T> | Null>;

    drive<T extends driveArgs= {}>(args?: Subset<T, driveArgs>): Prisma__driveClient<driveGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    parsed_episodes<T extends parsed_tv$parsed_episodesArgs= {}>(args?: Subset<T, parsed_tv$parsed_episodesArgs>): Prisma.PrismaPromise<Array<parsed_episodeGetPayload<T>>| Null>;

    parsed_seasons<T extends parsed_tv$parsed_seasonsArgs= {}>(args?: Subset<T, parsed_tv$parsed_seasonsArgs>): Prisma.PrismaPromise<Array<parsed_seasonGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * parsed_tv base type for findUnique actions
   */
  export type parsed_tvFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    /**
     * Filter, which parsed_tv to fetch.
     */
    where: parsed_tvWhereUniqueInput
  }

  /**
   * parsed_tv findUnique
   */
  export interface parsed_tvFindUniqueArgs extends parsed_tvFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parsed_tv findUniqueOrThrow
   */
  export type parsed_tvFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    /**
     * Filter, which parsed_tv to fetch.
     */
    where: parsed_tvWhereUniqueInput
  }


  /**
   * parsed_tv base type for findFirst actions
   */
  export type parsed_tvFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    /**
     * Filter, which parsed_tv to fetch.
     */
    where?: parsed_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_tvs to fetch.
     */
    orderBy?: Enumerable<parsed_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parsed_tvs.
     */
    cursor?: parsed_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parsed_tvs.
     */
    distinct?: Enumerable<Parsed_tvScalarFieldEnum>
  }

  /**
   * parsed_tv findFirst
   */
  export interface parsed_tvFindFirstArgs extends parsed_tvFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parsed_tv findFirstOrThrow
   */
  export type parsed_tvFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    /**
     * Filter, which parsed_tv to fetch.
     */
    where?: parsed_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_tvs to fetch.
     */
    orderBy?: Enumerable<parsed_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parsed_tvs.
     */
    cursor?: parsed_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parsed_tvs.
     */
    distinct?: Enumerable<Parsed_tvScalarFieldEnum>
  }


  /**
   * parsed_tv findMany
   */
  export type parsed_tvFindManyArgs = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    /**
     * Filter, which parsed_tvs to fetch.
     */
    where?: parsed_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_tvs to fetch.
     */
    orderBy?: Enumerable<parsed_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parsed_tvs.
     */
    cursor?: parsed_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_tvs.
     */
    skip?: number
    distinct?: Enumerable<Parsed_tvScalarFieldEnum>
  }


  /**
   * parsed_tv create
   */
  export type parsed_tvCreateArgs = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    /**
     * The data needed to create a parsed_tv.
     */
    data: XOR<parsed_tvCreateInput, parsed_tvUncheckedCreateInput>
  }


  /**
   * parsed_tv update
   */
  export type parsed_tvUpdateArgs = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    /**
     * The data needed to update a parsed_tv.
     */
    data: XOR<parsed_tvUpdateInput, parsed_tvUncheckedUpdateInput>
    /**
     * Choose, which parsed_tv to update.
     */
    where: parsed_tvWhereUniqueInput
  }


  /**
   * parsed_tv updateMany
   */
  export type parsed_tvUpdateManyArgs = {
    /**
     * The data used to update parsed_tvs.
     */
    data: XOR<parsed_tvUpdateManyMutationInput, parsed_tvUncheckedUpdateManyInput>
    /**
     * Filter which parsed_tvs to update
     */
    where?: parsed_tvWhereInput
  }


  /**
   * parsed_tv upsert
   */
  export type parsed_tvUpsertArgs = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    /**
     * The filter to search for the parsed_tv to update in case it exists.
     */
    where: parsed_tvWhereUniqueInput
    /**
     * In case the parsed_tv found by the `where` argument doesn't exist, create a new parsed_tv with this data.
     */
    create: XOR<parsed_tvCreateInput, parsed_tvUncheckedCreateInput>
    /**
     * In case the parsed_tv was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parsed_tvUpdateInput, parsed_tvUncheckedUpdateInput>
  }


  /**
   * parsed_tv delete
   */
  export type parsed_tvDeleteArgs = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    /**
     * Filter which parsed_tv to delete.
     */
    where: parsed_tvWhereUniqueInput
  }


  /**
   * parsed_tv deleteMany
   */
  export type parsed_tvDeleteManyArgs = {
    /**
     * Filter which parsed_tvs to delete
     */
    where?: parsed_tvWhereInput
  }


  /**
   * parsed_tv.parsed_episodes
   */
  export type parsed_tv$parsed_episodesArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    where?: parsed_episodeWhereInput
    orderBy?: Enumerable<parsed_episodeOrderByWithRelationInput>
    cursor?: parsed_episodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_episodeScalarFieldEnum>
  }


  /**
   * parsed_tv.parsed_seasons
   */
  export type parsed_tv$parsed_seasonsArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    where?: parsed_seasonWhereInput
    orderBy?: Enumerable<parsed_seasonOrderByWithRelationInput>
    cursor?: parsed_seasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_seasonScalarFieldEnum>
  }


  /**
   * parsed_tv without action
   */
  export type parsed_tvArgs = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
  }



  /**
   * Model parsed_season
   */


  export type AggregateParsed_season = {
    _count: Parsed_seasonCountAggregateOutputType | null
    _avg: Parsed_seasonAvgAggregateOutputType | null
    _sum: Parsed_seasonSumAggregateOutputType | null
    _min: Parsed_seasonMinAggregateOutputType | null
    _max: Parsed_seasonMaxAggregateOutputType | null
  }

  export type Parsed_seasonAvgAggregateOutputType = {
    can_search: number | null
  }

  export type Parsed_seasonSumAggregateOutputType = {
    can_search: number | null
  }

  export type Parsed_seasonMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    season_number: string | null
    file_id: string | null
    file_name: string | null
    can_search: number | null
    correct_season_number: string | null
    season_id: string | null
    parsed_tv_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Parsed_seasonMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    season_number: string | null
    file_id: string | null
    file_name: string | null
    can_search: number | null
    correct_season_number: string | null
    season_id: string | null
    parsed_tv_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Parsed_seasonCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    season_number: number
    file_id: number
    file_name: number
    can_search: number
    correct_season_number: number
    season_id: number
    parsed_tv_id: number
    drive_id: number
    user_id: number
    _all: number
  }


  export type Parsed_seasonAvgAggregateInputType = {
    can_search?: true
  }

  export type Parsed_seasonSumAggregateInputType = {
    can_search?: true
  }

  export type Parsed_seasonMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    season_number?: true
    file_id?: true
    file_name?: true
    can_search?: true
    correct_season_number?: true
    season_id?: true
    parsed_tv_id?: true
    drive_id?: true
    user_id?: true
  }

  export type Parsed_seasonMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    season_number?: true
    file_id?: true
    file_name?: true
    can_search?: true
    correct_season_number?: true
    season_id?: true
    parsed_tv_id?: true
    drive_id?: true
    user_id?: true
  }

  export type Parsed_seasonCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    season_number?: true
    file_id?: true
    file_name?: true
    can_search?: true
    correct_season_number?: true
    season_id?: true
    parsed_tv_id?: true
    drive_id?: true
    user_id?: true
    _all?: true
  }

  export type Parsed_seasonAggregateArgs = {
    /**
     * Filter which parsed_season to aggregate.
     */
    where?: parsed_seasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_seasons to fetch.
     */
    orderBy?: Enumerable<parsed_seasonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parsed_seasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parsed_seasons
    **/
    _count?: true | Parsed_seasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Parsed_seasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Parsed_seasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Parsed_seasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Parsed_seasonMaxAggregateInputType
  }

  export type GetParsed_seasonAggregateType<T extends Parsed_seasonAggregateArgs> = {
        [P in keyof T & keyof AggregateParsed_season]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsed_season[P]>
      : GetScalarType<T[P], AggregateParsed_season[P]>
  }




  export type Parsed_seasonGroupByArgs = {
    where?: parsed_seasonWhereInput
    orderBy?: Enumerable<parsed_seasonOrderByWithAggregationInput>
    by: Parsed_seasonScalarFieldEnum[]
    having?: parsed_seasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Parsed_seasonCountAggregateInputType | true
    _avg?: Parsed_seasonAvgAggregateInputType
    _sum?: Parsed_seasonSumAggregateInputType
    _min?: Parsed_seasonMinAggregateInputType
    _max?: Parsed_seasonMaxAggregateInputType
  }


  export type Parsed_seasonGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    season_number: string
    file_id: string | null
    file_name: string | null
    can_search: number | null
    correct_season_number: string | null
    season_id: string | null
    parsed_tv_id: string
    drive_id: string
    user_id: string
    _count: Parsed_seasonCountAggregateOutputType | null
    _avg: Parsed_seasonAvgAggregateOutputType | null
    _sum: Parsed_seasonSumAggregateOutputType | null
    _min: Parsed_seasonMinAggregateOutputType | null
    _max: Parsed_seasonMaxAggregateOutputType | null
  }

  type GetParsed_seasonGroupByPayload<T extends Parsed_seasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Parsed_seasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Parsed_seasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Parsed_seasonGroupByOutputType[P]>
            : GetScalarType<T[P], Parsed_seasonGroupByOutputType[P]>
        }
      >
    >


  export type parsed_seasonSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    season_number?: boolean
    file_id?: boolean
    file_name?: boolean
    can_search?: boolean
    correct_season_number?: boolean
    season_id?: boolean
    parsed_tv_id?: boolean
    drive_id?: boolean
    user_id?: boolean
    season?: boolean | seasonArgs
    parsed_tv?: boolean | parsed_tvArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
    parsed_episodes?: boolean | parsed_season$parsed_episodesArgs
    _count?: boolean | Parsed_seasonCountOutputTypeArgs
  }


  export type parsed_seasonInclude = {
    season?: boolean | seasonArgs
    parsed_tv?: boolean | parsed_tvArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
    parsed_episodes?: boolean | parsed_season$parsed_episodesArgs
    _count?: boolean | Parsed_seasonCountOutputTypeArgs
  }

  export type parsed_seasonGetPayload<S extends boolean | null | undefined | parsed_seasonArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? parsed_season :
    S extends undefined ? never :
    S extends { include: any } & (parsed_seasonArgs | parsed_seasonFindManyArgs)
    ? parsed_season  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'season' ? seasonGetPayload<S['include'][P]> | null :
        P extends 'parsed_tv' ? parsed_tvGetPayload<S['include'][P]> :
        P extends 'drive' ? driveGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends 'parsed_episodes' ? Array < parsed_episodeGetPayload<S['include'][P]>>  :
        P extends '_count' ? Parsed_seasonCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (parsed_seasonArgs | parsed_seasonFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'season' ? seasonGetPayload<S['select'][P]> | null :
        P extends 'parsed_tv' ? parsed_tvGetPayload<S['select'][P]> :
        P extends 'drive' ? driveGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends 'parsed_episodes' ? Array < parsed_episodeGetPayload<S['select'][P]>>  :
        P extends '_count' ? Parsed_seasonCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof parsed_season ? parsed_season[P] : never
  } 
      : parsed_season


  type parsed_seasonCountArgs = 
    Omit<parsed_seasonFindManyArgs, 'select' | 'include'> & {
      select?: Parsed_seasonCountAggregateInputType | true
    }

  export interface parsed_seasonDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Parsed_season that matches the filter.
     * @param {parsed_seasonFindUniqueArgs} args - Arguments to find a Parsed_season
     * @example
     * // Get one Parsed_season
     * const parsed_season = await prisma.parsed_season.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends parsed_seasonFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, parsed_seasonFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'parsed_season'> extends True ? Prisma__parsed_seasonClient<parsed_seasonGetPayload<T>> : Prisma__parsed_seasonClient<parsed_seasonGetPayload<T> | null, null>

    /**
     * Find one Parsed_season that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {parsed_seasonFindUniqueOrThrowArgs} args - Arguments to find a Parsed_season
     * @example
     * // Get one Parsed_season
     * const parsed_season = await prisma.parsed_season.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends parsed_seasonFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, parsed_seasonFindUniqueOrThrowArgs>
    ): Prisma__parsed_seasonClient<parsed_seasonGetPayload<T>>

    /**
     * Find the first Parsed_season that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_seasonFindFirstArgs} args - Arguments to find a Parsed_season
     * @example
     * // Get one Parsed_season
     * const parsed_season = await prisma.parsed_season.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends parsed_seasonFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, parsed_seasonFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'parsed_season'> extends True ? Prisma__parsed_seasonClient<parsed_seasonGetPayload<T>> : Prisma__parsed_seasonClient<parsed_seasonGetPayload<T> | null, null>

    /**
     * Find the first Parsed_season that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_seasonFindFirstOrThrowArgs} args - Arguments to find a Parsed_season
     * @example
     * // Get one Parsed_season
     * const parsed_season = await prisma.parsed_season.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends parsed_seasonFindFirstOrThrowArgs>(
      args?: SelectSubset<T, parsed_seasonFindFirstOrThrowArgs>
    ): Prisma__parsed_seasonClient<parsed_seasonGetPayload<T>>

    /**
     * Find zero or more Parsed_seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_seasonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parsed_seasons
     * const parsed_seasons = await prisma.parsed_season.findMany()
     * 
     * // Get first 10 Parsed_seasons
     * const parsed_seasons = await prisma.parsed_season.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsed_seasonWithIdOnly = await prisma.parsed_season.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends parsed_seasonFindManyArgs>(
      args?: SelectSubset<T, parsed_seasonFindManyArgs>
    ): Prisma.PrismaPromise<Array<parsed_seasonGetPayload<T>>>

    /**
     * Create a Parsed_season.
     * @param {parsed_seasonCreateArgs} args - Arguments to create a Parsed_season.
     * @example
     * // Create one Parsed_season
     * const Parsed_season = await prisma.parsed_season.create({
     *   data: {
     *     // ... data to create a Parsed_season
     *   }
     * })
     * 
    **/
    create<T extends parsed_seasonCreateArgs>(
      args: SelectSubset<T, parsed_seasonCreateArgs>
    ): Prisma__parsed_seasonClient<parsed_seasonGetPayload<T>>

    /**
     * Delete a Parsed_season.
     * @param {parsed_seasonDeleteArgs} args - Arguments to delete one Parsed_season.
     * @example
     * // Delete one Parsed_season
     * const Parsed_season = await prisma.parsed_season.delete({
     *   where: {
     *     // ... filter to delete one Parsed_season
     *   }
     * })
     * 
    **/
    delete<T extends parsed_seasonDeleteArgs>(
      args: SelectSubset<T, parsed_seasonDeleteArgs>
    ): Prisma__parsed_seasonClient<parsed_seasonGetPayload<T>>

    /**
     * Update one Parsed_season.
     * @param {parsed_seasonUpdateArgs} args - Arguments to update one Parsed_season.
     * @example
     * // Update one Parsed_season
     * const parsed_season = await prisma.parsed_season.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends parsed_seasonUpdateArgs>(
      args: SelectSubset<T, parsed_seasonUpdateArgs>
    ): Prisma__parsed_seasonClient<parsed_seasonGetPayload<T>>

    /**
     * Delete zero or more Parsed_seasons.
     * @param {parsed_seasonDeleteManyArgs} args - Arguments to filter Parsed_seasons to delete.
     * @example
     * // Delete a few Parsed_seasons
     * const { count } = await prisma.parsed_season.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends parsed_seasonDeleteManyArgs>(
      args?: SelectSubset<T, parsed_seasonDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parsed_seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_seasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parsed_seasons
     * const parsed_season = await prisma.parsed_season.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends parsed_seasonUpdateManyArgs>(
      args: SelectSubset<T, parsed_seasonUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parsed_season.
     * @param {parsed_seasonUpsertArgs} args - Arguments to update or create a Parsed_season.
     * @example
     * // Update or create a Parsed_season
     * const parsed_season = await prisma.parsed_season.upsert({
     *   create: {
     *     // ... data to create a Parsed_season
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parsed_season we want to update
     *   }
     * })
    **/
    upsert<T extends parsed_seasonUpsertArgs>(
      args: SelectSubset<T, parsed_seasonUpsertArgs>
    ): Prisma__parsed_seasonClient<parsed_seasonGetPayload<T>>

    /**
     * Count the number of Parsed_seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_seasonCountArgs} args - Arguments to filter Parsed_seasons to count.
     * @example
     * // Count the number of Parsed_seasons
     * const count = await prisma.parsed_season.count({
     *   where: {
     *     // ... the filter for the Parsed_seasons we want to count
     *   }
     * })
    **/
    count<T extends parsed_seasonCountArgs>(
      args?: Subset<T, parsed_seasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Parsed_seasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parsed_season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parsed_seasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Parsed_seasonAggregateArgs>(args: Subset<T, Parsed_seasonAggregateArgs>): Prisma.PrismaPromise<GetParsed_seasonAggregateType<T>>

    /**
     * Group by Parsed_season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parsed_seasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Parsed_seasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Parsed_seasonGroupByArgs['orderBy'] }
        : { orderBy?: Parsed_seasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Parsed_seasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsed_seasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for parsed_season.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__parsed_seasonClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    season<T extends seasonArgs= {}>(args?: Subset<T, seasonArgs>): Prisma__seasonClient<seasonGetPayload<T> | Null>;

    parsed_tv<T extends parsed_tvArgs= {}>(args?: Subset<T, parsed_tvArgs>): Prisma__parsed_tvClient<parsed_tvGetPayload<T> | Null>;

    drive<T extends driveArgs= {}>(args?: Subset<T, driveArgs>): Prisma__driveClient<driveGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    parsed_episodes<T extends parsed_season$parsed_episodesArgs= {}>(args?: Subset<T, parsed_season$parsed_episodesArgs>): Prisma.PrismaPromise<Array<parsed_episodeGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * parsed_season base type for findUnique actions
   */
  export type parsed_seasonFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    /**
     * Filter, which parsed_season to fetch.
     */
    where: parsed_seasonWhereUniqueInput
  }

  /**
   * parsed_season findUnique
   */
  export interface parsed_seasonFindUniqueArgs extends parsed_seasonFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parsed_season findUniqueOrThrow
   */
  export type parsed_seasonFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    /**
     * Filter, which parsed_season to fetch.
     */
    where: parsed_seasonWhereUniqueInput
  }


  /**
   * parsed_season base type for findFirst actions
   */
  export type parsed_seasonFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    /**
     * Filter, which parsed_season to fetch.
     */
    where?: parsed_seasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_seasons to fetch.
     */
    orderBy?: Enumerable<parsed_seasonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parsed_seasons.
     */
    cursor?: parsed_seasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parsed_seasons.
     */
    distinct?: Enumerable<Parsed_seasonScalarFieldEnum>
  }

  /**
   * parsed_season findFirst
   */
  export interface parsed_seasonFindFirstArgs extends parsed_seasonFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parsed_season findFirstOrThrow
   */
  export type parsed_seasonFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    /**
     * Filter, which parsed_season to fetch.
     */
    where?: parsed_seasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_seasons to fetch.
     */
    orderBy?: Enumerable<parsed_seasonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parsed_seasons.
     */
    cursor?: parsed_seasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parsed_seasons.
     */
    distinct?: Enumerable<Parsed_seasonScalarFieldEnum>
  }


  /**
   * parsed_season findMany
   */
  export type parsed_seasonFindManyArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    /**
     * Filter, which parsed_seasons to fetch.
     */
    where?: parsed_seasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_seasons to fetch.
     */
    orderBy?: Enumerable<parsed_seasonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parsed_seasons.
     */
    cursor?: parsed_seasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_seasons.
     */
    skip?: number
    distinct?: Enumerable<Parsed_seasonScalarFieldEnum>
  }


  /**
   * parsed_season create
   */
  export type parsed_seasonCreateArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    /**
     * The data needed to create a parsed_season.
     */
    data: XOR<parsed_seasonCreateInput, parsed_seasonUncheckedCreateInput>
  }


  /**
   * parsed_season update
   */
  export type parsed_seasonUpdateArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    /**
     * The data needed to update a parsed_season.
     */
    data: XOR<parsed_seasonUpdateInput, parsed_seasonUncheckedUpdateInput>
    /**
     * Choose, which parsed_season to update.
     */
    where: parsed_seasonWhereUniqueInput
  }


  /**
   * parsed_season updateMany
   */
  export type parsed_seasonUpdateManyArgs = {
    /**
     * The data used to update parsed_seasons.
     */
    data: XOR<parsed_seasonUpdateManyMutationInput, parsed_seasonUncheckedUpdateManyInput>
    /**
     * Filter which parsed_seasons to update
     */
    where?: parsed_seasonWhereInput
  }


  /**
   * parsed_season upsert
   */
  export type parsed_seasonUpsertArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    /**
     * The filter to search for the parsed_season to update in case it exists.
     */
    where: parsed_seasonWhereUniqueInput
    /**
     * In case the parsed_season found by the `where` argument doesn't exist, create a new parsed_season with this data.
     */
    create: XOR<parsed_seasonCreateInput, parsed_seasonUncheckedCreateInput>
    /**
     * In case the parsed_season was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parsed_seasonUpdateInput, parsed_seasonUncheckedUpdateInput>
  }


  /**
   * parsed_season delete
   */
  export type parsed_seasonDeleteArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    /**
     * Filter which parsed_season to delete.
     */
    where: parsed_seasonWhereUniqueInput
  }


  /**
   * parsed_season deleteMany
   */
  export type parsed_seasonDeleteManyArgs = {
    /**
     * Filter which parsed_seasons to delete
     */
    where?: parsed_seasonWhereInput
  }


  /**
   * parsed_season.parsed_episodes
   */
  export type parsed_season$parsed_episodesArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    where?: parsed_episodeWhereInput
    orderBy?: Enumerable<parsed_episodeOrderByWithRelationInput>
    cursor?: parsed_episodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_episodeScalarFieldEnum>
  }


  /**
   * parsed_season without action
   */
  export type parsed_seasonArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
  }



  /**
   * Model parsed_episode
   */


  export type AggregateParsed_episode = {
    _count: Parsed_episodeCountAggregateOutputType | null
    _avg: Parsed_episodeAvgAggregateOutputType | null
    _sum: Parsed_episodeSumAggregateOutputType | null
    _min: Parsed_episodeMinAggregateOutputType | null
    _max: Parsed_episodeMaxAggregateOutputType | null
  }

  export type Parsed_episodeAvgAggregateOutputType = {
    type: number | null
    size: number | null
    can_search: number | null
  }

  export type Parsed_episodeSumAggregateOutputType = {
    type: number | null
    size: number | null
    can_search: number | null
  }

  export type Parsed_episodeMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    episode_number: string | null
    season_number: string | null
    name: string | null
    file_id: string | null
    file_name: string | null
    parent_file_id: string | null
    parent_paths: string | null
    type: number | null
    size: number | null
    can_search: number | null
    episode_id: string | null
    parsed_tv_id: string | null
    parsed_season_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Parsed_episodeMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    episode_number: string | null
    season_number: string | null
    name: string | null
    file_id: string | null
    file_name: string | null
    parent_file_id: string | null
    parent_paths: string | null
    type: number | null
    size: number | null
    can_search: number | null
    episode_id: string | null
    parsed_tv_id: string | null
    parsed_season_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Parsed_episodeCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    episode_number: number
    season_number: number
    name: number
    file_id: number
    file_name: number
    parent_file_id: number
    parent_paths: number
    type: number
    size: number
    can_search: number
    episode_id: number
    parsed_tv_id: number
    parsed_season_id: number
    drive_id: number
    user_id: number
    _all: number
  }


  export type Parsed_episodeAvgAggregateInputType = {
    type?: true
    size?: true
    can_search?: true
  }

  export type Parsed_episodeSumAggregateInputType = {
    type?: true
    size?: true
    can_search?: true
  }

  export type Parsed_episodeMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    episode_number?: true
    season_number?: true
    name?: true
    file_id?: true
    file_name?: true
    parent_file_id?: true
    parent_paths?: true
    type?: true
    size?: true
    can_search?: true
    episode_id?: true
    parsed_tv_id?: true
    parsed_season_id?: true
    drive_id?: true
    user_id?: true
  }

  export type Parsed_episodeMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    episode_number?: true
    season_number?: true
    name?: true
    file_id?: true
    file_name?: true
    parent_file_id?: true
    parent_paths?: true
    type?: true
    size?: true
    can_search?: true
    episode_id?: true
    parsed_tv_id?: true
    parsed_season_id?: true
    drive_id?: true
    user_id?: true
  }

  export type Parsed_episodeCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    episode_number?: true
    season_number?: true
    name?: true
    file_id?: true
    file_name?: true
    parent_file_id?: true
    parent_paths?: true
    type?: true
    size?: true
    can_search?: true
    episode_id?: true
    parsed_tv_id?: true
    parsed_season_id?: true
    drive_id?: true
    user_id?: true
    _all?: true
  }

  export type Parsed_episodeAggregateArgs = {
    /**
     * Filter which parsed_episode to aggregate.
     */
    where?: parsed_episodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_episodes to fetch.
     */
    orderBy?: Enumerable<parsed_episodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parsed_episodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parsed_episodes
    **/
    _count?: true | Parsed_episodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Parsed_episodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Parsed_episodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Parsed_episodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Parsed_episodeMaxAggregateInputType
  }

  export type GetParsed_episodeAggregateType<T extends Parsed_episodeAggregateArgs> = {
        [P in keyof T & keyof AggregateParsed_episode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsed_episode[P]>
      : GetScalarType<T[P], AggregateParsed_episode[P]>
  }




  export type Parsed_episodeGroupByArgs = {
    where?: parsed_episodeWhereInput
    orderBy?: Enumerable<parsed_episodeOrderByWithAggregationInput>
    by: Parsed_episodeScalarFieldEnum[]
    having?: parsed_episodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Parsed_episodeCountAggregateInputType | true
    _avg?: Parsed_episodeAvgAggregateInputType
    _sum?: Parsed_episodeSumAggregateInputType
    _min?: Parsed_episodeMinAggregateInputType
    _max?: Parsed_episodeMaxAggregateInputType
  }


  export type Parsed_episodeGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size: number | null
    can_search: number | null
    episode_id: string | null
    parsed_tv_id: string
    parsed_season_id: string
    drive_id: string
    user_id: string
    _count: Parsed_episodeCountAggregateOutputType | null
    _avg: Parsed_episodeAvgAggregateOutputType | null
    _sum: Parsed_episodeSumAggregateOutputType | null
    _min: Parsed_episodeMinAggregateOutputType | null
    _max: Parsed_episodeMaxAggregateOutputType | null
  }

  type GetParsed_episodeGroupByPayload<T extends Parsed_episodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Parsed_episodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Parsed_episodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Parsed_episodeGroupByOutputType[P]>
            : GetScalarType<T[P], Parsed_episodeGroupByOutputType[P]>
        }
      >
    >


  export type parsed_episodeSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    episode_number?: boolean
    season_number?: boolean
    name?: boolean
    file_id?: boolean
    file_name?: boolean
    parent_file_id?: boolean
    parent_paths?: boolean
    type?: boolean
    size?: boolean
    can_search?: boolean
    episode_id?: boolean
    parsed_tv_id?: boolean
    parsed_season_id?: boolean
    drive_id?: boolean
    user_id?: boolean
    episode?: boolean | episodeArgs
    parsed_tv?: boolean | parsed_tvArgs
    parsed_season?: boolean | parsed_seasonArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }


  export type parsed_episodeInclude = {
    episode?: boolean | episodeArgs
    parsed_tv?: boolean | parsed_tvArgs
    parsed_season?: boolean | parsed_seasonArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }

  export type parsed_episodeGetPayload<S extends boolean | null | undefined | parsed_episodeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? parsed_episode :
    S extends undefined ? never :
    S extends { include: any } & (parsed_episodeArgs | parsed_episodeFindManyArgs)
    ? parsed_episode  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'episode' ? episodeGetPayload<S['include'][P]> | null :
        P extends 'parsed_tv' ? parsed_tvGetPayload<S['include'][P]> :
        P extends 'parsed_season' ? parsed_seasonGetPayload<S['include'][P]> :
        P extends 'drive' ? driveGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (parsed_episodeArgs | parsed_episodeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'episode' ? episodeGetPayload<S['select'][P]> | null :
        P extends 'parsed_tv' ? parsed_tvGetPayload<S['select'][P]> :
        P extends 'parsed_season' ? parsed_seasonGetPayload<S['select'][P]> :
        P extends 'drive' ? driveGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof parsed_episode ? parsed_episode[P] : never
  } 
      : parsed_episode


  type parsed_episodeCountArgs = 
    Omit<parsed_episodeFindManyArgs, 'select' | 'include'> & {
      select?: Parsed_episodeCountAggregateInputType | true
    }

  export interface parsed_episodeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Parsed_episode that matches the filter.
     * @param {parsed_episodeFindUniqueArgs} args - Arguments to find a Parsed_episode
     * @example
     * // Get one Parsed_episode
     * const parsed_episode = await prisma.parsed_episode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends parsed_episodeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, parsed_episodeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'parsed_episode'> extends True ? Prisma__parsed_episodeClient<parsed_episodeGetPayload<T>> : Prisma__parsed_episodeClient<parsed_episodeGetPayload<T> | null, null>

    /**
     * Find one Parsed_episode that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {parsed_episodeFindUniqueOrThrowArgs} args - Arguments to find a Parsed_episode
     * @example
     * // Get one Parsed_episode
     * const parsed_episode = await prisma.parsed_episode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends parsed_episodeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, parsed_episodeFindUniqueOrThrowArgs>
    ): Prisma__parsed_episodeClient<parsed_episodeGetPayload<T>>

    /**
     * Find the first Parsed_episode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_episodeFindFirstArgs} args - Arguments to find a Parsed_episode
     * @example
     * // Get one Parsed_episode
     * const parsed_episode = await prisma.parsed_episode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends parsed_episodeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, parsed_episodeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'parsed_episode'> extends True ? Prisma__parsed_episodeClient<parsed_episodeGetPayload<T>> : Prisma__parsed_episodeClient<parsed_episodeGetPayload<T> | null, null>

    /**
     * Find the first Parsed_episode that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_episodeFindFirstOrThrowArgs} args - Arguments to find a Parsed_episode
     * @example
     * // Get one Parsed_episode
     * const parsed_episode = await prisma.parsed_episode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends parsed_episodeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, parsed_episodeFindFirstOrThrowArgs>
    ): Prisma__parsed_episodeClient<parsed_episodeGetPayload<T>>

    /**
     * Find zero or more Parsed_episodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_episodeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parsed_episodes
     * const parsed_episodes = await prisma.parsed_episode.findMany()
     * 
     * // Get first 10 Parsed_episodes
     * const parsed_episodes = await prisma.parsed_episode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsed_episodeWithIdOnly = await prisma.parsed_episode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends parsed_episodeFindManyArgs>(
      args?: SelectSubset<T, parsed_episodeFindManyArgs>
    ): Prisma.PrismaPromise<Array<parsed_episodeGetPayload<T>>>

    /**
     * Create a Parsed_episode.
     * @param {parsed_episodeCreateArgs} args - Arguments to create a Parsed_episode.
     * @example
     * // Create one Parsed_episode
     * const Parsed_episode = await prisma.parsed_episode.create({
     *   data: {
     *     // ... data to create a Parsed_episode
     *   }
     * })
     * 
    **/
    create<T extends parsed_episodeCreateArgs>(
      args: SelectSubset<T, parsed_episodeCreateArgs>
    ): Prisma__parsed_episodeClient<parsed_episodeGetPayload<T>>

    /**
     * Delete a Parsed_episode.
     * @param {parsed_episodeDeleteArgs} args - Arguments to delete one Parsed_episode.
     * @example
     * // Delete one Parsed_episode
     * const Parsed_episode = await prisma.parsed_episode.delete({
     *   where: {
     *     // ... filter to delete one Parsed_episode
     *   }
     * })
     * 
    **/
    delete<T extends parsed_episodeDeleteArgs>(
      args: SelectSubset<T, parsed_episodeDeleteArgs>
    ): Prisma__parsed_episodeClient<parsed_episodeGetPayload<T>>

    /**
     * Update one Parsed_episode.
     * @param {parsed_episodeUpdateArgs} args - Arguments to update one Parsed_episode.
     * @example
     * // Update one Parsed_episode
     * const parsed_episode = await prisma.parsed_episode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends parsed_episodeUpdateArgs>(
      args: SelectSubset<T, parsed_episodeUpdateArgs>
    ): Prisma__parsed_episodeClient<parsed_episodeGetPayload<T>>

    /**
     * Delete zero or more Parsed_episodes.
     * @param {parsed_episodeDeleteManyArgs} args - Arguments to filter Parsed_episodes to delete.
     * @example
     * // Delete a few Parsed_episodes
     * const { count } = await prisma.parsed_episode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends parsed_episodeDeleteManyArgs>(
      args?: SelectSubset<T, parsed_episodeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parsed_episodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_episodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parsed_episodes
     * const parsed_episode = await prisma.parsed_episode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends parsed_episodeUpdateManyArgs>(
      args: SelectSubset<T, parsed_episodeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parsed_episode.
     * @param {parsed_episodeUpsertArgs} args - Arguments to update or create a Parsed_episode.
     * @example
     * // Update or create a Parsed_episode
     * const parsed_episode = await prisma.parsed_episode.upsert({
     *   create: {
     *     // ... data to create a Parsed_episode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parsed_episode we want to update
     *   }
     * })
    **/
    upsert<T extends parsed_episodeUpsertArgs>(
      args: SelectSubset<T, parsed_episodeUpsertArgs>
    ): Prisma__parsed_episodeClient<parsed_episodeGetPayload<T>>

    /**
     * Count the number of Parsed_episodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_episodeCountArgs} args - Arguments to filter Parsed_episodes to count.
     * @example
     * // Count the number of Parsed_episodes
     * const count = await prisma.parsed_episode.count({
     *   where: {
     *     // ... the filter for the Parsed_episodes we want to count
     *   }
     * })
    **/
    count<T extends parsed_episodeCountArgs>(
      args?: Subset<T, parsed_episodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Parsed_episodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parsed_episode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parsed_episodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Parsed_episodeAggregateArgs>(args: Subset<T, Parsed_episodeAggregateArgs>): Prisma.PrismaPromise<GetParsed_episodeAggregateType<T>>

    /**
     * Group by Parsed_episode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parsed_episodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Parsed_episodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Parsed_episodeGroupByArgs['orderBy'] }
        : { orderBy?: Parsed_episodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Parsed_episodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsed_episodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for parsed_episode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__parsed_episodeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    episode<T extends episodeArgs= {}>(args?: Subset<T, episodeArgs>): Prisma__episodeClient<episodeGetPayload<T> | Null>;

    parsed_tv<T extends parsed_tvArgs= {}>(args?: Subset<T, parsed_tvArgs>): Prisma__parsed_tvClient<parsed_tvGetPayload<T> | Null>;

    parsed_season<T extends parsed_seasonArgs= {}>(args?: Subset<T, parsed_seasonArgs>): Prisma__parsed_seasonClient<parsed_seasonGetPayload<T> | Null>;

    drive<T extends driveArgs= {}>(args?: Subset<T, driveArgs>): Prisma__driveClient<driveGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * parsed_episode base type for findUnique actions
   */
  export type parsed_episodeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    /**
     * Filter, which parsed_episode to fetch.
     */
    where: parsed_episodeWhereUniqueInput
  }

  /**
   * parsed_episode findUnique
   */
  export interface parsed_episodeFindUniqueArgs extends parsed_episodeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parsed_episode findUniqueOrThrow
   */
  export type parsed_episodeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    /**
     * Filter, which parsed_episode to fetch.
     */
    where: parsed_episodeWhereUniqueInput
  }


  /**
   * parsed_episode base type for findFirst actions
   */
  export type parsed_episodeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    /**
     * Filter, which parsed_episode to fetch.
     */
    where?: parsed_episodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_episodes to fetch.
     */
    orderBy?: Enumerable<parsed_episodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parsed_episodes.
     */
    cursor?: parsed_episodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parsed_episodes.
     */
    distinct?: Enumerable<Parsed_episodeScalarFieldEnum>
  }

  /**
   * parsed_episode findFirst
   */
  export interface parsed_episodeFindFirstArgs extends parsed_episodeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parsed_episode findFirstOrThrow
   */
  export type parsed_episodeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    /**
     * Filter, which parsed_episode to fetch.
     */
    where?: parsed_episodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_episodes to fetch.
     */
    orderBy?: Enumerable<parsed_episodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parsed_episodes.
     */
    cursor?: parsed_episodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parsed_episodes.
     */
    distinct?: Enumerable<Parsed_episodeScalarFieldEnum>
  }


  /**
   * parsed_episode findMany
   */
  export type parsed_episodeFindManyArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    /**
     * Filter, which parsed_episodes to fetch.
     */
    where?: parsed_episodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_episodes to fetch.
     */
    orderBy?: Enumerable<parsed_episodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parsed_episodes.
     */
    cursor?: parsed_episodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_episodes.
     */
    skip?: number
    distinct?: Enumerable<Parsed_episodeScalarFieldEnum>
  }


  /**
   * parsed_episode create
   */
  export type parsed_episodeCreateArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    /**
     * The data needed to create a parsed_episode.
     */
    data: XOR<parsed_episodeCreateInput, parsed_episodeUncheckedCreateInput>
  }


  /**
   * parsed_episode update
   */
  export type parsed_episodeUpdateArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    /**
     * The data needed to update a parsed_episode.
     */
    data: XOR<parsed_episodeUpdateInput, parsed_episodeUncheckedUpdateInput>
    /**
     * Choose, which parsed_episode to update.
     */
    where: parsed_episodeWhereUniqueInput
  }


  /**
   * parsed_episode updateMany
   */
  export type parsed_episodeUpdateManyArgs = {
    /**
     * The data used to update parsed_episodes.
     */
    data: XOR<parsed_episodeUpdateManyMutationInput, parsed_episodeUncheckedUpdateManyInput>
    /**
     * Filter which parsed_episodes to update
     */
    where?: parsed_episodeWhereInput
  }


  /**
   * parsed_episode upsert
   */
  export type parsed_episodeUpsertArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    /**
     * The filter to search for the parsed_episode to update in case it exists.
     */
    where: parsed_episodeWhereUniqueInput
    /**
     * In case the parsed_episode found by the `where` argument doesn't exist, create a new parsed_episode with this data.
     */
    create: XOR<parsed_episodeCreateInput, parsed_episodeUncheckedCreateInput>
    /**
     * In case the parsed_episode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parsed_episodeUpdateInput, parsed_episodeUncheckedUpdateInput>
  }


  /**
   * parsed_episode delete
   */
  export type parsed_episodeDeleteArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    /**
     * Filter which parsed_episode to delete.
     */
    where: parsed_episodeWhereUniqueInput
  }


  /**
   * parsed_episode deleteMany
   */
  export type parsed_episodeDeleteManyArgs = {
    /**
     * Filter which parsed_episodes to delete
     */
    where?: parsed_episodeWhereInput
  }


  /**
   * parsed_episode without action
   */
  export type parsed_episodeArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
  }



  /**
   * Model parsed_movie
   */


  export type AggregateParsed_movie = {
    _count: Parsed_movieCountAggregateOutputType | null
    _avg: Parsed_movieAvgAggregateOutputType | null
    _sum: Parsed_movieSumAggregateOutputType | null
    _min: Parsed_movieMinAggregateOutputType | null
    _max: Parsed_movieMaxAggregateOutputType | null
  }

  export type Parsed_movieAvgAggregateOutputType = {
    type: number | null
    size: number | null
    can_search: number | null
  }

  export type Parsed_movieSumAggregateOutputType = {
    type: number | null
    size: number | null
    can_search: number | null
  }

  export type Parsed_movieMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    name: string | null
    original_name: string | null
    correct_name: string | null
    file_id: string | null
    file_name: string | null
    parent_file_id: string | null
    parent_paths: string | null
    type: number | null
    size: number | null
    can_search: number | null
    movie_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Parsed_movieMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    name: string | null
    original_name: string | null
    correct_name: string | null
    file_id: string | null
    file_name: string | null
    parent_file_id: string | null
    parent_paths: string | null
    type: number | null
    size: number | null
    can_search: number | null
    movie_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Parsed_movieCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    name: number
    original_name: number
    correct_name: number
    file_id: number
    file_name: number
    parent_file_id: number
    parent_paths: number
    type: number
    size: number
    can_search: number
    movie_id: number
    drive_id: number
    user_id: number
    _all: number
  }


  export type Parsed_movieAvgAggregateInputType = {
    type?: true
    size?: true
    can_search?: true
  }

  export type Parsed_movieSumAggregateInputType = {
    type?: true
    size?: true
    can_search?: true
  }

  export type Parsed_movieMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    original_name?: true
    correct_name?: true
    file_id?: true
    file_name?: true
    parent_file_id?: true
    parent_paths?: true
    type?: true
    size?: true
    can_search?: true
    movie_id?: true
    drive_id?: true
    user_id?: true
  }

  export type Parsed_movieMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    original_name?: true
    correct_name?: true
    file_id?: true
    file_name?: true
    parent_file_id?: true
    parent_paths?: true
    type?: true
    size?: true
    can_search?: true
    movie_id?: true
    drive_id?: true
    user_id?: true
  }

  export type Parsed_movieCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    original_name?: true
    correct_name?: true
    file_id?: true
    file_name?: true
    parent_file_id?: true
    parent_paths?: true
    type?: true
    size?: true
    can_search?: true
    movie_id?: true
    drive_id?: true
    user_id?: true
    _all?: true
  }

  export type Parsed_movieAggregateArgs = {
    /**
     * Filter which parsed_movie to aggregate.
     */
    where?: parsed_movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_movies to fetch.
     */
    orderBy?: Enumerable<parsed_movieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: parsed_movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned parsed_movies
    **/
    _count?: true | Parsed_movieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Parsed_movieAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Parsed_movieSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Parsed_movieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Parsed_movieMaxAggregateInputType
  }

  export type GetParsed_movieAggregateType<T extends Parsed_movieAggregateArgs> = {
        [P in keyof T & keyof AggregateParsed_movie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateParsed_movie[P]>
      : GetScalarType<T[P], AggregateParsed_movie[P]>
  }




  export type Parsed_movieGroupByArgs = {
    where?: parsed_movieWhereInput
    orderBy?: Enumerable<parsed_movieOrderByWithAggregationInput>
    by: Parsed_movieScalarFieldEnum[]
    having?: parsed_movieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Parsed_movieCountAggregateInputType | true
    _avg?: Parsed_movieAvgAggregateInputType
    _sum?: Parsed_movieSumAggregateInputType
    _min?: Parsed_movieMinAggregateInputType
    _max?: Parsed_movieMaxAggregateInputType
  }


  export type Parsed_movieGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    name: string
    original_name: string | null
    correct_name: string | null
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size: number | null
    can_search: number | null
    movie_id: string | null
    drive_id: string
    user_id: string
    _count: Parsed_movieCountAggregateOutputType | null
    _avg: Parsed_movieAvgAggregateOutputType | null
    _sum: Parsed_movieSumAggregateOutputType | null
    _min: Parsed_movieMinAggregateOutputType | null
    _max: Parsed_movieMaxAggregateOutputType | null
  }

  type GetParsed_movieGroupByPayload<T extends Parsed_movieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Parsed_movieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Parsed_movieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Parsed_movieGroupByOutputType[P]>
            : GetScalarType<T[P], Parsed_movieGroupByOutputType[P]>
        }
      >
    >


  export type parsed_movieSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    name?: boolean
    original_name?: boolean
    correct_name?: boolean
    file_id?: boolean
    file_name?: boolean
    parent_file_id?: boolean
    parent_paths?: boolean
    type?: boolean
    size?: boolean
    can_search?: boolean
    movie_id?: boolean
    drive_id?: boolean
    user_id?: boolean
    movie?: boolean | movieArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }


  export type parsed_movieInclude = {
    movie?: boolean | movieArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }

  export type parsed_movieGetPayload<S extends boolean | null | undefined | parsed_movieArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? parsed_movie :
    S extends undefined ? never :
    S extends { include: any } & (parsed_movieArgs | parsed_movieFindManyArgs)
    ? parsed_movie  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'movie' ? movieGetPayload<S['include'][P]> | null :
        P extends 'drive' ? driveGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (parsed_movieArgs | parsed_movieFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'movie' ? movieGetPayload<S['select'][P]> | null :
        P extends 'drive' ? driveGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof parsed_movie ? parsed_movie[P] : never
  } 
      : parsed_movie


  type parsed_movieCountArgs = 
    Omit<parsed_movieFindManyArgs, 'select' | 'include'> & {
      select?: Parsed_movieCountAggregateInputType | true
    }

  export interface parsed_movieDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Parsed_movie that matches the filter.
     * @param {parsed_movieFindUniqueArgs} args - Arguments to find a Parsed_movie
     * @example
     * // Get one Parsed_movie
     * const parsed_movie = await prisma.parsed_movie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends parsed_movieFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, parsed_movieFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'parsed_movie'> extends True ? Prisma__parsed_movieClient<parsed_movieGetPayload<T>> : Prisma__parsed_movieClient<parsed_movieGetPayload<T> | null, null>

    /**
     * Find one Parsed_movie that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {parsed_movieFindUniqueOrThrowArgs} args - Arguments to find a Parsed_movie
     * @example
     * // Get one Parsed_movie
     * const parsed_movie = await prisma.parsed_movie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends parsed_movieFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, parsed_movieFindUniqueOrThrowArgs>
    ): Prisma__parsed_movieClient<parsed_movieGetPayload<T>>

    /**
     * Find the first Parsed_movie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_movieFindFirstArgs} args - Arguments to find a Parsed_movie
     * @example
     * // Get one Parsed_movie
     * const parsed_movie = await prisma.parsed_movie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends parsed_movieFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, parsed_movieFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'parsed_movie'> extends True ? Prisma__parsed_movieClient<parsed_movieGetPayload<T>> : Prisma__parsed_movieClient<parsed_movieGetPayload<T> | null, null>

    /**
     * Find the first Parsed_movie that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_movieFindFirstOrThrowArgs} args - Arguments to find a Parsed_movie
     * @example
     * // Get one Parsed_movie
     * const parsed_movie = await prisma.parsed_movie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends parsed_movieFindFirstOrThrowArgs>(
      args?: SelectSubset<T, parsed_movieFindFirstOrThrowArgs>
    ): Prisma__parsed_movieClient<parsed_movieGetPayload<T>>

    /**
     * Find zero or more Parsed_movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_movieFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Parsed_movies
     * const parsed_movies = await prisma.parsed_movie.findMany()
     * 
     * // Get first 10 Parsed_movies
     * const parsed_movies = await prisma.parsed_movie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const parsed_movieWithIdOnly = await prisma.parsed_movie.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends parsed_movieFindManyArgs>(
      args?: SelectSubset<T, parsed_movieFindManyArgs>
    ): Prisma.PrismaPromise<Array<parsed_movieGetPayload<T>>>

    /**
     * Create a Parsed_movie.
     * @param {parsed_movieCreateArgs} args - Arguments to create a Parsed_movie.
     * @example
     * // Create one Parsed_movie
     * const Parsed_movie = await prisma.parsed_movie.create({
     *   data: {
     *     // ... data to create a Parsed_movie
     *   }
     * })
     * 
    **/
    create<T extends parsed_movieCreateArgs>(
      args: SelectSubset<T, parsed_movieCreateArgs>
    ): Prisma__parsed_movieClient<parsed_movieGetPayload<T>>

    /**
     * Delete a Parsed_movie.
     * @param {parsed_movieDeleteArgs} args - Arguments to delete one Parsed_movie.
     * @example
     * // Delete one Parsed_movie
     * const Parsed_movie = await prisma.parsed_movie.delete({
     *   where: {
     *     // ... filter to delete one Parsed_movie
     *   }
     * })
     * 
    **/
    delete<T extends parsed_movieDeleteArgs>(
      args: SelectSubset<T, parsed_movieDeleteArgs>
    ): Prisma__parsed_movieClient<parsed_movieGetPayload<T>>

    /**
     * Update one Parsed_movie.
     * @param {parsed_movieUpdateArgs} args - Arguments to update one Parsed_movie.
     * @example
     * // Update one Parsed_movie
     * const parsed_movie = await prisma.parsed_movie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends parsed_movieUpdateArgs>(
      args: SelectSubset<T, parsed_movieUpdateArgs>
    ): Prisma__parsed_movieClient<parsed_movieGetPayload<T>>

    /**
     * Delete zero or more Parsed_movies.
     * @param {parsed_movieDeleteManyArgs} args - Arguments to filter Parsed_movies to delete.
     * @example
     * // Delete a few Parsed_movies
     * const { count } = await prisma.parsed_movie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends parsed_movieDeleteManyArgs>(
      args?: SelectSubset<T, parsed_movieDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Parsed_movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_movieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Parsed_movies
     * const parsed_movie = await prisma.parsed_movie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends parsed_movieUpdateManyArgs>(
      args: SelectSubset<T, parsed_movieUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Parsed_movie.
     * @param {parsed_movieUpsertArgs} args - Arguments to update or create a Parsed_movie.
     * @example
     * // Update or create a Parsed_movie
     * const parsed_movie = await prisma.parsed_movie.upsert({
     *   create: {
     *     // ... data to create a Parsed_movie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Parsed_movie we want to update
     *   }
     * })
    **/
    upsert<T extends parsed_movieUpsertArgs>(
      args: SelectSubset<T, parsed_movieUpsertArgs>
    ): Prisma__parsed_movieClient<parsed_movieGetPayload<T>>

    /**
     * Count the number of Parsed_movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {parsed_movieCountArgs} args - Arguments to filter Parsed_movies to count.
     * @example
     * // Count the number of Parsed_movies
     * const count = await prisma.parsed_movie.count({
     *   where: {
     *     // ... the filter for the Parsed_movies we want to count
     *   }
     * })
    **/
    count<T extends parsed_movieCountArgs>(
      args?: Subset<T, parsed_movieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Parsed_movieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Parsed_movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parsed_movieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Parsed_movieAggregateArgs>(args: Subset<T, Parsed_movieAggregateArgs>): Prisma.PrismaPromise<GetParsed_movieAggregateType<T>>

    /**
     * Group by Parsed_movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Parsed_movieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Parsed_movieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Parsed_movieGroupByArgs['orderBy'] }
        : { orderBy?: Parsed_movieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Parsed_movieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetParsed_movieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for parsed_movie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__parsed_movieClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    movie<T extends movieArgs= {}>(args?: Subset<T, movieArgs>): Prisma__movieClient<movieGetPayload<T> | Null>;

    drive<T extends driveArgs= {}>(args?: Subset<T, driveArgs>): Prisma__driveClient<driveGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * parsed_movie base type for findUnique actions
   */
  export type parsed_movieFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    /**
     * Filter, which parsed_movie to fetch.
     */
    where: parsed_movieWhereUniqueInput
  }

  /**
   * parsed_movie findUnique
   */
  export interface parsed_movieFindUniqueArgs extends parsed_movieFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parsed_movie findUniqueOrThrow
   */
  export type parsed_movieFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    /**
     * Filter, which parsed_movie to fetch.
     */
    where: parsed_movieWhereUniqueInput
  }


  /**
   * parsed_movie base type for findFirst actions
   */
  export type parsed_movieFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    /**
     * Filter, which parsed_movie to fetch.
     */
    where?: parsed_movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_movies to fetch.
     */
    orderBy?: Enumerable<parsed_movieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parsed_movies.
     */
    cursor?: parsed_movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parsed_movies.
     */
    distinct?: Enumerable<Parsed_movieScalarFieldEnum>
  }

  /**
   * parsed_movie findFirst
   */
  export interface parsed_movieFindFirstArgs extends parsed_movieFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * parsed_movie findFirstOrThrow
   */
  export type parsed_movieFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    /**
     * Filter, which parsed_movie to fetch.
     */
    where?: parsed_movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_movies to fetch.
     */
    orderBy?: Enumerable<parsed_movieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for parsed_movies.
     */
    cursor?: parsed_movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of parsed_movies.
     */
    distinct?: Enumerable<Parsed_movieScalarFieldEnum>
  }


  /**
   * parsed_movie findMany
   */
  export type parsed_movieFindManyArgs = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    /**
     * Filter, which parsed_movies to fetch.
     */
    where?: parsed_movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of parsed_movies to fetch.
     */
    orderBy?: Enumerable<parsed_movieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing parsed_movies.
     */
    cursor?: parsed_movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` parsed_movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` parsed_movies.
     */
    skip?: number
    distinct?: Enumerable<Parsed_movieScalarFieldEnum>
  }


  /**
   * parsed_movie create
   */
  export type parsed_movieCreateArgs = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    /**
     * The data needed to create a parsed_movie.
     */
    data: XOR<parsed_movieCreateInput, parsed_movieUncheckedCreateInput>
  }


  /**
   * parsed_movie update
   */
  export type parsed_movieUpdateArgs = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    /**
     * The data needed to update a parsed_movie.
     */
    data: XOR<parsed_movieUpdateInput, parsed_movieUncheckedUpdateInput>
    /**
     * Choose, which parsed_movie to update.
     */
    where: parsed_movieWhereUniqueInput
  }


  /**
   * parsed_movie updateMany
   */
  export type parsed_movieUpdateManyArgs = {
    /**
     * The data used to update parsed_movies.
     */
    data: XOR<parsed_movieUpdateManyMutationInput, parsed_movieUncheckedUpdateManyInput>
    /**
     * Filter which parsed_movies to update
     */
    where?: parsed_movieWhereInput
  }


  /**
   * parsed_movie upsert
   */
  export type parsed_movieUpsertArgs = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    /**
     * The filter to search for the parsed_movie to update in case it exists.
     */
    where: parsed_movieWhereUniqueInput
    /**
     * In case the parsed_movie found by the `where` argument doesn't exist, create a new parsed_movie with this data.
     */
    create: XOR<parsed_movieCreateInput, parsed_movieUncheckedCreateInput>
    /**
     * In case the parsed_movie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<parsed_movieUpdateInput, parsed_movieUncheckedUpdateInput>
  }


  /**
   * parsed_movie delete
   */
  export type parsed_movieDeleteArgs = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    /**
     * Filter which parsed_movie to delete.
     */
    where: parsed_movieWhereUniqueInput
  }


  /**
   * parsed_movie deleteMany
   */
  export type parsed_movieDeleteManyArgs = {
    /**
     * Filter which parsed_movies to delete
     */
    where?: parsed_movieWhereInput
  }


  /**
   * parsed_movie without action
   */
  export type parsed_movieArgs = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
  }



  /**
   * Model tv
   */


  export type AggregateTv = {
    _count: TvCountAggregateOutputType | null
    _avg: TvAvgAggregateOutputType | null
    _sum: TvSumAggregateOutputType | null
    _min: TvMinAggregateOutputType | null
    _max: TvMaxAggregateOutputType | null
  }

  export type TvAvgAggregateOutputType = {
    hidden: number | null
  }

  export type TvSumAggregateOutputType = {
    hidden: number | null
  }

  export type TvMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    hidden: number | null
    profile_id: string | null
    collection_id: string | null
    user_id: string | null
  }

  export type TvMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    hidden: number | null
    profile_id: string | null
    collection_id: string | null
    user_id: string | null
  }

  export type TvCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    hidden: number
    profile_id: number
    collection_id: number
    user_id: number
    _all: number
  }


  export type TvAvgAggregateInputType = {
    hidden?: true
  }

  export type TvSumAggregateInputType = {
    hidden?: true
  }

  export type TvMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    hidden?: true
    profile_id?: true
    collection_id?: true
    user_id?: true
  }

  export type TvMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    hidden?: true
    profile_id?: true
    collection_id?: true
    user_id?: true
  }

  export type TvCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    hidden?: true
    profile_id?: true
    collection_id?: true
    user_id?: true
    _all?: true
  }

  export type TvAggregateArgs = {
    /**
     * Filter which tv to aggregate.
     */
    where?: tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tvs to fetch.
     */
    orderBy?: Enumerable<tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tvs
    **/
    _count?: true | TvCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TvAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TvSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TvMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TvMaxAggregateInputType
  }

  export type GetTvAggregateType<T extends TvAggregateArgs> = {
        [P in keyof T & keyof AggregateTv]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTv[P]>
      : GetScalarType<T[P], AggregateTv[P]>
  }




  export type TvGroupByArgs = {
    where?: tvWhereInput
    orderBy?: Enumerable<tvOrderByWithAggregationInput>
    by: TvScalarFieldEnum[]
    having?: tvScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TvCountAggregateInputType | true
    _avg?: TvAvgAggregateInputType
    _sum?: TvSumAggregateInputType
    _min?: TvMinAggregateInputType
    _max?: TvMaxAggregateInputType
  }


  export type TvGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    hidden: number | null
    profile_id: string
    collection_id: string | null
    user_id: string
    _count: TvCountAggregateOutputType | null
    _avg: TvAvgAggregateOutputType | null
    _sum: TvSumAggregateOutputType | null
    _min: TvMinAggregateOutputType | null
    _max: TvMaxAggregateOutputType | null
  }

  type GetTvGroupByPayload<T extends TvGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<TvGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TvGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TvGroupByOutputType[P]>
            : GetScalarType<T[P], TvGroupByOutputType[P]>
        }
      >
    >


  export type tvSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    hidden?: boolean
    profile_id?: boolean
    collection_id?: boolean
    user_id?: boolean
    profile?: boolean | tv_profileArgs
    collection?: boolean | collectionArgs
    user?: boolean | userArgs
    seasons?: boolean | tv$seasonsArgs
    episodes?: boolean | tv$episodesArgs
    play_histories?: boolean | tv$play_historiesArgs
    parsed_tvs?: boolean | tv$parsed_tvsArgs
    reports?: boolean | tv$reportsArgs
    _count?: boolean | TvCountOutputTypeArgs
  }


  export type tvInclude = {
    profile?: boolean | tv_profileArgs
    collection?: boolean | collectionArgs
    user?: boolean | userArgs
    seasons?: boolean | tv$seasonsArgs
    episodes?: boolean | tv$episodesArgs
    play_histories?: boolean | tv$play_historiesArgs
    parsed_tvs?: boolean | tv$parsed_tvsArgs
    reports?: boolean | tv$reportsArgs
    _count?: boolean | TvCountOutputTypeArgs
  }

  export type tvGetPayload<S extends boolean | null | undefined | tvArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tv :
    S extends undefined ? never :
    S extends { include: any } & (tvArgs | tvFindManyArgs)
    ? tv  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'profile' ? tv_profileGetPayload<S['include'][P]> :
        P extends 'collection' ? collectionGetPayload<S['include'][P]> | null :
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends 'seasons' ? Array < seasonGetPayload<S['include'][P]>>  :
        P extends 'episodes' ? Array < episodeGetPayload<S['include'][P]>>  :
        P extends 'play_histories' ? Array < play_historyGetPayload<S['include'][P]>>  :
        P extends 'parsed_tvs' ? Array < parsed_tvGetPayload<S['include'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends '_count' ? TvCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (tvArgs | tvFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'profile' ? tv_profileGetPayload<S['select'][P]> :
        P extends 'collection' ? collectionGetPayload<S['select'][P]> | null :
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends 'seasons' ? Array < seasonGetPayload<S['select'][P]>>  :
        P extends 'episodes' ? Array < episodeGetPayload<S['select'][P]>>  :
        P extends 'play_histories' ? Array < play_historyGetPayload<S['select'][P]>>  :
        P extends 'parsed_tvs' ? Array < parsed_tvGetPayload<S['select'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends '_count' ? TvCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof tv ? tv[P] : never
  } 
      : tv


  type tvCountArgs = 
    Omit<tvFindManyArgs, 'select' | 'include'> & {
      select?: TvCountAggregateInputType | true
    }

  export interface tvDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tv that matches the filter.
     * @param {tvFindUniqueArgs} args - Arguments to find a Tv
     * @example
     * // Get one Tv
     * const tv = await prisma.tv.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tvFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tvFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tv'> extends True ? Prisma__tvClient<tvGetPayload<T>> : Prisma__tvClient<tvGetPayload<T> | null, null>

    /**
     * Find one Tv that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tvFindUniqueOrThrowArgs} args - Arguments to find a Tv
     * @example
     * // Get one Tv
     * const tv = await prisma.tv.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tvFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tvFindUniqueOrThrowArgs>
    ): Prisma__tvClient<tvGetPayload<T>>

    /**
     * Find the first Tv that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tvFindFirstArgs} args - Arguments to find a Tv
     * @example
     * // Get one Tv
     * const tv = await prisma.tv.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tvFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tvFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tv'> extends True ? Prisma__tvClient<tvGetPayload<T>> : Prisma__tvClient<tvGetPayload<T> | null, null>

    /**
     * Find the first Tv that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tvFindFirstOrThrowArgs} args - Arguments to find a Tv
     * @example
     * // Get one Tv
     * const tv = await prisma.tv.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tvFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tvFindFirstOrThrowArgs>
    ): Prisma__tvClient<tvGetPayload<T>>

    /**
     * Find zero or more Tvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tvFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tvs
     * const tvs = await prisma.tv.findMany()
     * 
     * // Get first 10 Tvs
     * const tvs = await prisma.tv.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tvWithIdOnly = await prisma.tv.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tvFindManyArgs>(
      args?: SelectSubset<T, tvFindManyArgs>
    ): Prisma.PrismaPromise<Array<tvGetPayload<T>>>

    /**
     * Create a Tv.
     * @param {tvCreateArgs} args - Arguments to create a Tv.
     * @example
     * // Create one Tv
     * const Tv = await prisma.tv.create({
     *   data: {
     *     // ... data to create a Tv
     *   }
     * })
     * 
    **/
    create<T extends tvCreateArgs>(
      args: SelectSubset<T, tvCreateArgs>
    ): Prisma__tvClient<tvGetPayload<T>>

    /**
     * Delete a Tv.
     * @param {tvDeleteArgs} args - Arguments to delete one Tv.
     * @example
     * // Delete one Tv
     * const Tv = await prisma.tv.delete({
     *   where: {
     *     // ... filter to delete one Tv
     *   }
     * })
     * 
    **/
    delete<T extends tvDeleteArgs>(
      args: SelectSubset<T, tvDeleteArgs>
    ): Prisma__tvClient<tvGetPayload<T>>

    /**
     * Update one Tv.
     * @param {tvUpdateArgs} args - Arguments to update one Tv.
     * @example
     * // Update one Tv
     * const tv = await prisma.tv.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tvUpdateArgs>(
      args: SelectSubset<T, tvUpdateArgs>
    ): Prisma__tvClient<tvGetPayload<T>>

    /**
     * Delete zero or more Tvs.
     * @param {tvDeleteManyArgs} args - Arguments to filter Tvs to delete.
     * @example
     * // Delete a few Tvs
     * const { count } = await prisma.tv.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tvDeleteManyArgs>(
      args?: SelectSubset<T, tvDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tvUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tvs
     * const tv = await prisma.tv.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tvUpdateManyArgs>(
      args: SelectSubset<T, tvUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tv.
     * @param {tvUpsertArgs} args - Arguments to update or create a Tv.
     * @example
     * // Update or create a Tv
     * const tv = await prisma.tv.upsert({
     *   create: {
     *     // ... data to create a Tv
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tv we want to update
     *   }
     * })
    **/
    upsert<T extends tvUpsertArgs>(
      args: SelectSubset<T, tvUpsertArgs>
    ): Prisma__tvClient<tvGetPayload<T>>

    /**
     * Count the number of Tvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tvCountArgs} args - Arguments to filter Tvs to count.
     * @example
     * // Count the number of Tvs
     * const count = await prisma.tv.count({
     *   where: {
     *     // ... the filter for the Tvs we want to count
     *   }
     * })
    **/
    count<T extends tvCountArgs>(
      args?: Subset<T, tvCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TvCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TvAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TvAggregateArgs>(args: Subset<T, TvAggregateArgs>): Prisma.PrismaPromise<GetTvAggregateType<T>>

    /**
     * Group by Tv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TvGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TvGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TvGroupByArgs['orderBy'] }
        : { orderBy?: TvGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TvGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTvGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tv.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tvClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    profile<T extends tv_profileArgs= {}>(args?: Subset<T, tv_profileArgs>): Prisma__tv_profileClient<tv_profileGetPayload<T> | Null>;

    collection<T extends collectionArgs= {}>(args?: Subset<T, collectionArgs>): Prisma__collectionClient<collectionGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    seasons<T extends tv$seasonsArgs= {}>(args?: Subset<T, tv$seasonsArgs>): Prisma.PrismaPromise<Array<seasonGetPayload<T>>| Null>;

    episodes<T extends tv$episodesArgs= {}>(args?: Subset<T, tv$episodesArgs>): Prisma.PrismaPromise<Array<episodeGetPayload<T>>| Null>;

    play_histories<T extends tv$play_historiesArgs= {}>(args?: Subset<T, tv$play_historiesArgs>): Prisma.PrismaPromise<Array<play_historyGetPayload<T>>| Null>;

    parsed_tvs<T extends tv$parsed_tvsArgs= {}>(args?: Subset<T, tv$parsed_tvsArgs>): Prisma.PrismaPromise<Array<parsed_tvGetPayload<T>>| Null>;

    reports<T extends tv$reportsArgs= {}>(args?: Subset<T, tv$reportsArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tv base type for findUnique actions
   */
  export type tvFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    /**
     * Filter, which tv to fetch.
     */
    where: tvWhereUniqueInput
  }

  /**
   * tv findUnique
   */
  export interface tvFindUniqueArgs extends tvFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tv findUniqueOrThrow
   */
  export type tvFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    /**
     * Filter, which tv to fetch.
     */
    where: tvWhereUniqueInput
  }


  /**
   * tv base type for findFirst actions
   */
  export type tvFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    /**
     * Filter, which tv to fetch.
     */
    where?: tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tvs to fetch.
     */
    orderBy?: Enumerable<tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tvs.
     */
    cursor?: tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tvs.
     */
    distinct?: Enumerable<TvScalarFieldEnum>
  }

  /**
   * tv findFirst
   */
  export interface tvFindFirstArgs extends tvFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tv findFirstOrThrow
   */
  export type tvFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    /**
     * Filter, which tv to fetch.
     */
    where?: tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tvs to fetch.
     */
    orderBy?: Enumerable<tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tvs.
     */
    cursor?: tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tvs.
     */
    distinct?: Enumerable<TvScalarFieldEnum>
  }


  /**
   * tv findMany
   */
  export type tvFindManyArgs = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    /**
     * Filter, which tvs to fetch.
     */
    where?: tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tvs to fetch.
     */
    orderBy?: Enumerable<tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tvs.
     */
    cursor?: tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tvs.
     */
    skip?: number
    distinct?: Enumerable<TvScalarFieldEnum>
  }


  /**
   * tv create
   */
  export type tvCreateArgs = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    /**
     * The data needed to create a tv.
     */
    data: XOR<tvCreateInput, tvUncheckedCreateInput>
  }


  /**
   * tv update
   */
  export type tvUpdateArgs = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    /**
     * The data needed to update a tv.
     */
    data: XOR<tvUpdateInput, tvUncheckedUpdateInput>
    /**
     * Choose, which tv to update.
     */
    where: tvWhereUniqueInput
  }


  /**
   * tv updateMany
   */
  export type tvUpdateManyArgs = {
    /**
     * The data used to update tvs.
     */
    data: XOR<tvUpdateManyMutationInput, tvUncheckedUpdateManyInput>
    /**
     * Filter which tvs to update
     */
    where?: tvWhereInput
  }


  /**
   * tv upsert
   */
  export type tvUpsertArgs = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    /**
     * The filter to search for the tv to update in case it exists.
     */
    where: tvWhereUniqueInput
    /**
     * In case the tv found by the `where` argument doesn't exist, create a new tv with this data.
     */
    create: XOR<tvCreateInput, tvUncheckedCreateInput>
    /**
     * In case the tv was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tvUpdateInput, tvUncheckedUpdateInput>
  }


  /**
   * tv delete
   */
  export type tvDeleteArgs = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    /**
     * Filter which tv to delete.
     */
    where: tvWhereUniqueInput
  }


  /**
   * tv deleteMany
   */
  export type tvDeleteManyArgs = {
    /**
     * Filter which tvs to delete
     */
    where?: tvWhereInput
  }


  /**
   * tv.seasons
   */
  export type tv$seasonsArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    where?: seasonWhereInput
    orderBy?: Enumerable<seasonOrderByWithRelationInput>
    cursor?: seasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SeasonScalarFieldEnum>
  }


  /**
   * tv.episodes
   */
  export type tv$episodesArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    where?: episodeWhereInput
    orderBy?: Enumerable<episodeOrderByWithRelationInput>
    cursor?: episodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EpisodeScalarFieldEnum>
  }


  /**
   * tv.play_histories
   */
  export type tv$play_historiesArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    where?: play_historyWhereInput
    orderBy?: Enumerable<play_historyOrderByWithRelationInput>
    cursor?: play_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Play_historyScalarFieldEnum>
  }


  /**
   * tv.parsed_tvs
   */
  export type tv$parsed_tvsArgs = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    where?: parsed_tvWhereInput
    orderBy?: Enumerable<parsed_tvOrderByWithRelationInput>
    cursor?: parsed_tvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_tvScalarFieldEnum>
  }


  /**
   * tv.reports
   */
  export type tv$reportsArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * tv without action
   */
  export type tvArgs = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
  }



  /**
   * Model season
   */


  export type AggregateSeason = {
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  export type SeasonAvgAggregateOutputType = {
    season_number: number | null
  }

  export type SeasonSumAggregateOutputType = {
    season_number: number | null
  }

  export type SeasonMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    season_text: string | null
    season_number: number | null
    profile_id: string | null
    collection_id: string | null
    tv_id: string | null
    user_id: string | null
  }

  export type SeasonMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    season_text: string | null
    season_number: number | null
    profile_id: string | null
    collection_id: string | null
    tv_id: string | null
    user_id: string | null
  }

  export type SeasonCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    season_text: number
    season_number: number
    profile_id: number
    collection_id: number
    tv_id: number
    user_id: number
    _all: number
  }


  export type SeasonAvgAggregateInputType = {
    season_number?: true
  }

  export type SeasonSumAggregateInputType = {
    season_number?: true
  }

  export type SeasonMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    season_text?: true
    season_number?: true
    profile_id?: true
    collection_id?: true
    tv_id?: true
    user_id?: true
  }

  export type SeasonMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    season_text?: true
    season_number?: true
    profile_id?: true
    collection_id?: true
    tv_id?: true
    user_id?: true
  }

  export type SeasonCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    season_text?: true
    season_number?: true
    profile_id?: true
    collection_id?: true
    tv_id?: true
    user_id?: true
    _all?: true
  }

  export type SeasonAggregateArgs = {
    /**
     * Filter which season to aggregate.
     */
    where?: seasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: Enumerable<seasonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: seasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned seasons
    **/
    _count?: true | SeasonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SeasonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SeasonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SeasonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SeasonMaxAggregateInputType
  }

  export type GetSeasonAggregateType<T extends SeasonAggregateArgs> = {
        [P in keyof T & keyof AggregateSeason]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSeason[P]>
      : GetScalarType<T[P], AggregateSeason[P]>
  }




  export type SeasonGroupByArgs = {
    where?: seasonWhereInput
    orderBy?: Enumerable<seasonOrderByWithAggregationInput>
    by: SeasonScalarFieldEnum[]
    having?: seasonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SeasonCountAggregateInputType | true
    _avg?: SeasonAvgAggregateInputType
    _sum?: SeasonSumAggregateInputType
    _min?: SeasonMinAggregateInputType
    _max?: SeasonMaxAggregateInputType
  }


  export type SeasonGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    season_text: string
    season_number: number
    profile_id: string
    collection_id: string | null
    tv_id: string
    user_id: string
    _count: SeasonCountAggregateOutputType | null
    _avg: SeasonAvgAggregateOutputType | null
    _sum: SeasonSumAggregateOutputType | null
    _min: SeasonMinAggregateOutputType | null
    _max: SeasonMaxAggregateOutputType | null
  }

  type GetSeasonGroupByPayload<T extends SeasonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SeasonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SeasonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SeasonGroupByOutputType[P]>
            : GetScalarType<T[P], SeasonGroupByOutputType[P]>
        }
      >
    >


  export type seasonSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    season_text?: boolean
    season_number?: boolean
    profile_id?: boolean
    collection_id?: boolean
    tv_id?: boolean
    user_id?: boolean
    profile?: boolean | season_profileArgs
    collection?: boolean | collectionArgs
    tv?: boolean | tvArgs
    user?: boolean | userArgs
    parsed_season?: boolean | season$parsed_seasonArgs
    play_histories?: boolean | season$play_historiesArgs
    episodes?: boolean | season$episodesArgs
    reports?: boolean | season$reportsArgs
    sync_tasks?: boolean | season$sync_tasksArgs
    _count?: boolean | SeasonCountOutputTypeArgs
  }


  export type seasonInclude = {
    profile?: boolean | season_profileArgs
    collection?: boolean | collectionArgs
    tv?: boolean | tvArgs
    user?: boolean | userArgs
    parsed_season?: boolean | season$parsed_seasonArgs
    play_histories?: boolean | season$play_historiesArgs
    episodes?: boolean | season$episodesArgs
    reports?: boolean | season$reportsArgs
    sync_tasks?: boolean | season$sync_tasksArgs
    _count?: boolean | SeasonCountOutputTypeArgs
  }

  export type seasonGetPayload<S extends boolean | null | undefined | seasonArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? season :
    S extends undefined ? never :
    S extends { include: any } & (seasonArgs | seasonFindManyArgs)
    ? season  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'profile' ? season_profileGetPayload<S['include'][P]> :
        P extends 'collection' ? collectionGetPayload<S['include'][P]> | null :
        P extends 'tv' ? tvGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends 'parsed_season' ? Array < parsed_seasonGetPayload<S['include'][P]>>  :
        P extends 'play_histories' ? Array < play_historyGetPayload<S['include'][P]>>  :
        P extends 'episodes' ? Array < episodeGetPayload<S['include'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'sync_tasks' ? Array < bind_for_parsed_tvGetPayload<S['include'][P]>>  :
        P extends '_count' ? SeasonCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (seasonArgs | seasonFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'profile' ? season_profileGetPayload<S['select'][P]> :
        P extends 'collection' ? collectionGetPayload<S['select'][P]> | null :
        P extends 'tv' ? tvGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends 'parsed_season' ? Array < parsed_seasonGetPayload<S['select'][P]>>  :
        P extends 'play_histories' ? Array < play_historyGetPayload<S['select'][P]>>  :
        P extends 'episodes' ? Array < episodeGetPayload<S['select'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'sync_tasks' ? Array < bind_for_parsed_tvGetPayload<S['select'][P]>>  :
        P extends '_count' ? SeasonCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof season ? season[P] : never
  } 
      : season


  type seasonCountArgs = 
    Omit<seasonFindManyArgs, 'select' | 'include'> & {
      select?: SeasonCountAggregateInputType | true
    }

  export interface seasonDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Season that matches the filter.
     * @param {seasonFindUniqueArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends seasonFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, seasonFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'season'> extends True ? Prisma__seasonClient<seasonGetPayload<T>> : Prisma__seasonClient<seasonGetPayload<T> | null, null>

    /**
     * Find one Season that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {seasonFindUniqueOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends seasonFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, seasonFindUniqueOrThrowArgs>
    ): Prisma__seasonClient<seasonGetPayload<T>>

    /**
     * Find the first Season that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonFindFirstArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends seasonFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, seasonFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'season'> extends True ? Prisma__seasonClient<seasonGetPayload<T>> : Prisma__seasonClient<seasonGetPayload<T> | null, null>

    /**
     * Find the first Season that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonFindFirstOrThrowArgs} args - Arguments to find a Season
     * @example
     * // Get one Season
     * const season = await prisma.season.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends seasonFindFirstOrThrowArgs>(
      args?: SelectSubset<T, seasonFindFirstOrThrowArgs>
    ): Prisma__seasonClient<seasonGetPayload<T>>

    /**
     * Find zero or more Seasons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Seasons
     * const seasons = await prisma.season.findMany()
     * 
     * // Get first 10 Seasons
     * const seasons = await prisma.season.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const seasonWithIdOnly = await prisma.season.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends seasonFindManyArgs>(
      args?: SelectSubset<T, seasonFindManyArgs>
    ): Prisma.PrismaPromise<Array<seasonGetPayload<T>>>

    /**
     * Create a Season.
     * @param {seasonCreateArgs} args - Arguments to create a Season.
     * @example
     * // Create one Season
     * const Season = await prisma.season.create({
     *   data: {
     *     // ... data to create a Season
     *   }
     * })
     * 
    **/
    create<T extends seasonCreateArgs>(
      args: SelectSubset<T, seasonCreateArgs>
    ): Prisma__seasonClient<seasonGetPayload<T>>

    /**
     * Delete a Season.
     * @param {seasonDeleteArgs} args - Arguments to delete one Season.
     * @example
     * // Delete one Season
     * const Season = await prisma.season.delete({
     *   where: {
     *     // ... filter to delete one Season
     *   }
     * })
     * 
    **/
    delete<T extends seasonDeleteArgs>(
      args: SelectSubset<T, seasonDeleteArgs>
    ): Prisma__seasonClient<seasonGetPayload<T>>

    /**
     * Update one Season.
     * @param {seasonUpdateArgs} args - Arguments to update one Season.
     * @example
     * // Update one Season
     * const season = await prisma.season.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends seasonUpdateArgs>(
      args: SelectSubset<T, seasonUpdateArgs>
    ): Prisma__seasonClient<seasonGetPayload<T>>

    /**
     * Delete zero or more Seasons.
     * @param {seasonDeleteManyArgs} args - Arguments to filter Seasons to delete.
     * @example
     * // Delete a few Seasons
     * const { count } = await prisma.season.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends seasonDeleteManyArgs>(
      args?: SelectSubset<T, seasonDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Seasons
     * const season = await prisma.season.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends seasonUpdateManyArgs>(
      args: SelectSubset<T, seasonUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Season.
     * @param {seasonUpsertArgs} args - Arguments to update or create a Season.
     * @example
     * // Update or create a Season
     * const season = await prisma.season.upsert({
     *   create: {
     *     // ... data to create a Season
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Season we want to update
     *   }
     * })
    **/
    upsert<T extends seasonUpsertArgs>(
      args: SelectSubset<T, seasonUpsertArgs>
    ): Prisma__seasonClient<seasonGetPayload<T>>

    /**
     * Count the number of Seasons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {seasonCountArgs} args - Arguments to filter Seasons to count.
     * @example
     * // Count the number of Seasons
     * const count = await prisma.season.count({
     *   where: {
     *     // ... the filter for the Seasons we want to count
     *   }
     * })
    **/
    count<T extends seasonCountArgs>(
      args?: Subset<T, seasonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SeasonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SeasonAggregateArgs>(args: Subset<T, SeasonAggregateArgs>): Prisma.PrismaPromise<GetSeasonAggregateType<T>>

    /**
     * Group by Season.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SeasonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SeasonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SeasonGroupByArgs['orderBy'] }
        : { orderBy?: SeasonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SeasonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSeasonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for season.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__seasonClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    profile<T extends season_profileArgs= {}>(args?: Subset<T, season_profileArgs>): Prisma__season_profileClient<season_profileGetPayload<T> | Null>;

    collection<T extends collectionArgs= {}>(args?: Subset<T, collectionArgs>): Prisma__collectionClient<collectionGetPayload<T> | Null>;

    tv<T extends tvArgs= {}>(args?: Subset<T, tvArgs>): Prisma__tvClient<tvGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    parsed_season<T extends season$parsed_seasonArgs= {}>(args?: Subset<T, season$parsed_seasonArgs>): Prisma.PrismaPromise<Array<parsed_seasonGetPayload<T>>| Null>;

    play_histories<T extends season$play_historiesArgs= {}>(args?: Subset<T, season$play_historiesArgs>): Prisma.PrismaPromise<Array<play_historyGetPayload<T>>| Null>;

    episodes<T extends season$episodesArgs= {}>(args?: Subset<T, season$episodesArgs>): Prisma.PrismaPromise<Array<episodeGetPayload<T>>| Null>;

    reports<T extends season$reportsArgs= {}>(args?: Subset<T, season$reportsArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    sync_tasks<T extends season$sync_tasksArgs= {}>(args?: Subset<T, season$sync_tasksArgs>): Prisma.PrismaPromise<Array<bind_for_parsed_tvGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * season base type for findUnique actions
   */
  export type seasonFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    /**
     * Filter, which season to fetch.
     */
    where: seasonWhereUniqueInput
  }

  /**
   * season findUnique
   */
  export interface seasonFindUniqueArgs extends seasonFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * season findUniqueOrThrow
   */
  export type seasonFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    /**
     * Filter, which season to fetch.
     */
    where: seasonWhereUniqueInput
  }


  /**
   * season base type for findFirst actions
   */
  export type seasonFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    /**
     * Filter, which season to fetch.
     */
    where?: seasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: Enumerable<seasonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seasons.
     */
    cursor?: seasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seasons.
     */
    distinct?: Enumerable<SeasonScalarFieldEnum>
  }

  /**
   * season findFirst
   */
  export interface seasonFindFirstArgs extends seasonFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * season findFirstOrThrow
   */
  export type seasonFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    /**
     * Filter, which season to fetch.
     */
    where?: seasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: Enumerable<seasonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for seasons.
     */
    cursor?: seasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of seasons.
     */
    distinct?: Enumerable<SeasonScalarFieldEnum>
  }


  /**
   * season findMany
   */
  export type seasonFindManyArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    /**
     * Filter, which seasons to fetch.
     */
    where?: seasonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of seasons to fetch.
     */
    orderBy?: Enumerable<seasonOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing seasons.
     */
    cursor?: seasonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` seasons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` seasons.
     */
    skip?: number
    distinct?: Enumerable<SeasonScalarFieldEnum>
  }


  /**
   * season create
   */
  export type seasonCreateArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    /**
     * The data needed to create a season.
     */
    data: XOR<seasonCreateInput, seasonUncheckedCreateInput>
  }


  /**
   * season update
   */
  export type seasonUpdateArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    /**
     * The data needed to update a season.
     */
    data: XOR<seasonUpdateInput, seasonUncheckedUpdateInput>
    /**
     * Choose, which season to update.
     */
    where: seasonWhereUniqueInput
  }


  /**
   * season updateMany
   */
  export type seasonUpdateManyArgs = {
    /**
     * The data used to update seasons.
     */
    data: XOR<seasonUpdateManyMutationInput, seasonUncheckedUpdateManyInput>
    /**
     * Filter which seasons to update
     */
    where?: seasonWhereInput
  }


  /**
   * season upsert
   */
  export type seasonUpsertArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    /**
     * The filter to search for the season to update in case it exists.
     */
    where: seasonWhereUniqueInput
    /**
     * In case the season found by the `where` argument doesn't exist, create a new season with this data.
     */
    create: XOR<seasonCreateInput, seasonUncheckedCreateInput>
    /**
     * In case the season was found with the provided `where` argument, update it with this data.
     */
    update: XOR<seasonUpdateInput, seasonUncheckedUpdateInput>
  }


  /**
   * season delete
   */
  export type seasonDeleteArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    /**
     * Filter which season to delete.
     */
    where: seasonWhereUniqueInput
  }


  /**
   * season deleteMany
   */
  export type seasonDeleteManyArgs = {
    /**
     * Filter which seasons to delete
     */
    where?: seasonWhereInput
  }


  /**
   * season.parsed_season
   */
  export type season$parsed_seasonArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    where?: parsed_seasonWhereInput
    orderBy?: Enumerable<parsed_seasonOrderByWithRelationInput>
    cursor?: parsed_seasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_seasonScalarFieldEnum>
  }


  /**
   * season.play_histories
   */
  export type season$play_historiesArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    where?: play_historyWhereInput
    orderBy?: Enumerable<play_historyOrderByWithRelationInput>
    cursor?: play_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Play_historyScalarFieldEnum>
  }


  /**
   * season.episodes
   */
  export type season$episodesArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    where?: episodeWhereInput
    orderBy?: Enumerable<episodeOrderByWithRelationInput>
    cursor?: episodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EpisodeScalarFieldEnum>
  }


  /**
   * season.reports
   */
  export type season$reportsArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * season.sync_tasks
   */
  export type season$sync_tasksArgs = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    where?: bind_for_parsed_tvWhereInput
    orderBy?: Enumerable<bind_for_parsed_tvOrderByWithRelationInput>
    cursor?: bind_for_parsed_tvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Bind_for_parsed_tvScalarFieldEnum>
  }


  /**
   * season without action
   */
  export type seasonArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
  }



  /**
   * Model episode
   */


  export type AggregateEpisode = {
    _count: EpisodeCountAggregateOutputType | null
    _avg: EpisodeAvgAggregateOutputType | null
    _sum: EpisodeSumAggregateOutputType | null
    _min: EpisodeMinAggregateOutputType | null
    _max: EpisodeMaxAggregateOutputType | null
  }

  export type EpisodeAvgAggregateOutputType = {
    episode_number: number | null
  }

  export type EpisodeSumAggregateOutputType = {
    episode_number: number | null
  }

  export type EpisodeMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    episode_text: string | null
    season_text: string | null
    episode_number: number | null
    profile_id: string | null
    tv_id: string | null
    season_id: string | null
    user_id: string | null
  }

  export type EpisodeMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    episode_text: string | null
    season_text: string | null
    episode_number: number | null
    profile_id: string | null
    tv_id: string | null
    season_id: string | null
    user_id: string | null
  }

  export type EpisodeCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    episode_text: number
    season_text: number
    episode_number: number
    profile_id: number
    tv_id: number
    season_id: number
    user_id: number
    _all: number
  }


  export type EpisodeAvgAggregateInputType = {
    episode_number?: true
  }

  export type EpisodeSumAggregateInputType = {
    episode_number?: true
  }

  export type EpisodeMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    episode_text?: true
    season_text?: true
    episode_number?: true
    profile_id?: true
    tv_id?: true
    season_id?: true
    user_id?: true
  }

  export type EpisodeMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    episode_text?: true
    season_text?: true
    episode_number?: true
    profile_id?: true
    tv_id?: true
    season_id?: true
    user_id?: true
  }

  export type EpisodeCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    episode_text?: true
    season_text?: true
    episode_number?: true
    profile_id?: true
    tv_id?: true
    season_id?: true
    user_id?: true
    _all?: true
  }

  export type EpisodeAggregateArgs = {
    /**
     * Filter which episode to aggregate.
     */
    where?: episodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episodes to fetch.
     */
    orderBy?: Enumerable<episodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: episodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned episodes
    **/
    _count?: true | EpisodeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EpisodeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EpisodeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EpisodeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EpisodeMaxAggregateInputType
  }

  export type GetEpisodeAggregateType<T extends EpisodeAggregateArgs> = {
        [P in keyof T & keyof AggregateEpisode]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEpisode[P]>
      : GetScalarType<T[P], AggregateEpisode[P]>
  }




  export type EpisodeGroupByArgs = {
    where?: episodeWhereInput
    orderBy?: Enumerable<episodeOrderByWithAggregationInput>
    by: EpisodeScalarFieldEnum[]
    having?: episodeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EpisodeCountAggregateInputType | true
    _avg?: EpisodeAvgAggregateInputType
    _sum?: EpisodeSumAggregateInputType
    _min?: EpisodeMinAggregateInputType
    _max?: EpisodeMaxAggregateInputType
  }


  export type EpisodeGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    episode_text: string
    season_text: string
    episode_number: number
    profile_id: string
    tv_id: string
    season_id: string
    user_id: string
    _count: EpisodeCountAggregateOutputType | null
    _avg: EpisodeAvgAggregateOutputType | null
    _sum: EpisodeSumAggregateOutputType | null
    _min: EpisodeMinAggregateOutputType | null
    _max: EpisodeMaxAggregateOutputType | null
  }

  type GetEpisodeGroupByPayload<T extends EpisodeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<EpisodeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EpisodeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EpisodeGroupByOutputType[P]>
            : GetScalarType<T[P], EpisodeGroupByOutputType[P]>
        }
      >
    >


  export type episodeSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    episode_text?: boolean
    season_text?: boolean
    episode_number?: boolean
    profile_id?: boolean
    tv_id?: boolean
    season_id?: boolean
    user_id?: boolean
    profile?: boolean | episode_profileArgs
    tv?: boolean | tvArgs
    season?: boolean | seasonArgs
    user?: boolean | userArgs
    parsed_episodes?: boolean | episode$parsed_episodesArgs
    play_histories?: boolean | episode$play_historiesArgs
    reports?: boolean | episode$reportsArgs
    subtitles?: boolean | episode$subtitlesArgs
    _count?: boolean | EpisodeCountOutputTypeArgs
  }


  export type episodeInclude = {
    profile?: boolean | episode_profileArgs
    tv?: boolean | tvArgs
    season?: boolean | seasonArgs
    user?: boolean | userArgs
    parsed_episodes?: boolean | episode$parsed_episodesArgs
    play_histories?: boolean | episode$play_historiesArgs
    reports?: boolean | episode$reportsArgs
    subtitles?: boolean | episode$subtitlesArgs
    _count?: boolean | EpisodeCountOutputTypeArgs
  }

  export type episodeGetPayload<S extends boolean | null | undefined | episodeArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? episode :
    S extends undefined ? never :
    S extends { include: any } & (episodeArgs | episodeFindManyArgs)
    ? episode  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'profile' ? episode_profileGetPayload<S['include'][P]> :
        P extends 'tv' ? tvGetPayload<S['include'][P]> :
        P extends 'season' ? seasonGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends 'parsed_episodes' ? Array < parsed_episodeGetPayload<S['include'][P]>>  :
        P extends 'play_histories' ? Array < play_historyGetPayload<S['include'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'subtitles' ? Array < subtitleGetPayload<S['include'][P]>>  :
        P extends '_count' ? EpisodeCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (episodeArgs | episodeFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'profile' ? episode_profileGetPayload<S['select'][P]> :
        P extends 'tv' ? tvGetPayload<S['select'][P]> :
        P extends 'season' ? seasonGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends 'parsed_episodes' ? Array < parsed_episodeGetPayload<S['select'][P]>>  :
        P extends 'play_histories' ? Array < play_historyGetPayload<S['select'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'subtitles' ? Array < subtitleGetPayload<S['select'][P]>>  :
        P extends '_count' ? EpisodeCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof episode ? episode[P] : never
  } 
      : episode


  type episodeCountArgs = 
    Omit<episodeFindManyArgs, 'select' | 'include'> & {
      select?: EpisodeCountAggregateInputType | true
    }

  export interface episodeDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Episode that matches the filter.
     * @param {episodeFindUniqueArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends episodeFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, episodeFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'episode'> extends True ? Prisma__episodeClient<episodeGetPayload<T>> : Prisma__episodeClient<episodeGetPayload<T> | null, null>

    /**
     * Find one Episode that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {episodeFindUniqueOrThrowArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends episodeFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, episodeFindUniqueOrThrowArgs>
    ): Prisma__episodeClient<episodeGetPayload<T>>

    /**
     * Find the first Episode that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episodeFindFirstArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends episodeFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, episodeFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'episode'> extends True ? Prisma__episodeClient<episodeGetPayload<T>> : Prisma__episodeClient<episodeGetPayload<T> | null, null>

    /**
     * Find the first Episode that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episodeFindFirstOrThrowArgs} args - Arguments to find a Episode
     * @example
     * // Get one Episode
     * const episode = await prisma.episode.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends episodeFindFirstOrThrowArgs>(
      args?: SelectSubset<T, episodeFindFirstOrThrowArgs>
    ): Prisma__episodeClient<episodeGetPayload<T>>

    /**
     * Find zero or more Episodes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episodeFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Episodes
     * const episodes = await prisma.episode.findMany()
     * 
     * // Get first 10 Episodes
     * const episodes = await prisma.episode.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const episodeWithIdOnly = await prisma.episode.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends episodeFindManyArgs>(
      args?: SelectSubset<T, episodeFindManyArgs>
    ): Prisma.PrismaPromise<Array<episodeGetPayload<T>>>

    /**
     * Create a Episode.
     * @param {episodeCreateArgs} args - Arguments to create a Episode.
     * @example
     * // Create one Episode
     * const Episode = await prisma.episode.create({
     *   data: {
     *     // ... data to create a Episode
     *   }
     * })
     * 
    **/
    create<T extends episodeCreateArgs>(
      args: SelectSubset<T, episodeCreateArgs>
    ): Prisma__episodeClient<episodeGetPayload<T>>

    /**
     * Delete a Episode.
     * @param {episodeDeleteArgs} args - Arguments to delete one Episode.
     * @example
     * // Delete one Episode
     * const Episode = await prisma.episode.delete({
     *   where: {
     *     // ... filter to delete one Episode
     *   }
     * })
     * 
    **/
    delete<T extends episodeDeleteArgs>(
      args: SelectSubset<T, episodeDeleteArgs>
    ): Prisma__episodeClient<episodeGetPayload<T>>

    /**
     * Update one Episode.
     * @param {episodeUpdateArgs} args - Arguments to update one Episode.
     * @example
     * // Update one Episode
     * const episode = await prisma.episode.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends episodeUpdateArgs>(
      args: SelectSubset<T, episodeUpdateArgs>
    ): Prisma__episodeClient<episodeGetPayload<T>>

    /**
     * Delete zero or more Episodes.
     * @param {episodeDeleteManyArgs} args - Arguments to filter Episodes to delete.
     * @example
     * // Delete a few Episodes
     * const { count } = await prisma.episode.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends episodeDeleteManyArgs>(
      args?: SelectSubset<T, episodeDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Episodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episodeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Episodes
     * const episode = await prisma.episode.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends episodeUpdateManyArgs>(
      args: SelectSubset<T, episodeUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Episode.
     * @param {episodeUpsertArgs} args - Arguments to update or create a Episode.
     * @example
     * // Update or create a Episode
     * const episode = await prisma.episode.upsert({
     *   create: {
     *     // ... data to create a Episode
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Episode we want to update
     *   }
     * })
    **/
    upsert<T extends episodeUpsertArgs>(
      args: SelectSubset<T, episodeUpsertArgs>
    ): Prisma__episodeClient<episodeGetPayload<T>>

    /**
     * Count the number of Episodes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {episodeCountArgs} args - Arguments to filter Episodes to count.
     * @example
     * // Count the number of Episodes
     * const count = await prisma.episode.count({
     *   where: {
     *     // ... the filter for the Episodes we want to count
     *   }
     * })
    **/
    count<T extends episodeCountArgs>(
      args?: Subset<T, episodeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EpisodeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Episode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EpisodeAggregateArgs>(args: Subset<T, EpisodeAggregateArgs>): Prisma.PrismaPromise<GetEpisodeAggregateType<T>>

    /**
     * Group by Episode.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EpisodeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EpisodeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EpisodeGroupByArgs['orderBy'] }
        : { orderBy?: EpisodeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EpisodeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEpisodeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for episode.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__episodeClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    profile<T extends episode_profileArgs= {}>(args?: Subset<T, episode_profileArgs>): Prisma__episode_profileClient<episode_profileGetPayload<T> | Null>;

    tv<T extends tvArgs= {}>(args?: Subset<T, tvArgs>): Prisma__tvClient<tvGetPayload<T> | Null>;

    season<T extends seasonArgs= {}>(args?: Subset<T, seasonArgs>): Prisma__seasonClient<seasonGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    parsed_episodes<T extends episode$parsed_episodesArgs= {}>(args?: Subset<T, episode$parsed_episodesArgs>): Prisma.PrismaPromise<Array<parsed_episodeGetPayload<T>>| Null>;

    play_histories<T extends episode$play_historiesArgs= {}>(args?: Subset<T, episode$play_historiesArgs>): Prisma.PrismaPromise<Array<play_historyGetPayload<T>>| Null>;

    reports<T extends episode$reportsArgs= {}>(args?: Subset<T, episode$reportsArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    subtitles<T extends episode$subtitlesArgs= {}>(args?: Subset<T, episode$subtitlesArgs>): Prisma.PrismaPromise<Array<subtitleGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * episode base type for findUnique actions
   */
  export type episodeFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    /**
     * Filter, which episode to fetch.
     */
    where: episodeWhereUniqueInput
  }

  /**
   * episode findUnique
   */
  export interface episodeFindUniqueArgs extends episodeFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * episode findUniqueOrThrow
   */
  export type episodeFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    /**
     * Filter, which episode to fetch.
     */
    where: episodeWhereUniqueInput
  }


  /**
   * episode base type for findFirst actions
   */
  export type episodeFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    /**
     * Filter, which episode to fetch.
     */
    where?: episodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episodes to fetch.
     */
    orderBy?: Enumerable<episodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for episodes.
     */
    cursor?: episodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of episodes.
     */
    distinct?: Enumerable<EpisodeScalarFieldEnum>
  }

  /**
   * episode findFirst
   */
  export interface episodeFindFirstArgs extends episodeFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * episode findFirstOrThrow
   */
  export type episodeFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    /**
     * Filter, which episode to fetch.
     */
    where?: episodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episodes to fetch.
     */
    orderBy?: Enumerable<episodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for episodes.
     */
    cursor?: episodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episodes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of episodes.
     */
    distinct?: Enumerable<EpisodeScalarFieldEnum>
  }


  /**
   * episode findMany
   */
  export type episodeFindManyArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    /**
     * Filter, which episodes to fetch.
     */
    where?: episodeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of episodes to fetch.
     */
    orderBy?: Enumerable<episodeOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing episodes.
     */
    cursor?: episodeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` episodes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` episodes.
     */
    skip?: number
    distinct?: Enumerable<EpisodeScalarFieldEnum>
  }


  /**
   * episode create
   */
  export type episodeCreateArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    /**
     * The data needed to create a episode.
     */
    data: XOR<episodeCreateInput, episodeUncheckedCreateInput>
  }


  /**
   * episode update
   */
  export type episodeUpdateArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    /**
     * The data needed to update a episode.
     */
    data: XOR<episodeUpdateInput, episodeUncheckedUpdateInput>
    /**
     * Choose, which episode to update.
     */
    where: episodeWhereUniqueInput
  }


  /**
   * episode updateMany
   */
  export type episodeUpdateManyArgs = {
    /**
     * The data used to update episodes.
     */
    data: XOR<episodeUpdateManyMutationInput, episodeUncheckedUpdateManyInput>
    /**
     * Filter which episodes to update
     */
    where?: episodeWhereInput
  }


  /**
   * episode upsert
   */
  export type episodeUpsertArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    /**
     * The filter to search for the episode to update in case it exists.
     */
    where: episodeWhereUniqueInput
    /**
     * In case the episode found by the `where` argument doesn't exist, create a new episode with this data.
     */
    create: XOR<episodeCreateInput, episodeUncheckedCreateInput>
    /**
     * In case the episode was found with the provided `where` argument, update it with this data.
     */
    update: XOR<episodeUpdateInput, episodeUncheckedUpdateInput>
  }


  /**
   * episode delete
   */
  export type episodeDeleteArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    /**
     * Filter which episode to delete.
     */
    where: episodeWhereUniqueInput
  }


  /**
   * episode deleteMany
   */
  export type episodeDeleteManyArgs = {
    /**
     * Filter which episodes to delete
     */
    where?: episodeWhereInput
  }


  /**
   * episode.parsed_episodes
   */
  export type episode$parsed_episodesArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    where?: parsed_episodeWhereInput
    orderBy?: Enumerable<parsed_episodeOrderByWithRelationInput>
    cursor?: parsed_episodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_episodeScalarFieldEnum>
  }


  /**
   * episode.play_histories
   */
  export type episode$play_historiesArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    where?: play_historyWhereInput
    orderBy?: Enumerable<play_historyOrderByWithRelationInput>
    cursor?: play_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Play_historyScalarFieldEnum>
  }


  /**
   * episode.reports
   */
  export type episode$reportsArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * episode.subtitles
   */
  export type episode$subtitlesArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    where?: subtitleWhereInput
    orderBy?: Enumerable<subtitleOrderByWithRelationInput>
    cursor?: subtitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubtitleScalarFieldEnum>
  }


  /**
   * episode without action
   */
  export type episodeArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
  }



  /**
   * Model movie
   */


  export type AggregateMovie = {
    _count: MovieCountAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  export type MovieMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    profile_id: string | null
    user_id: string | null
    collection_id: string | null
  }

  export type MovieMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    profile_id: string | null
    user_id: string | null
    collection_id: string | null
  }

  export type MovieCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    profile_id: number
    user_id: number
    collection_id: number
    _all: number
  }


  export type MovieMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    profile_id?: true
    user_id?: true
    collection_id?: true
  }

  export type MovieMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    profile_id?: true
    user_id?: true
    collection_id?: true
  }

  export type MovieCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    profile_id?: true
    user_id?: true
    collection_id?: true
    _all?: true
  }

  export type MovieAggregateArgs = {
    /**
     * Filter which movie to aggregate.
     */
    where?: movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movies to fetch.
     */
    orderBy?: Enumerable<movieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned movies
    **/
    _count?: true | MovieCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MovieMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MovieMaxAggregateInputType
  }

  export type GetMovieAggregateType<T extends MovieAggregateArgs> = {
        [P in keyof T & keyof AggregateMovie]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMovie[P]>
      : GetScalarType<T[P], AggregateMovie[P]>
  }




  export type MovieGroupByArgs = {
    where?: movieWhereInput
    orderBy?: Enumerable<movieOrderByWithAggregationInput>
    by: MovieScalarFieldEnum[]
    having?: movieScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MovieCountAggregateInputType | true
    _min?: MovieMinAggregateInputType
    _max?: MovieMaxAggregateInputType
  }


  export type MovieGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    profile_id: string
    user_id: string
    collection_id: string | null
    _count: MovieCountAggregateOutputType | null
    _min: MovieMinAggregateOutputType | null
    _max: MovieMaxAggregateOutputType | null
  }

  type GetMovieGroupByPayload<T extends MovieGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MovieGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MovieGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MovieGroupByOutputType[P]>
            : GetScalarType<T[P], MovieGroupByOutputType[P]>
        }
      >
    >


  export type movieSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    profile_id?: boolean
    user_id?: boolean
    collection_id?: boolean
    profile?: boolean | movie_profileArgs
    user?: boolean | userArgs
    collection?: boolean | collectionArgs
    play_histories?: boolean | movie$play_historiesArgs
    parsed_movies?: boolean | movie$parsed_moviesArgs
    reports?: boolean | movie$reportsArgs
    subtitles?: boolean | movie$subtitlesArgs
    _count?: boolean | MovieCountOutputTypeArgs
  }


  export type movieInclude = {
    profile?: boolean | movie_profileArgs
    user?: boolean | userArgs
    collection?: boolean | collectionArgs
    play_histories?: boolean | movie$play_historiesArgs
    parsed_movies?: boolean | movie$parsed_moviesArgs
    reports?: boolean | movie$reportsArgs
    subtitles?: boolean | movie$subtitlesArgs
    _count?: boolean | MovieCountOutputTypeArgs
  }

  export type movieGetPayload<S extends boolean | null | undefined | movieArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? movie :
    S extends undefined ? never :
    S extends { include: any } & (movieArgs | movieFindManyArgs)
    ? movie  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'profile' ? movie_profileGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends 'collection' ? collectionGetPayload<S['include'][P]> | null :
        P extends 'play_histories' ? Array < play_historyGetPayload<S['include'][P]>>  :
        P extends 'parsed_movies' ? Array < parsed_movieGetPayload<S['include'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'subtitles' ? Array < subtitleGetPayload<S['include'][P]>>  :
        P extends '_count' ? MovieCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (movieArgs | movieFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'profile' ? movie_profileGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends 'collection' ? collectionGetPayload<S['select'][P]> | null :
        P extends 'play_histories' ? Array < play_historyGetPayload<S['select'][P]>>  :
        P extends 'parsed_movies' ? Array < parsed_movieGetPayload<S['select'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'subtitles' ? Array < subtitleGetPayload<S['select'][P]>>  :
        P extends '_count' ? MovieCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof movie ? movie[P] : never
  } 
      : movie


  type movieCountArgs = 
    Omit<movieFindManyArgs, 'select' | 'include'> & {
      select?: MovieCountAggregateInputType | true
    }

  export interface movieDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Movie that matches the filter.
     * @param {movieFindUniqueArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends movieFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, movieFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'movie'> extends True ? Prisma__movieClient<movieGetPayload<T>> : Prisma__movieClient<movieGetPayload<T> | null, null>

    /**
     * Find one Movie that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {movieFindUniqueOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends movieFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, movieFindUniqueOrThrowArgs>
    ): Prisma__movieClient<movieGetPayload<T>>

    /**
     * Find the first Movie that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movieFindFirstArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends movieFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, movieFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'movie'> extends True ? Prisma__movieClient<movieGetPayload<T>> : Prisma__movieClient<movieGetPayload<T> | null, null>

    /**
     * Find the first Movie that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movieFindFirstOrThrowArgs} args - Arguments to find a Movie
     * @example
     * // Get one Movie
     * const movie = await prisma.movie.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends movieFindFirstOrThrowArgs>(
      args?: SelectSubset<T, movieFindFirstOrThrowArgs>
    ): Prisma__movieClient<movieGetPayload<T>>

    /**
     * Find zero or more Movies that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movieFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Movies
     * const movies = await prisma.movie.findMany()
     * 
     * // Get first 10 Movies
     * const movies = await prisma.movie.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const movieWithIdOnly = await prisma.movie.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends movieFindManyArgs>(
      args?: SelectSubset<T, movieFindManyArgs>
    ): Prisma.PrismaPromise<Array<movieGetPayload<T>>>

    /**
     * Create a Movie.
     * @param {movieCreateArgs} args - Arguments to create a Movie.
     * @example
     * // Create one Movie
     * const Movie = await prisma.movie.create({
     *   data: {
     *     // ... data to create a Movie
     *   }
     * })
     * 
    **/
    create<T extends movieCreateArgs>(
      args: SelectSubset<T, movieCreateArgs>
    ): Prisma__movieClient<movieGetPayload<T>>

    /**
     * Delete a Movie.
     * @param {movieDeleteArgs} args - Arguments to delete one Movie.
     * @example
     * // Delete one Movie
     * const Movie = await prisma.movie.delete({
     *   where: {
     *     // ... filter to delete one Movie
     *   }
     * })
     * 
    **/
    delete<T extends movieDeleteArgs>(
      args: SelectSubset<T, movieDeleteArgs>
    ): Prisma__movieClient<movieGetPayload<T>>

    /**
     * Update one Movie.
     * @param {movieUpdateArgs} args - Arguments to update one Movie.
     * @example
     * // Update one Movie
     * const movie = await prisma.movie.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends movieUpdateArgs>(
      args: SelectSubset<T, movieUpdateArgs>
    ): Prisma__movieClient<movieGetPayload<T>>

    /**
     * Delete zero or more Movies.
     * @param {movieDeleteManyArgs} args - Arguments to filter Movies to delete.
     * @example
     * // Delete a few Movies
     * const { count } = await prisma.movie.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends movieDeleteManyArgs>(
      args?: SelectSubset<T, movieDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movieUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Movies
     * const movie = await prisma.movie.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends movieUpdateManyArgs>(
      args: SelectSubset<T, movieUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Movie.
     * @param {movieUpsertArgs} args - Arguments to update or create a Movie.
     * @example
     * // Update or create a Movie
     * const movie = await prisma.movie.upsert({
     *   create: {
     *     // ... data to create a Movie
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Movie we want to update
     *   }
     * })
    **/
    upsert<T extends movieUpsertArgs>(
      args: SelectSubset<T, movieUpsertArgs>
    ): Prisma__movieClient<movieGetPayload<T>>

    /**
     * Count the number of Movies.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {movieCountArgs} args - Arguments to filter Movies to count.
     * @example
     * // Count the number of Movies
     * const count = await prisma.movie.count({
     *   where: {
     *     // ... the filter for the Movies we want to count
     *   }
     * })
    **/
    count<T extends movieCountArgs>(
      args?: Subset<T, movieCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MovieCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MovieAggregateArgs>(args: Subset<T, MovieAggregateArgs>): Prisma.PrismaPromise<GetMovieAggregateType<T>>

    /**
     * Group by Movie.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MovieGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MovieGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MovieGroupByArgs['orderBy'] }
        : { orderBy?: MovieGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MovieGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMovieGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for movie.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__movieClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    profile<T extends movie_profileArgs= {}>(args?: Subset<T, movie_profileArgs>): Prisma__movie_profileClient<movie_profileGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    collection<T extends collectionArgs= {}>(args?: Subset<T, collectionArgs>): Prisma__collectionClient<collectionGetPayload<T> | Null>;

    play_histories<T extends movie$play_historiesArgs= {}>(args?: Subset<T, movie$play_historiesArgs>): Prisma.PrismaPromise<Array<play_historyGetPayload<T>>| Null>;

    parsed_movies<T extends movie$parsed_moviesArgs= {}>(args?: Subset<T, movie$parsed_moviesArgs>): Prisma.PrismaPromise<Array<parsed_movieGetPayload<T>>| Null>;

    reports<T extends movie$reportsArgs= {}>(args?: Subset<T, movie$reportsArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    subtitles<T extends movie$subtitlesArgs= {}>(args?: Subset<T, movie$subtitlesArgs>): Prisma.PrismaPromise<Array<subtitleGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * movie base type for findUnique actions
   */
  export type movieFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    /**
     * Filter, which movie to fetch.
     */
    where: movieWhereUniqueInput
  }

  /**
   * movie findUnique
   */
  export interface movieFindUniqueArgs extends movieFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * movie findUniqueOrThrow
   */
  export type movieFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    /**
     * Filter, which movie to fetch.
     */
    where: movieWhereUniqueInput
  }


  /**
   * movie base type for findFirst actions
   */
  export type movieFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    /**
     * Filter, which movie to fetch.
     */
    where?: movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movies to fetch.
     */
    orderBy?: Enumerable<movieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for movies.
     */
    cursor?: movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of movies.
     */
    distinct?: Enumerable<MovieScalarFieldEnum>
  }

  /**
   * movie findFirst
   */
  export interface movieFindFirstArgs extends movieFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * movie findFirstOrThrow
   */
  export type movieFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    /**
     * Filter, which movie to fetch.
     */
    where?: movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movies to fetch.
     */
    orderBy?: Enumerable<movieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for movies.
     */
    cursor?: movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movies.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of movies.
     */
    distinct?: Enumerable<MovieScalarFieldEnum>
  }


  /**
   * movie findMany
   */
  export type movieFindManyArgs = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    /**
     * Filter, which movies to fetch.
     */
    where?: movieWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of movies to fetch.
     */
    orderBy?: Enumerable<movieOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing movies.
     */
    cursor?: movieWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` movies from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` movies.
     */
    skip?: number
    distinct?: Enumerable<MovieScalarFieldEnum>
  }


  /**
   * movie create
   */
  export type movieCreateArgs = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    /**
     * The data needed to create a movie.
     */
    data: XOR<movieCreateInput, movieUncheckedCreateInput>
  }


  /**
   * movie update
   */
  export type movieUpdateArgs = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    /**
     * The data needed to update a movie.
     */
    data: XOR<movieUpdateInput, movieUncheckedUpdateInput>
    /**
     * Choose, which movie to update.
     */
    where: movieWhereUniqueInput
  }


  /**
   * movie updateMany
   */
  export type movieUpdateManyArgs = {
    /**
     * The data used to update movies.
     */
    data: XOR<movieUpdateManyMutationInput, movieUncheckedUpdateManyInput>
    /**
     * Filter which movies to update
     */
    where?: movieWhereInput
  }


  /**
   * movie upsert
   */
  export type movieUpsertArgs = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    /**
     * The filter to search for the movie to update in case it exists.
     */
    where: movieWhereUniqueInput
    /**
     * In case the movie found by the `where` argument doesn't exist, create a new movie with this data.
     */
    create: XOR<movieCreateInput, movieUncheckedCreateInput>
    /**
     * In case the movie was found with the provided `where` argument, update it with this data.
     */
    update: XOR<movieUpdateInput, movieUncheckedUpdateInput>
  }


  /**
   * movie delete
   */
  export type movieDeleteArgs = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    /**
     * Filter which movie to delete.
     */
    where: movieWhereUniqueInput
  }


  /**
   * movie deleteMany
   */
  export type movieDeleteManyArgs = {
    /**
     * Filter which movies to delete
     */
    where?: movieWhereInput
  }


  /**
   * movie.play_histories
   */
  export type movie$play_historiesArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    where?: play_historyWhereInput
    orderBy?: Enumerable<play_historyOrderByWithRelationInput>
    cursor?: play_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Play_historyScalarFieldEnum>
  }


  /**
   * movie.parsed_movies
   */
  export type movie$parsed_moviesArgs = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    where?: parsed_movieWhereInput
    orderBy?: Enumerable<parsed_movieOrderByWithRelationInput>
    cursor?: parsed_movieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_movieScalarFieldEnum>
  }


  /**
   * movie.reports
   */
  export type movie$reportsArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * movie.subtitles
   */
  export type movie$subtitlesArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    where?: subtitleWhereInput
    orderBy?: Enumerable<subtitleOrderByWithRelationInput>
    cursor?: subtitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubtitleScalarFieldEnum>
  }


  /**
   * movie without action
   */
  export type movieArgs = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
  }



  /**
   * Model collection
   */


  export type AggregateCollection = {
    _count: CollectionCountAggregateOutputType | null
    _avg: CollectionAvgAggregateOutputType | null
    _sum: CollectionSumAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  export type CollectionAvgAggregateOutputType = {
    type: number | null
    sort: number | null
  }

  export type CollectionSumAggregateOutputType = {
    type: number | null
    sort: number | null
  }

  export type CollectionMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    title: string | null
    desc: string | null
    type: number | null
    rules: string | null
    sort: number | null
    styles: string | null
    user_id: string | null
  }

  export type CollectionMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    title: string | null
    desc: string | null
    type: number | null
    rules: string | null
    sort: number | null
    styles: string | null
    user_id: string | null
  }

  export type CollectionCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    title: number
    desc: number
    type: number
    rules: number
    sort: number
    styles: number
    user_id: number
    _all: number
  }


  export type CollectionAvgAggregateInputType = {
    type?: true
    sort?: true
  }

  export type CollectionSumAggregateInputType = {
    type?: true
    sort?: true
  }

  export type CollectionMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    title?: true
    desc?: true
    type?: true
    rules?: true
    sort?: true
    styles?: true
    user_id?: true
  }

  export type CollectionMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    title?: true
    desc?: true
    type?: true
    rules?: true
    sort?: true
    styles?: true
    user_id?: true
  }

  export type CollectionCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    title?: true
    desc?: true
    type?: true
    rules?: true
    sort?: true
    styles?: true
    user_id?: true
    _all?: true
  }

  export type CollectionAggregateArgs = {
    /**
     * Filter which collection to aggregate.
     */
    where?: collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: Enumerable<collectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned collections
    **/
    _count?: true | CollectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CollectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CollectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CollectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CollectionMaxAggregateInputType
  }

  export type GetCollectionAggregateType<T extends CollectionAggregateArgs> = {
        [P in keyof T & keyof AggregateCollection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCollection[P]>
      : GetScalarType<T[P], AggregateCollection[P]>
  }




  export type CollectionGroupByArgs = {
    where?: collectionWhereInput
    orderBy?: Enumerable<collectionOrderByWithAggregationInput>
    by: CollectionScalarFieldEnum[]
    having?: collectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CollectionCountAggregateInputType | true
    _avg?: CollectionAvgAggregateInputType
    _sum?: CollectionSumAggregateInputType
    _min?: CollectionMinAggregateInputType
    _max?: CollectionMaxAggregateInputType
  }


  export type CollectionGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    title: string
    desc: string | null
    type: number
    rules: string | null
    sort: number
    styles: string | null
    user_id: string
    _count: CollectionCountAggregateOutputType | null
    _avg: CollectionAvgAggregateOutputType | null
    _sum: CollectionSumAggregateOutputType | null
    _min: CollectionMinAggregateOutputType | null
    _max: CollectionMaxAggregateOutputType | null
  }

  type GetCollectionGroupByPayload<T extends CollectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CollectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CollectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CollectionGroupByOutputType[P]>
            : GetScalarType<T[P], CollectionGroupByOutputType[P]>
        }
      >
    >


  export type collectionSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    title?: boolean
    desc?: boolean
    type?: boolean
    rules?: boolean
    sort?: boolean
    styles?: boolean
    user_id?: boolean
    tvs?: boolean | collection$tvsArgs
    seasons?: boolean | collection$seasonsArgs
    movies?: boolean | collection$moviesArgs
    user?: boolean | userArgs
    _count?: boolean | CollectionCountOutputTypeArgs
  }


  export type collectionInclude = {
    tvs?: boolean | collection$tvsArgs
    seasons?: boolean | collection$seasonsArgs
    movies?: boolean | collection$moviesArgs
    user?: boolean | userArgs
    _count?: boolean | CollectionCountOutputTypeArgs
  }

  export type collectionGetPayload<S extends boolean | null | undefined | collectionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? collection :
    S extends undefined ? never :
    S extends { include: any } & (collectionArgs | collectionFindManyArgs)
    ? collection  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tvs' ? Array < tvGetPayload<S['include'][P]>>  :
        P extends 'seasons' ? Array < seasonGetPayload<S['include'][P]>>  :
        P extends 'movies' ? Array < movieGetPayload<S['include'][P]>>  :
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends '_count' ? CollectionCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (collectionArgs | collectionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tvs' ? Array < tvGetPayload<S['select'][P]>>  :
        P extends 'seasons' ? Array < seasonGetPayload<S['select'][P]>>  :
        P extends 'movies' ? Array < movieGetPayload<S['select'][P]>>  :
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends '_count' ? CollectionCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof collection ? collection[P] : never
  } 
      : collection


  type collectionCountArgs = 
    Omit<collectionFindManyArgs, 'select' | 'include'> & {
      select?: CollectionCountAggregateInputType | true
    }

  export interface collectionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Collection that matches the filter.
     * @param {collectionFindUniqueArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends collectionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, collectionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'collection'> extends True ? Prisma__collectionClient<collectionGetPayload<T>> : Prisma__collectionClient<collectionGetPayload<T> | null, null>

    /**
     * Find one Collection that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {collectionFindUniqueOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends collectionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, collectionFindUniqueOrThrowArgs>
    ): Prisma__collectionClient<collectionGetPayload<T>>

    /**
     * Find the first Collection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionFindFirstArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends collectionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, collectionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'collection'> extends True ? Prisma__collectionClient<collectionGetPayload<T>> : Prisma__collectionClient<collectionGetPayload<T> | null, null>

    /**
     * Find the first Collection that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionFindFirstOrThrowArgs} args - Arguments to find a Collection
     * @example
     * // Get one Collection
     * const collection = await prisma.collection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends collectionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, collectionFindFirstOrThrowArgs>
    ): Prisma__collectionClient<collectionGetPayload<T>>

    /**
     * Find zero or more Collections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Collections
     * const collections = await prisma.collection.findMany()
     * 
     * // Get first 10 Collections
     * const collections = await prisma.collection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const collectionWithIdOnly = await prisma.collection.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends collectionFindManyArgs>(
      args?: SelectSubset<T, collectionFindManyArgs>
    ): Prisma.PrismaPromise<Array<collectionGetPayload<T>>>

    /**
     * Create a Collection.
     * @param {collectionCreateArgs} args - Arguments to create a Collection.
     * @example
     * // Create one Collection
     * const Collection = await prisma.collection.create({
     *   data: {
     *     // ... data to create a Collection
     *   }
     * })
     * 
    **/
    create<T extends collectionCreateArgs>(
      args: SelectSubset<T, collectionCreateArgs>
    ): Prisma__collectionClient<collectionGetPayload<T>>

    /**
     * Delete a Collection.
     * @param {collectionDeleteArgs} args - Arguments to delete one Collection.
     * @example
     * // Delete one Collection
     * const Collection = await prisma.collection.delete({
     *   where: {
     *     // ... filter to delete one Collection
     *   }
     * })
     * 
    **/
    delete<T extends collectionDeleteArgs>(
      args: SelectSubset<T, collectionDeleteArgs>
    ): Prisma__collectionClient<collectionGetPayload<T>>

    /**
     * Update one Collection.
     * @param {collectionUpdateArgs} args - Arguments to update one Collection.
     * @example
     * // Update one Collection
     * const collection = await prisma.collection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends collectionUpdateArgs>(
      args: SelectSubset<T, collectionUpdateArgs>
    ): Prisma__collectionClient<collectionGetPayload<T>>

    /**
     * Delete zero or more Collections.
     * @param {collectionDeleteManyArgs} args - Arguments to filter Collections to delete.
     * @example
     * // Delete a few Collections
     * const { count } = await prisma.collection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends collectionDeleteManyArgs>(
      args?: SelectSubset<T, collectionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Collections
     * const collection = await prisma.collection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends collectionUpdateManyArgs>(
      args: SelectSubset<T, collectionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Collection.
     * @param {collectionUpsertArgs} args - Arguments to update or create a Collection.
     * @example
     * // Update or create a Collection
     * const collection = await prisma.collection.upsert({
     *   create: {
     *     // ... data to create a Collection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Collection we want to update
     *   }
     * })
    **/
    upsert<T extends collectionUpsertArgs>(
      args: SelectSubset<T, collectionUpsertArgs>
    ): Prisma__collectionClient<collectionGetPayload<T>>

    /**
     * Count the number of Collections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {collectionCountArgs} args - Arguments to filter Collections to count.
     * @example
     * // Count the number of Collections
     * const count = await prisma.collection.count({
     *   where: {
     *     // ... the filter for the Collections we want to count
     *   }
     * })
    **/
    count<T extends collectionCountArgs>(
      args?: Subset<T, collectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CollectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CollectionAggregateArgs>(args: Subset<T, CollectionAggregateArgs>): Prisma.PrismaPromise<GetCollectionAggregateType<T>>

    /**
     * Group by Collection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CollectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CollectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CollectionGroupByArgs['orderBy'] }
        : { orderBy?: CollectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CollectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCollectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for collection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__collectionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tvs<T extends collection$tvsArgs= {}>(args?: Subset<T, collection$tvsArgs>): Prisma.PrismaPromise<Array<tvGetPayload<T>>| Null>;

    seasons<T extends collection$seasonsArgs= {}>(args?: Subset<T, collection$seasonsArgs>): Prisma.PrismaPromise<Array<seasonGetPayload<T>>| Null>;

    movies<T extends collection$moviesArgs= {}>(args?: Subset<T, collection$moviesArgs>): Prisma.PrismaPromise<Array<movieGetPayload<T>>| Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * collection base type for findUnique actions
   */
  export type collectionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionInclude | null
    /**
     * Filter, which collection to fetch.
     */
    where: collectionWhereUniqueInput
  }

  /**
   * collection findUnique
   */
  export interface collectionFindUniqueArgs extends collectionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * collection findUniqueOrThrow
   */
  export type collectionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionInclude | null
    /**
     * Filter, which collection to fetch.
     */
    where: collectionWhereUniqueInput
  }


  /**
   * collection base type for findFirst actions
   */
  export type collectionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionInclude | null
    /**
     * Filter, which collection to fetch.
     */
    where?: collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: Enumerable<collectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collections.
     */
    cursor?: collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collections.
     */
    distinct?: Enumerable<CollectionScalarFieldEnum>
  }

  /**
   * collection findFirst
   */
  export interface collectionFindFirstArgs extends collectionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * collection findFirstOrThrow
   */
  export type collectionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionInclude | null
    /**
     * Filter, which collection to fetch.
     */
    where?: collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: Enumerable<collectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for collections.
     */
    cursor?: collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of collections.
     */
    distinct?: Enumerable<CollectionScalarFieldEnum>
  }


  /**
   * collection findMany
   */
  export type collectionFindManyArgs = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionInclude | null
    /**
     * Filter, which collections to fetch.
     */
    where?: collectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of collections to fetch.
     */
    orderBy?: Enumerable<collectionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing collections.
     */
    cursor?: collectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` collections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` collections.
     */
    skip?: number
    distinct?: Enumerable<CollectionScalarFieldEnum>
  }


  /**
   * collection create
   */
  export type collectionCreateArgs = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionInclude | null
    /**
     * The data needed to create a collection.
     */
    data: XOR<collectionCreateInput, collectionUncheckedCreateInput>
  }


  /**
   * collection update
   */
  export type collectionUpdateArgs = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionInclude | null
    /**
     * The data needed to update a collection.
     */
    data: XOR<collectionUpdateInput, collectionUncheckedUpdateInput>
    /**
     * Choose, which collection to update.
     */
    where: collectionWhereUniqueInput
  }


  /**
   * collection updateMany
   */
  export type collectionUpdateManyArgs = {
    /**
     * The data used to update collections.
     */
    data: XOR<collectionUpdateManyMutationInput, collectionUncheckedUpdateManyInput>
    /**
     * Filter which collections to update
     */
    where?: collectionWhereInput
  }


  /**
   * collection upsert
   */
  export type collectionUpsertArgs = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionInclude | null
    /**
     * The filter to search for the collection to update in case it exists.
     */
    where: collectionWhereUniqueInput
    /**
     * In case the collection found by the `where` argument doesn't exist, create a new collection with this data.
     */
    create: XOR<collectionCreateInput, collectionUncheckedCreateInput>
    /**
     * In case the collection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<collectionUpdateInput, collectionUncheckedUpdateInput>
  }


  /**
   * collection delete
   */
  export type collectionDeleteArgs = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionInclude | null
    /**
     * Filter which collection to delete.
     */
    where: collectionWhereUniqueInput
  }


  /**
   * collection deleteMany
   */
  export type collectionDeleteManyArgs = {
    /**
     * Filter which collections to delete
     */
    where?: collectionWhereInput
  }


  /**
   * collection.tvs
   */
  export type collection$tvsArgs = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    where?: tvWhereInput
    orderBy?: Enumerable<tvOrderByWithRelationInput>
    cursor?: tvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TvScalarFieldEnum>
  }


  /**
   * collection.seasons
   */
  export type collection$seasonsArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    where?: seasonWhereInput
    orderBy?: Enumerable<seasonOrderByWithRelationInput>
    cursor?: seasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SeasonScalarFieldEnum>
  }


  /**
   * collection.movies
   */
  export type collection$moviesArgs = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    where?: movieWhereInput
    orderBy?: Enumerable<movieOrderByWithRelationInput>
    cursor?: movieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MovieScalarFieldEnum>
  }


  /**
   * collection without action
   */
  export type collectionArgs = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionInclude | null
  }



  /**
   * Model async_task
   */


  export type AggregateAsync_task = {
    _count: Async_taskCountAggregateOutputType | null
    _avg: Async_taskAvgAggregateOutputType | null
    _sum: Async_taskSumAggregateOutputType | null
    _min: Async_taskMinAggregateOutputType | null
    _max: Async_taskMaxAggregateOutputType | null
  }

  export type Async_taskAvgAggregateOutputType = {
    type: number | null
    status: number | null
    need_stop: number | null
  }

  export type Async_taskSumAggregateOutputType = {
    type: number | null
    status: number | null
    need_stop: number | null
  }

  export type Async_taskMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    type: number | null
    desc: string | null
    status: number | null
    need_stop: number | null
    error: string | null
    output_id: string | null
    user_id: string | null
  }

  export type Async_taskMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    type: number | null
    desc: string | null
    status: number | null
    need_stop: number | null
    error: string | null
    output_id: string | null
    user_id: string | null
  }

  export type Async_taskCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    unique_id: number
    type: number
    desc: number
    status: number
    need_stop: number
    error: number
    output_id: number
    user_id: number
    _all: number
  }


  export type Async_taskAvgAggregateInputType = {
    type?: true
    status?: true
    need_stop?: true
  }

  export type Async_taskSumAggregateInputType = {
    type?: true
    status?: true
    need_stop?: true
  }

  export type Async_taskMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    type?: true
    desc?: true
    status?: true
    need_stop?: true
    error?: true
    output_id?: true
    user_id?: true
  }

  export type Async_taskMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    type?: true
    desc?: true
    status?: true
    need_stop?: true
    error?: true
    output_id?: true
    user_id?: true
  }

  export type Async_taskCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    type?: true
    desc?: true
    status?: true
    need_stop?: true
    error?: true
    output_id?: true
    user_id?: true
    _all?: true
  }

  export type Async_taskAggregateArgs = {
    /**
     * Filter which async_task to aggregate.
     */
    where?: async_taskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of async_tasks to fetch.
     */
    orderBy?: Enumerable<async_taskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: async_taskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` async_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` async_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned async_tasks
    **/
    _count?: true | Async_taskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Async_taskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Async_taskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Async_taskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Async_taskMaxAggregateInputType
  }

  export type GetAsync_taskAggregateType<T extends Async_taskAggregateArgs> = {
        [P in keyof T & keyof AggregateAsync_task]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAsync_task[P]>
      : GetScalarType<T[P], AggregateAsync_task[P]>
  }




  export type Async_taskGroupByArgs = {
    where?: async_taskWhereInput
    orderBy?: Enumerable<async_taskOrderByWithAggregationInput>
    by: Async_taskScalarFieldEnum[]
    having?: async_taskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Async_taskCountAggregateInputType | true
    _avg?: Async_taskAvgAggregateInputType
    _sum?: Async_taskSumAggregateInputType
    _min?: Async_taskMinAggregateInputType
    _max?: Async_taskMaxAggregateInputType
  }


  export type Async_taskGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    unique_id: string
    type: number | null
    desc: string | null
    status: number | null
    need_stop: number | null
    error: string | null
    output_id: string
    user_id: string
    _count: Async_taskCountAggregateOutputType | null
    _avg: Async_taskAvgAggregateOutputType | null
    _sum: Async_taskSumAggregateOutputType | null
    _min: Async_taskMinAggregateOutputType | null
    _max: Async_taskMaxAggregateOutputType | null
  }

  type GetAsync_taskGroupByPayload<T extends Async_taskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Async_taskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Async_taskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Async_taskGroupByOutputType[P]>
            : GetScalarType<T[P], Async_taskGroupByOutputType[P]>
        }
      >
    >


  export type async_taskSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    unique_id?: boolean
    type?: boolean
    desc?: boolean
    status?: boolean
    need_stop?: boolean
    error?: boolean
    output_id?: boolean
    user_id?: boolean
    output?: boolean | outputArgs
    user?: boolean | userArgs
  }


  export type async_taskInclude = {
    output?: boolean | outputArgs
    user?: boolean | userArgs
  }

  export type async_taskGetPayload<S extends boolean | null | undefined | async_taskArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? async_task :
    S extends undefined ? never :
    S extends { include: any } & (async_taskArgs | async_taskFindManyArgs)
    ? async_task  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'output' ? outputGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (async_taskArgs | async_taskFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'output' ? outputGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof async_task ? async_task[P] : never
  } 
      : async_task


  type async_taskCountArgs = 
    Omit<async_taskFindManyArgs, 'select' | 'include'> & {
      select?: Async_taskCountAggregateInputType | true
    }

  export interface async_taskDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Async_task that matches the filter.
     * @param {async_taskFindUniqueArgs} args - Arguments to find a Async_task
     * @example
     * // Get one Async_task
     * const async_task = await prisma.async_task.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends async_taskFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, async_taskFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'async_task'> extends True ? Prisma__async_taskClient<async_taskGetPayload<T>> : Prisma__async_taskClient<async_taskGetPayload<T> | null, null>

    /**
     * Find one Async_task that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {async_taskFindUniqueOrThrowArgs} args - Arguments to find a Async_task
     * @example
     * // Get one Async_task
     * const async_task = await prisma.async_task.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends async_taskFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, async_taskFindUniqueOrThrowArgs>
    ): Prisma__async_taskClient<async_taskGetPayload<T>>

    /**
     * Find the first Async_task that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {async_taskFindFirstArgs} args - Arguments to find a Async_task
     * @example
     * // Get one Async_task
     * const async_task = await prisma.async_task.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends async_taskFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, async_taskFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'async_task'> extends True ? Prisma__async_taskClient<async_taskGetPayload<T>> : Prisma__async_taskClient<async_taskGetPayload<T> | null, null>

    /**
     * Find the first Async_task that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {async_taskFindFirstOrThrowArgs} args - Arguments to find a Async_task
     * @example
     * // Get one Async_task
     * const async_task = await prisma.async_task.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends async_taskFindFirstOrThrowArgs>(
      args?: SelectSubset<T, async_taskFindFirstOrThrowArgs>
    ): Prisma__async_taskClient<async_taskGetPayload<T>>

    /**
     * Find zero or more Async_tasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {async_taskFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Async_tasks
     * const async_tasks = await prisma.async_task.findMany()
     * 
     * // Get first 10 Async_tasks
     * const async_tasks = await prisma.async_task.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const async_taskWithIdOnly = await prisma.async_task.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends async_taskFindManyArgs>(
      args?: SelectSubset<T, async_taskFindManyArgs>
    ): Prisma.PrismaPromise<Array<async_taskGetPayload<T>>>

    /**
     * Create a Async_task.
     * @param {async_taskCreateArgs} args - Arguments to create a Async_task.
     * @example
     * // Create one Async_task
     * const Async_task = await prisma.async_task.create({
     *   data: {
     *     // ... data to create a Async_task
     *   }
     * })
     * 
    **/
    create<T extends async_taskCreateArgs>(
      args: SelectSubset<T, async_taskCreateArgs>
    ): Prisma__async_taskClient<async_taskGetPayload<T>>

    /**
     * Delete a Async_task.
     * @param {async_taskDeleteArgs} args - Arguments to delete one Async_task.
     * @example
     * // Delete one Async_task
     * const Async_task = await prisma.async_task.delete({
     *   where: {
     *     // ... filter to delete one Async_task
     *   }
     * })
     * 
    **/
    delete<T extends async_taskDeleteArgs>(
      args: SelectSubset<T, async_taskDeleteArgs>
    ): Prisma__async_taskClient<async_taskGetPayload<T>>

    /**
     * Update one Async_task.
     * @param {async_taskUpdateArgs} args - Arguments to update one Async_task.
     * @example
     * // Update one Async_task
     * const async_task = await prisma.async_task.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends async_taskUpdateArgs>(
      args: SelectSubset<T, async_taskUpdateArgs>
    ): Prisma__async_taskClient<async_taskGetPayload<T>>

    /**
     * Delete zero or more Async_tasks.
     * @param {async_taskDeleteManyArgs} args - Arguments to filter Async_tasks to delete.
     * @example
     * // Delete a few Async_tasks
     * const { count } = await prisma.async_task.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends async_taskDeleteManyArgs>(
      args?: SelectSubset<T, async_taskDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Async_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {async_taskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Async_tasks
     * const async_task = await prisma.async_task.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends async_taskUpdateManyArgs>(
      args: SelectSubset<T, async_taskUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Async_task.
     * @param {async_taskUpsertArgs} args - Arguments to update or create a Async_task.
     * @example
     * // Update or create a Async_task
     * const async_task = await prisma.async_task.upsert({
     *   create: {
     *     // ... data to create a Async_task
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Async_task we want to update
     *   }
     * })
    **/
    upsert<T extends async_taskUpsertArgs>(
      args: SelectSubset<T, async_taskUpsertArgs>
    ): Prisma__async_taskClient<async_taskGetPayload<T>>

    /**
     * Count the number of Async_tasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {async_taskCountArgs} args - Arguments to filter Async_tasks to count.
     * @example
     * // Count the number of Async_tasks
     * const count = await prisma.async_task.count({
     *   where: {
     *     // ... the filter for the Async_tasks we want to count
     *   }
     * })
    **/
    count<T extends async_taskCountArgs>(
      args?: Subset<T, async_taskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Async_taskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Async_task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Async_taskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Async_taskAggregateArgs>(args: Subset<T, Async_taskAggregateArgs>): Prisma.PrismaPromise<GetAsync_taskAggregateType<T>>

    /**
     * Group by Async_task.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Async_taskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Async_taskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Async_taskGroupByArgs['orderBy'] }
        : { orderBy?: Async_taskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Async_taskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAsync_taskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for async_task.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__async_taskClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    output<T extends outputArgs= {}>(args?: Subset<T, outputArgs>): Prisma__outputClient<outputGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * async_task base type for findUnique actions
   */
  export type async_taskFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the async_task
     */
    select?: async_taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: async_taskInclude | null
    /**
     * Filter, which async_task to fetch.
     */
    where: async_taskWhereUniqueInput
  }

  /**
   * async_task findUnique
   */
  export interface async_taskFindUniqueArgs extends async_taskFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * async_task findUniqueOrThrow
   */
  export type async_taskFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the async_task
     */
    select?: async_taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: async_taskInclude | null
    /**
     * Filter, which async_task to fetch.
     */
    where: async_taskWhereUniqueInput
  }


  /**
   * async_task base type for findFirst actions
   */
  export type async_taskFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the async_task
     */
    select?: async_taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: async_taskInclude | null
    /**
     * Filter, which async_task to fetch.
     */
    where?: async_taskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of async_tasks to fetch.
     */
    orderBy?: Enumerable<async_taskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for async_tasks.
     */
    cursor?: async_taskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` async_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` async_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of async_tasks.
     */
    distinct?: Enumerable<Async_taskScalarFieldEnum>
  }

  /**
   * async_task findFirst
   */
  export interface async_taskFindFirstArgs extends async_taskFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * async_task findFirstOrThrow
   */
  export type async_taskFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the async_task
     */
    select?: async_taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: async_taskInclude | null
    /**
     * Filter, which async_task to fetch.
     */
    where?: async_taskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of async_tasks to fetch.
     */
    orderBy?: Enumerable<async_taskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for async_tasks.
     */
    cursor?: async_taskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` async_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` async_tasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of async_tasks.
     */
    distinct?: Enumerable<Async_taskScalarFieldEnum>
  }


  /**
   * async_task findMany
   */
  export type async_taskFindManyArgs = {
    /**
     * Select specific fields to fetch from the async_task
     */
    select?: async_taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: async_taskInclude | null
    /**
     * Filter, which async_tasks to fetch.
     */
    where?: async_taskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of async_tasks to fetch.
     */
    orderBy?: Enumerable<async_taskOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing async_tasks.
     */
    cursor?: async_taskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` async_tasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` async_tasks.
     */
    skip?: number
    distinct?: Enumerable<Async_taskScalarFieldEnum>
  }


  /**
   * async_task create
   */
  export type async_taskCreateArgs = {
    /**
     * Select specific fields to fetch from the async_task
     */
    select?: async_taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: async_taskInclude | null
    /**
     * The data needed to create a async_task.
     */
    data: XOR<async_taskCreateInput, async_taskUncheckedCreateInput>
  }


  /**
   * async_task update
   */
  export type async_taskUpdateArgs = {
    /**
     * Select specific fields to fetch from the async_task
     */
    select?: async_taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: async_taskInclude | null
    /**
     * The data needed to update a async_task.
     */
    data: XOR<async_taskUpdateInput, async_taskUncheckedUpdateInput>
    /**
     * Choose, which async_task to update.
     */
    where: async_taskWhereUniqueInput
  }


  /**
   * async_task updateMany
   */
  export type async_taskUpdateManyArgs = {
    /**
     * The data used to update async_tasks.
     */
    data: XOR<async_taskUpdateManyMutationInput, async_taskUncheckedUpdateManyInput>
    /**
     * Filter which async_tasks to update
     */
    where?: async_taskWhereInput
  }


  /**
   * async_task upsert
   */
  export type async_taskUpsertArgs = {
    /**
     * Select specific fields to fetch from the async_task
     */
    select?: async_taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: async_taskInclude | null
    /**
     * The filter to search for the async_task to update in case it exists.
     */
    where: async_taskWhereUniqueInput
    /**
     * In case the async_task found by the `where` argument doesn't exist, create a new async_task with this data.
     */
    create: XOR<async_taskCreateInput, async_taskUncheckedCreateInput>
    /**
     * In case the async_task was found with the provided `where` argument, update it with this data.
     */
    update: XOR<async_taskUpdateInput, async_taskUncheckedUpdateInput>
  }


  /**
   * async_task delete
   */
  export type async_taskDeleteArgs = {
    /**
     * Select specific fields to fetch from the async_task
     */
    select?: async_taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: async_taskInclude | null
    /**
     * Filter which async_task to delete.
     */
    where: async_taskWhereUniqueInput
  }


  /**
   * async_task deleteMany
   */
  export type async_taskDeleteManyArgs = {
    /**
     * Filter which async_tasks to delete
     */
    where?: async_taskWhereInput
  }


  /**
   * async_task without action
   */
  export type async_taskArgs = {
    /**
     * Select specific fields to fetch from the async_task
     */
    select?: async_taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: async_taskInclude | null
  }



  /**
   * Model output
   */


  export type AggregateOutput = {
    _count: OutputCountAggregateOutputType | null
    _min: OutputMinAggregateOutputType | null
    _max: OutputMaxAggregateOutputType | null
  }

  export type OutputMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    user_id: string | null
  }

  export type OutputMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    user_id: string | null
  }

  export type OutputCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    user_id: number
    _all: number
  }


  export type OutputMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    user_id?: true
  }

  export type OutputMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    user_id?: true
  }

  export type OutputCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    user_id?: true
    _all?: true
  }

  export type OutputAggregateArgs = {
    /**
     * Filter which output to aggregate.
     */
    where?: outputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outputs to fetch.
     */
    orderBy?: Enumerable<outputOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: outputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned outputs
    **/
    _count?: true | OutputCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OutputMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OutputMaxAggregateInputType
  }

  export type GetOutputAggregateType<T extends OutputAggregateArgs> = {
        [P in keyof T & keyof AggregateOutput]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutput[P]>
      : GetScalarType<T[P], AggregateOutput[P]>
  }




  export type OutputGroupByArgs = {
    where?: outputWhereInput
    orderBy?: Enumerable<outputOrderByWithAggregationInput>
    by: OutputScalarFieldEnum[]
    having?: outputScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OutputCountAggregateInputType | true
    _min?: OutputMinAggregateInputType
    _max?: OutputMaxAggregateInputType
  }


  export type OutputGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    user_id: string
    _count: OutputCountAggregateOutputType | null
    _min: OutputMinAggregateOutputType | null
    _max: OutputMaxAggregateOutputType | null
  }

  type GetOutputGroupByPayload<T extends OutputGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<OutputGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OutputGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OutputGroupByOutputType[P]>
            : GetScalarType<T[P], OutputGroupByOutputType[P]>
        }
      >
    >


  export type outputSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    user_id?: boolean
    lines?: boolean | output$linesArgs
    user?: boolean | userArgs
    async_task?: boolean | async_taskArgs
    _count?: boolean | OutputCountOutputTypeArgs
  }


  export type outputInclude = {
    lines?: boolean | output$linesArgs
    user?: boolean | userArgs
    async_task?: boolean | async_taskArgs
    _count?: boolean | OutputCountOutputTypeArgs
  }

  export type outputGetPayload<S extends boolean | null | undefined | outputArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? output :
    S extends undefined ? never :
    S extends { include: any } & (outputArgs | outputFindManyArgs)
    ? output  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'lines' ? Array < output_lineGetPayload<S['include'][P]>>  :
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends 'async_task' ? async_taskGetPayload<S['include'][P]> | null :
        P extends '_count' ? OutputCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (outputArgs | outputFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'lines' ? Array < output_lineGetPayload<S['select'][P]>>  :
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends 'async_task' ? async_taskGetPayload<S['select'][P]> | null :
        P extends '_count' ? OutputCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof output ? output[P] : never
  } 
      : output


  type outputCountArgs = 
    Omit<outputFindManyArgs, 'select' | 'include'> & {
      select?: OutputCountAggregateInputType | true
    }

  export interface outputDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Output that matches the filter.
     * @param {outputFindUniqueArgs} args - Arguments to find a Output
     * @example
     * // Get one Output
     * const output = await prisma.output.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends outputFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, outputFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'output'> extends True ? Prisma__outputClient<outputGetPayload<T>> : Prisma__outputClient<outputGetPayload<T> | null, null>

    /**
     * Find one Output that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {outputFindUniqueOrThrowArgs} args - Arguments to find a Output
     * @example
     * // Get one Output
     * const output = await prisma.output.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends outputFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, outputFindUniqueOrThrowArgs>
    ): Prisma__outputClient<outputGetPayload<T>>

    /**
     * Find the first Output that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outputFindFirstArgs} args - Arguments to find a Output
     * @example
     * // Get one Output
     * const output = await prisma.output.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends outputFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, outputFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'output'> extends True ? Prisma__outputClient<outputGetPayload<T>> : Prisma__outputClient<outputGetPayload<T> | null, null>

    /**
     * Find the first Output that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outputFindFirstOrThrowArgs} args - Arguments to find a Output
     * @example
     * // Get one Output
     * const output = await prisma.output.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends outputFindFirstOrThrowArgs>(
      args?: SelectSubset<T, outputFindFirstOrThrowArgs>
    ): Prisma__outputClient<outputGetPayload<T>>

    /**
     * Find zero or more Outputs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outputFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Outputs
     * const outputs = await prisma.output.findMany()
     * 
     * // Get first 10 Outputs
     * const outputs = await prisma.output.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const outputWithIdOnly = await prisma.output.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends outputFindManyArgs>(
      args?: SelectSubset<T, outputFindManyArgs>
    ): Prisma.PrismaPromise<Array<outputGetPayload<T>>>

    /**
     * Create a Output.
     * @param {outputCreateArgs} args - Arguments to create a Output.
     * @example
     * // Create one Output
     * const Output = await prisma.output.create({
     *   data: {
     *     // ... data to create a Output
     *   }
     * })
     * 
    **/
    create<T extends outputCreateArgs>(
      args: SelectSubset<T, outputCreateArgs>
    ): Prisma__outputClient<outputGetPayload<T>>

    /**
     * Delete a Output.
     * @param {outputDeleteArgs} args - Arguments to delete one Output.
     * @example
     * // Delete one Output
     * const Output = await prisma.output.delete({
     *   where: {
     *     // ... filter to delete one Output
     *   }
     * })
     * 
    **/
    delete<T extends outputDeleteArgs>(
      args: SelectSubset<T, outputDeleteArgs>
    ): Prisma__outputClient<outputGetPayload<T>>

    /**
     * Update one Output.
     * @param {outputUpdateArgs} args - Arguments to update one Output.
     * @example
     * // Update one Output
     * const output = await prisma.output.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends outputUpdateArgs>(
      args: SelectSubset<T, outputUpdateArgs>
    ): Prisma__outputClient<outputGetPayload<T>>

    /**
     * Delete zero or more Outputs.
     * @param {outputDeleteManyArgs} args - Arguments to filter Outputs to delete.
     * @example
     * // Delete a few Outputs
     * const { count } = await prisma.output.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends outputDeleteManyArgs>(
      args?: SelectSubset<T, outputDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Outputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outputUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Outputs
     * const output = await prisma.output.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends outputUpdateManyArgs>(
      args: SelectSubset<T, outputUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Output.
     * @param {outputUpsertArgs} args - Arguments to update or create a Output.
     * @example
     * // Update or create a Output
     * const output = await prisma.output.upsert({
     *   create: {
     *     // ... data to create a Output
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Output we want to update
     *   }
     * })
    **/
    upsert<T extends outputUpsertArgs>(
      args: SelectSubset<T, outputUpsertArgs>
    ): Prisma__outputClient<outputGetPayload<T>>

    /**
     * Count the number of Outputs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {outputCountArgs} args - Arguments to filter Outputs to count.
     * @example
     * // Count the number of Outputs
     * const count = await prisma.output.count({
     *   where: {
     *     // ... the filter for the Outputs we want to count
     *   }
     * })
    **/
    count<T extends outputCountArgs>(
      args?: Subset<T, outputCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OutputCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Output.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutputAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OutputAggregateArgs>(args: Subset<T, OutputAggregateArgs>): Prisma.PrismaPromise<GetOutputAggregateType<T>>

    /**
     * Group by Output.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OutputGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OutputGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OutputGroupByArgs['orderBy'] }
        : { orderBy?: OutputGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OutputGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutputGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for output.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__outputClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    lines<T extends output$linesArgs= {}>(args?: Subset<T, output$linesArgs>): Prisma.PrismaPromise<Array<output_lineGetPayload<T>>| Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    async_task<T extends async_taskArgs= {}>(args?: Subset<T, async_taskArgs>): Prisma__async_taskClient<async_taskGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * output base type for findUnique actions
   */
  export type outputFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the output
     */
    select?: outputSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outputInclude | null
    /**
     * Filter, which output to fetch.
     */
    where: outputWhereUniqueInput
  }

  /**
   * output findUnique
   */
  export interface outputFindUniqueArgs extends outputFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * output findUniqueOrThrow
   */
  export type outputFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the output
     */
    select?: outputSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outputInclude | null
    /**
     * Filter, which output to fetch.
     */
    where: outputWhereUniqueInput
  }


  /**
   * output base type for findFirst actions
   */
  export type outputFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the output
     */
    select?: outputSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outputInclude | null
    /**
     * Filter, which output to fetch.
     */
    where?: outputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outputs to fetch.
     */
    orderBy?: Enumerable<outputOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for outputs.
     */
    cursor?: outputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of outputs.
     */
    distinct?: Enumerable<OutputScalarFieldEnum>
  }

  /**
   * output findFirst
   */
  export interface outputFindFirstArgs extends outputFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * output findFirstOrThrow
   */
  export type outputFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the output
     */
    select?: outputSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outputInclude | null
    /**
     * Filter, which output to fetch.
     */
    where?: outputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outputs to fetch.
     */
    orderBy?: Enumerable<outputOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for outputs.
     */
    cursor?: outputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outputs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of outputs.
     */
    distinct?: Enumerable<OutputScalarFieldEnum>
  }


  /**
   * output findMany
   */
  export type outputFindManyArgs = {
    /**
     * Select specific fields to fetch from the output
     */
    select?: outputSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outputInclude | null
    /**
     * Filter, which outputs to fetch.
     */
    where?: outputWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of outputs to fetch.
     */
    orderBy?: Enumerable<outputOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing outputs.
     */
    cursor?: outputWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` outputs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` outputs.
     */
    skip?: number
    distinct?: Enumerable<OutputScalarFieldEnum>
  }


  /**
   * output create
   */
  export type outputCreateArgs = {
    /**
     * Select specific fields to fetch from the output
     */
    select?: outputSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outputInclude | null
    /**
     * The data needed to create a output.
     */
    data: XOR<outputCreateInput, outputUncheckedCreateInput>
  }


  /**
   * output update
   */
  export type outputUpdateArgs = {
    /**
     * Select specific fields to fetch from the output
     */
    select?: outputSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outputInclude | null
    /**
     * The data needed to update a output.
     */
    data: XOR<outputUpdateInput, outputUncheckedUpdateInput>
    /**
     * Choose, which output to update.
     */
    where: outputWhereUniqueInput
  }


  /**
   * output updateMany
   */
  export type outputUpdateManyArgs = {
    /**
     * The data used to update outputs.
     */
    data: XOR<outputUpdateManyMutationInput, outputUncheckedUpdateManyInput>
    /**
     * Filter which outputs to update
     */
    where?: outputWhereInput
  }


  /**
   * output upsert
   */
  export type outputUpsertArgs = {
    /**
     * Select specific fields to fetch from the output
     */
    select?: outputSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outputInclude | null
    /**
     * The filter to search for the output to update in case it exists.
     */
    where: outputWhereUniqueInput
    /**
     * In case the output found by the `where` argument doesn't exist, create a new output with this data.
     */
    create: XOR<outputCreateInput, outputUncheckedCreateInput>
    /**
     * In case the output was found with the provided `where` argument, update it with this data.
     */
    update: XOR<outputUpdateInput, outputUncheckedUpdateInput>
  }


  /**
   * output delete
   */
  export type outputDeleteArgs = {
    /**
     * Select specific fields to fetch from the output
     */
    select?: outputSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outputInclude | null
    /**
     * Filter which output to delete.
     */
    where: outputWhereUniqueInput
  }


  /**
   * output deleteMany
   */
  export type outputDeleteManyArgs = {
    /**
     * Filter which outputs to delete
     */
    where?: outputWhereInput
  }


  /**
   * output.lines
   */
  export type output$linesArgs = {
    /**
     * Select specific fields to fetch from the output_line
     */
    select?: output_lineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: output_lineInclude | null
    where?: output_lineWhereInput
    orderBy?: Enumerable<output_lineOrderByWithRelationInput>
    cursor?: output_lineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Output_lineScalarFieldEnum>
  }


  /**
   * output without action
   */
  export type outputArgs = {
    /**
     * Select specific fields to fetch from the output
     */
    select?: outputSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outputInclude | null
  }



  /**
   * Model output_line
   */


  export type AggregateOutput_line = {
    _count: Output_lineCountAggregateOutputType | null
    _min: Output_lineMinAggregateOutputType | null
    _max: Output_lineMaxAggregateOutputType | null
  }

  export type Output_lineMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    content: string | null
    output_id: string | null
  }

  export type Output_lineMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    content: string | null
    output_id: string | null
  }

  export type Output_lineCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    content: number
    output_id: number
    _all: number
  }


  export type Output_lineMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    content?: true
    output_id?: true
  }

  export type Output_lineMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    content?: true
    output_id?: true
  }

  export type Output_lineCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    content?: true
    output_id?: true
    _all?: true
  }

  export type Output_lineAggregateArgs = {
    /**
     * Filter which output_line to aggregate.
     */
    where?: output_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_lines to fetch.
     */
    orderBy?: Enumerable<output_lineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: output_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_lines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned output_lines
    **/
    _count?: true | Output_lineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Output_lineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Output_lineMaxAggregateInputType
  }

  export type GetOutput_lineAggregateType<T extends Output_lineAggregateArgs> = {
        [P in keyof T & keyof AggregateOutput_line]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOutput_line[P]>
      : GetScalarType<T[P], AggregateOutput_line[P]>
  }




  export type Output_lineGroupByArgs = {
    where?: output_lineWhereInput
    orderBy?: Enumerable<output_lineOrderByWithAggregationInput>
    by: Output_lineScalarFieldEnum[]
    having?: output_lineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Output_lineCountAggregateInputType | true
    _min?: Output_lineMinAggregateInputType
    _max?: Output_lineMaxAggregateInputType
  }


  export type Output_lineGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    content: string
    output_id: string | null
    _count: Output_lineCountAggregateOutputType | null
    _min: Output_lineMinAggregateOutputType | null
    _max: Output_lineMaxAggregateOutputType | null
  }

  type GetOutput_lineGroupByPayload<T extends Output_lineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Output_lineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Output_lineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Output_lineGroupByOutputType[P]>
            : GetScalarType<T[P], Output_lineGroupByOutputType[P]>
        }
      >
    >


  export type output_lineSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    content?: boolean
    output_id?: boolean
    output?: boolean | outputArgs
  }


  export type output_lineInclude = {
    output?: boolean | outputArgs
  }

  export type output_lineGetPayload<S extends boolean | null | undefined | output_lineArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? output_line :
    S extends undefined ? never :
    S extends { include: any } & (output_lineArgs | output_lineFindManyArgs)
    ? output_line  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'output' ? outputGetPayload<S['include'][P]> | null :  never
  } 
    : S extends { select: any } & (output_lineArgs | output_lineFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'output' ? outputGetPayload<S['select'][P]> | null :  P extends keyof output_line ? output_line[P] : never
  } 
      : output_line


  type output_lineCountArgs = 
    Omit<output_lineFindManyArgs, 'select' | 'include'> & {
      select?: Output_lineCountAggregateInputType | true
    }

  export interface output_lineDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Output_line that matches the filter.
     * @param {output_lineFindUniqueArgs} args - Arguments to find a Output_line
     * @example
     * // Get one Output_line
     * const output_line = await prisma.output_line.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends output_lineFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, output_lineFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'output_line'> extends True ? Prisma__output_lineClient<output_lineGetPayload<T>> : Prisma__output_lineClient<output_lineGetPayload<T> | null, null>

    /**
     * Find one Output_line that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {output_lineFindUniqueOrThrowArgs} args - Arguments to find a Output_line
     * @example
     * // Get one Output_line
     * const output_line = await prisma.output_line.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends output_lineFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, output_lineFindUniqueOrThrowArgs>
    ): Prisma__output_lineClient<output_lineGetPayload<T>>

    /**
     * Find the first Output_line that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_lineFindFirstArgs} args - Arguments to find a Output_line
     * @example
     * // Get one Output_line
     * const output_line = await prisma.output_line.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends output_lineFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, output_lineFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'output_line'> extends True ? Prisma__output_lineClient<output_lineGetPayload<T>> : Prisma__output_lineClient<output_lineGetPayload<T> | null, null>

    /**
     * Find the first Output_line that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_lineFindFirstOrThrowArgs} args - Arguments to find a Output_line
     * @example
     * // Get one Output_line
     * const output_line = await prisma.output_line.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends output_lineFindFirstOrThrowArgs>(
      args?: SelectSubset<T, output_lineFindFirstOrThrowArgs>
    ): Prisma__output_lineClient<output_lineGetPayload<T>>

    /**
     * Find zero or more Output_lines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_lineFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Output_lines
     * const output_lines = await prisma.output_line.findMany()
     * 
     * // Get first 10 Output_lines
     * const output_lines = await prisma.output_line.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const output_lineWithIdOnly = await prisma.output_line.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends output_lineFindManyArgs>(
      args?: SelectSubset<T, output_lineFindManyArgs>
    ): Prisma.PrismaPromise<Array<output_lineGetPayload<T>>>

    /**
     * Create a Output_line.
     * @param {output_lineCreateArgs} args - Arguments to create a Output_line.
     * @example
     * // Create one Output_line
     * const Output_line = await prisma.output_line.create({
     *   data: {
     *     // ... data to create a Output_line
     *   }
     * })
     * 
    **/
    create<T extends output_lineCreateArgs>(
      args: SelectSubset<T, output_lineCreateArgs>
    ): Prisma__output_lineClient<output_lineGetPayload<T>>

    /**
     * Delete a Output_line.
     * @param {output_lineDeleteArgs} args - Arguments to delete one Output_line.
     * @example
     * // Delete one Output_line
     * const Output_line = await prisma.output_line.delete({
     *   where: {
     *     // ... filter to delete one Output_line
     *   }
     * })
     * 
    **/
    delete<T extends output_lineDeleteArgs>(
      args: SelectSubset<T, output_lineDeleteArgs>
    ): Prisma__output_lineClient<output_lineGetPayload<T>>

    /**
     * Update one Output_line.
     * @param {output_lineUpdateArgs} args - Arguments to update one Output_line.
     * @example
     * // Update one Output_line
     * const output_line = await prisma.output_line.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends output_lineUpdateArgs>(
      args: SelectSubset<T, output_lineUpdateArgs>
    ): Prisma__output_lineClient<output_lineGetPayload<T>>

    /**
     * Delete zero or more Output_lines.
     * @param {output_lineDeleteManyArgs} args - Arguments to filter Output_lines to delete.
     * @example
     * // Delete a few Output_lines
     * const { count } = await prisma.output_line.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends output_lineDeleteManyArgs>(
      args?: SelectSubset<T, output_lineDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Output_lines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_lineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Output_lines
     * const output_line = await prisma.output_line.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends output_lineUpdateManyArgs>(
      args: SelectSubset<T, output_lineUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Output_line.
     * @param {output_lineUpsertArgs} args - Arguments to update or create a Output_line.
     * @example
     * // Update or create a Output_line
     * const output_line = await prisma.output_line.upsert({
     *   create: {
     *     // ... data to create a Output_line
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Output_line we want to update
     *   }
     * })
    **/
    upsert<T extends output_lineUpsertArgs>(
      args: SelectSubset<T, output_lineUpsertArgs>
    ): Prisma__output_lineClient<output_lineGetPayload<T>>

    /**
     * Count the number of Output_lines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {output_lineCountArgs} args - Arguments to filter Output_lines to count.
     * @example
     * // Count the number of Output_lines
     * const count = await prisma.output_line.count({
     *   where: {
     *     // ... the filter for the Output_lines we want to count
     *   }
     * })
    **/
    count<T extends output_lineCountArgs>(
      args?: Subset<T, output_lineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Output_lineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Output_line.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Output_lineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Output_lineAggregateArgs>(args: Subset<T, Output_lineAggregateArgs>): Prisma.PrismaPromise<GetOutput_lineAggregateType<T>>

    /**
     * Group by Output_line.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Output_lineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Output_lineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Output_lineGroupByArgs['orderBy'] }
        : { orderBy?: Output_lineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Output_lineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOutput_lineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for output_line.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__output_lineClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    output<T extends outputArgs= {}>(args?: Subset<T, outputArgs>): Prisma__outputClient<outputGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * output_line base type for findUnique actions
   */
  export type output_lineFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the output_line
     */
    select?: output_lineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: output_lineInclude | null
    /**
     * Filter, which output_line to fetch.
     */
    where: output_lineWhereUniqueInput
  }

  /**
   * output_line findUnique
   */
  export interface output_lineFindUniqueArgs extends output_lineFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * output_line findUniqueOrThrow
   */
  export type output_lineFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the output_line
     */
    select?: output_lineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: output_lineInclude | null
    /**
     * Filter, which output_line to fetch.
     */
    where: output_lineWhereUniqueInput
  }


  /**
   * output_line base type for findFirst actions
   */
  export type output_lineFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the output_line
     */
    select?: output_lineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: output_lineInclude | null
    /**
     * Filter, which output_line to fetch.
     */
    where?: output_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_lines to fetch.
     */
    orderBy?: Enumerable<output_lineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for output_lines.
     */
    cursor?: output_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_lines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of output_lines.
     */
    distinct?: Enumerable<Output_lineScalarFieldEnum>
  }

  /**
   * output_line findFirst
   */
  export interface output_lineFindFirstArgs extends output_lineFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * output_line findFirstOrThrow
   */
  export type output_lineFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the output_line
     */
    select?: output_lineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: output_lineInclude | null
    /**
     * Filter, which output_line to fetch.
     */
    where?: output_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_lines to fetch.
     */
    orderBy?: Enumerable<output_lineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for output_lines.
     */
    cursor?: output_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_lines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of output_lines.
     */
    distinct?: Enumerable<Output_lineScalarFieldEnum>
  }


  /**
   * output_line findMany
   */
  export type output_lineFindManyArgs = {
    /**
     * Select specific fields to fetch from the output_line
     */
    select?: output_lineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: output_lineInclude | null
    /**
     * Filter, which output_lines to fetch.
     */
    where?: output_lineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of output_lines to fetch.
     */
    orderBy?: Enumerable<output_lineOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing output_lines.
     */
    cursor?: output_lineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` output_lines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` output_lines.
     */
    skip?: number
    distinct?: Enumerable<Output_lineScalarFieldEnum>
  }


  /**
   * output_line create
   */
  export type output_lineCreateArgs = {
    /**
     * Select specific fields to fetch from the output_line
     */
    select?: output_lineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: output_lineInclude | null
    /**
     * The data needed to create a output_line.
     */
    data: XOR<output_lineCreateInput, output_lineUncheckedCreateInput>
  }


  /**
   * output_line update
   */
  export type output_lineUpdateArgs = {
    /**
     * Select specific fields to fetch from the output_line
     */
    select?: output_lineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: output_lineInclude | null
    /**
     * The data needed to update a output_line.
     */
    data: XOR<output_lineUpdateInput, output_lineUncheckedUpdateInput>
    /**
     * Choose, which output_line to update.
     */
    where: output_lineWhereUniqueInput
  }


  /**
   * output_line updateMany
   */
  export type output_lineUpdateManyArgs = {
    /**
     * The data used to update output_lines.
     */
    data: XOR<output_lineUpdateManyMutationInput, output_lineUncheckedUpdateManyInput>
    /**
     * Filter which output_lines to update
     */
    where?: output_lineWhereInput
  }


  /**
   * output_line upsert
   */
  export type output_lineUpsertArgs = {
    /**
     * Select specific fields to fetch from the output_line
     */
    select?: output_lineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: output_lineInclude | null
    /**
     * The filter to search for the output_line to update in case it exists.
     */
    where: output_lineWhereUniqueInput
    /**
     * In case the output_line found by the `where` argument doesn't exist, create a new output_line with this data.
     */
    create: XOR<output_lineCreateInput, output_lineUncheckedCreateInput>
    /**
     * In case the output_line was found with the provided `where` argument, update it with this data.
     */
    update: XOR<output_lineUpdateInput, output_lineUncheckedUpdateInput>
  }


  /**
   * output_line delete
   */
  export type output_lineDeleteArgs = {
    /**
     * Select specific fields to fetch from the output_line
     */
    select?: output_lineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: output_lineInclude | null
    /**
     * Filter which output_line to delete.
     */
    where: output_lineWhereUniqueInput
  }


  /**
   * output_line deleteMany
   */
  export type output_lineDeleteManyArgs = {
    /**
     * Filter which output_lines to delete
     */
    where?: output_lineWhereInput
  }


  /**
   * output_line without action
   */
  export type output_lineArgs = {
    /**
     * Select specific fields to fetch from the output_line
     */
    select?: output_lineSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: output_lineInclude | null
  }



  /**
   * Model play_history
   */


  export type AggregatePlay_history = {
    _count: Play_historyCountAggregateOutputType | null
    _avg: Play_historyAvgAggregateOutputType | null
    _sum: Play_historySumAggregateOutputType | null
    _min: Play_historyMinAggregateOutputType | null
    _max: Play_historyMaxAggregateOutputType | null
  }

  export type Play_historyAvgAggregateOutputType = {
    duration: number | null
    current_time: number | null
  }

  export type Play_historySumAggregateOutputType = {
    duration: number | null
    current_time: number | null
  }

  export type Play_historyMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    duration: number | null
    current_time: number | null
    thumbnail: string | null
    file_id: string | null
    tv_id: string | null
    season_id: string | null
    episode_id: string | null
    movie_id: string | null
    member_id: string | null
  }

  export type Play_historyMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    duration: number | null
    current_time: number | null
    thumbnail: string | null
    file_id: string | null
    tv_id: string | null
    season_id: string | null
    episode_id: string | null
    movie_id: string | null
    member_id: string | null
  }

  export type Play_historyCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    duration: number
    current_time: number
    thumbnail: number
    file_id: number
    tv_id: number
    season_id: number
    episode_id: number
    movie_id: number
    member_id: number
    _all: number
  }


  export type Play_historyAvgAggregateInputType = {
    duration?: true
    current_time?: true
  }

  export type Play_historySumAggregateInputType = {
    duration?: true
    current_time?: true
  }

  export type Play_historyMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    duration?: true
    current_time?: true
    thumbnail?: true
    file_id?: true
    tv_id?: true
    season_id?: true
    episode_id?: true
    movie_id?: true
    member_id?: true
  }

  export type Play_historyMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    duration?: true
    current_time?: true
    thumbnail?: true
    file_id?: true
    tv_id?: true
    season_id?: true
    episode_id?: true
    movie_id?: true
    member_id?: true
  }

  export type Play_historyCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    duration?: true
    current_time?: true
    thumbnail?: true
    file_id?: true
    tv_id?: true
    season_id?: true
    episode_id?: true
    movie_id?: true
    member_id?: true
    _all?: true
  }

  export type Play_historyAggregateArgs = {
    /**
     * Filter which play_history to aggregate.
     */
    where?: play_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of play_histories to fetch.
     */
    orderBy?: Enumerable<play_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: play_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` play_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` play_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned play_histories
    **/
    _count?: true | Play_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Play_historyAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Play_historySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Play_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Play_historyMaxAggregateInputType
  }

  export type GetPlay_historyAggregateType<T extends Play_historyAggregateArgs> = {
        [P in keyof T & keyof AggregatePlay_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePlay_history[P]>
      : GetScalarType<T[P], AggregatePlay_history[P]>
  }




  export type Play_historyGroupByArgs = {
    where?: play_historyWhereInput
    orderBy?: Enumerable<play_historyOrderByWithAggregationInput>
    by: Play_historyScalarFieldEnum[]
    having?: play_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Play_historyCountAggregateInputType | true
    _avg?: Play_historyAvgAggregateInputType
    _sum?: Play_historySumAggregateInputType
    _min?: Play_historyMinAggregateInputType
    _max?: Play_historyMaxAggregateInputType
  }


  export type Play_historyGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    duration: number | null
    current_time: number | null
    thumbnail: string | null
    file_id: string | null
    tv_id: string | null
    season_id: string | null
    episode_id: string | null
    movie_id: string | null
    member_id: string
    _count: Play_historyCountAggregateOutputType | null
    _avg: Play_historyAvgAggregateOutputType | null
    _sum: Play_historySumAggregateOutputType | null
    _min: Play_historyMinAggregateOutputType | null
    _max: Play_historyMaxAggregateOutputType | null
  }

  type GetPlay_historyGroupByPayload<T extends Play_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Play_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Play_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Play_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Play_historyGroupByOutputType[P]>
        }
      >
    >


  export type play_historySelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    duration?: boolean
    current_time?: boolean
    thumbnail?: boolean
    file_id?: boolean
    tv_id?: boolean
    season_id?: boolean
    episode_id?: boolean
    movie_id?: boolean
    member_id?: boolean
    tv?: boolean | tvArgs
    season?: boolean | seasonArgs
    episode?: boolean | episodeArgs
    movie?: boolean | movieArgs
    member?: boolean | memberArgs
  }


  export type play_historyInclude = {
    tv?: boolean | tvArgs
    season?: boolean | seasonArgs
    episode?: boolean | episodeArgs
    movie?: boolean | movieArgs
    member?: boolean | memberArgs
  }

  export type play_historyGetPayload<S extends boolean | null | undefined | play_historyArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? play_history :
    S extends undefined ? never :
    S extends { include: any } & (play_historyArgs | play_historyFindManyArgs)
    ? play_history  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tv' ? tvGetPayload<S['include'][P]> | null :
        P extends 'season' ? seasonGetPayload<S['include'][P]> | null :
        P extends 'episode' ? episodeGetPayload<S['include'][P]> | null :
        P extends 'movie' ? movieGetPayload<S['include'][P]> | null :
        P extends 'member' ? memberGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (play_historyArgs | play_historyFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tv' ? tvGetPayload<S['select'][P]> | null :
        P extends 'season' ? seasonGetPayload<S['select'][P]> | null :
        P extends 'episode' ? episodeGetPayload<S['select'][P]> | null :
        P extends 'movie' ? movieGetPayload<S['select'][P]> | null :
        P extends 'member' ? memberGetPayload<S['select'][P]> :  P extends keyof play_history ? play_history[P] : never
  } 
      : play_history


  type play_historyCountArgs = 
    Omit<play_historyFindManyArgs, 'select' | 'include'> & {
      select?: Play_historyCountAggregateInputType | true
    }

  export interface play_historyDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Play_history that matches the filter.
     * @param {play_historyFindUniqueArgs} args - Arguments to find a Play_history
     * @example
     * // Get one Play_history
     * const play_history = await prisma.play_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends play_historyFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, play_historyFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'play_history'> extends True ? Prisma__play_historyClient<play_historyGetPayload<T>> : Prisma__play_historyClient<play_historyGetPayload<T> | null, null>

    /**
     * Find one Play_history that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {play_historyFindUniqueOrThrowArgs} args - Arguments to find a Play_history
     * @example
     * // Get one Play_history
     * const play_history = await prisma.play_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends play_historyFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, play_historyFindUniqueOrThrowArgs>
    ): Prisma__play_historyClient<play_historyGetPayload<T>>

    /**
     * Find the first Play_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {play_historyFindFirstArgs} args - Arguments to find a Play_history
     * @example
     * // Get one Play_history
     * const play_history = await prisma.play_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends play_historyFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, play_historyFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'play_history'> extends True ? Prisma__play_historyClient<play_historyGetPayload<T>> : Prisma__play_historyClient<play_historyGetPayload<T> | null, null>

    /**
     * Find the first Play_history that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {play_historyFindFirstOrThrowArgs} args - Arguments to find a Play_history
     * @example
     * // Get one Play_history
     * const play_history = await prisma.play_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends play_historyFindFirstOrThrowArgs>(
      args?: SelectSubset<T, play_historyFindFirstOrThrowArgs>
    ): Prisma__play_historyClient<play_historyGetPayload<T>>

    /**
     * Find zero or more Play_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {play_historyFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Play_histories
     * const play_histories = await prisma.play_history.findMany()
     * 
     * // Get first 10 Play_histories
     * const play_histories = await prisma.play_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const play_historyWithIdOnly = await prisma.play_history.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends play_historyFindManyArgs>(
      args?: SelectSubset<T, play_historyFindManyArgs>
    ): Prisma.PrismaPromise<Array<play_historyGetPayload<T>>>

    /**
     * Create a Play_history.
     * @param {play_historyCreateArgs} args - Arguments to create a Play_history.
     * @example
     * // Create one Play_history
     * const Play_history = await prisma.play_history.create({
     *   data: {
     *     // ... data to create a Play_history
     *   }
     * })
     * 
    **/
    create<T extends play_historyCreateArgs>(
      args: SelectSubset<T, play_historyCreateArgs>
    ): Prisma__play_historyClient<play_historyGetPayload<T>>

    /**
     * Delete a Play_history.
     * @param {play_historyDeleteArgs} args - Arguments to delete one Play_history.
     * @example
     * // Delete one Play_history
     * const Play_history = await prisma.play_history.delete({
     *   where: {
     *     // ... filter to delete one Play_history
     *   }
     * })
     * 
    **/
    delete<T extends play_historyDeleteArgs>(
      args: SelectSubset<T, play_historyDeleteArgs>
    ): Prisma__play_historyClient<play_historyGetPayload<T>>

    /**
     * Update one Play_history.
     * @param {play_historyUpdateArgs} args - Arguments to update one Play_history.
     * @example
     * // Update one Play_history
     * const play_history = await prisma.play_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends play_historyUpdateArgs>(
      args: SelectSubset<T, play_historyUpdateArgs>
    ): Prisma__play_historyClient<play_historyGetPayload<T>>

    /**
     * Delete zero or more Play_histories.
     * @param {play_historyDeleteManyArgs} args - Arguments to filter Play_histories to delete.
     * @example
     * // Delete a few Play_histories
     * const { count } = await prisma.play_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends play_historyDeleteManyArgs>(
      args?: SelectSubset<T, play_historyDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Play_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {play_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Play_histories
     * const play_history = await prisma.play_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends play_historyUpdateManyArgs>(
      args: SelectSubset<T, play_historyUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Play_history.
     * @param {play_historyUpsertArgs} args - Arguments to update or create a Play_history.
     * @example
     * // Update or create a Play_history
     * const play_history = await prisma.play_history.upsert({
     *   create: {
     *     // ... data to create a Play_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Play_history we want to update
     *   }
     * })
    **/
    upsert<T extends play_historyUpsertArgs>(
      args: SelectSubset<T, play_historyUpsertArgs>
    ): Prisma__play_historyClient<play_historyGetPayload<T>>

    /**
     * Count the number of Play_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {play_historyCountArgs} args - Arguments to filter Play_histories to count.
     * @example
     * // Count the number of Play_histories
     * const count = await prisma.play_history.count({
     *   where: {
     *     // ... the filter for the Play_histories we want to count
     *   }
     * })
    **/
    count<T extends play_historyCountArgs>(
      args?: Subset<T, play_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Play_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Play_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Play_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Play_historyAggregateArgs>(args: Subset<T, Play_historyAggregateArgs>): Prisma.PrismaPromise<GetPlay_historyAggregateType<T>>

    /**
     * Group by Play_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Play_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Play_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Play_historyGroupByArgs['orderBy'] }
        : { orderBy?: Play_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Play_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPlay_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for play_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__play_historyClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tv<T extends tvArgs= {}>(args?: Subset<T, tvArgs>): Prisma__tvClient<tvGetPayload<T> | Null>;

    season<T extends seasonArgs= {}>(args?: Subset<T, seasonArgs>): Prisma__seasonClient<seasonGetPayload<T> | Null>;

    episode<T extends episodeArgs= {}>(args?: Subset<T, episodeArgs>): Prisma__episodeClient<episodeGetPayload<T> | Null>;

    movie<T extends movieArgs= {}>(args?: Subset<T, movieArgs>): Prisma__movieClient<movieGetPayload<T> | Null>;

    member<T extends memberArgs= {}>(args?: Subset<T, memberArgs>): Prisma__memberClient<memberGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * play_history base type for findUnique actions
   */
  export type play_historyFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    /**
     * Filter, which play_history to fetch.
     */
    where: play_historyWhereUniqueInput
  }

  /**
   * play_history findUnique
   */
  export interface play_historyFindUniqueArgs extends play_historyFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * play_history findUniqueOrThrow
   */
  export type play_historyFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    /**
     * Filter, which play_history to fetch.
     */
    where: play_historyWhereUniqueInput
  }


  /**
   * play_history base type for findFirst actions
   */
  export type play_historyFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    /**
     * Filter, which play_history to fetch.
     */
    where?: play_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of play_histories to fetch.
     */
    orderBy?: Enumerable<play_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for play_histories.
     */
    cursor?: play_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` play_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` play_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of play_histories.
     */
    distinct?: Enumerable<Play_historyScalarFieldEnum>
  }

  /**
   * play_history findFirst
   */
  export interface play_historyFindFirstArgs extends play_historyFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * play_history findFirstOrThrow
   */
  export type play_historyFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    /**
     * Filter, which play_history to fetch.
     */
    where?: play_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of play_histories to fetch.
     */
    orderBy?: Enumerable<play_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for play_histories.
     */
    cursor?: play_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` play_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` play_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of play_histories.
     */
    distinct?: Enumerable<Play_historyScalarFieldEnum>
  }


  /**
   * play_history findMany
   */
  export type play_historyFindManyArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    /**
     * Filter, which play_histories to fetch.
     */
    where?: play_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of play_histories to fetch.
     */
    orderBy?: Enumerable<play_historyOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing play_histories.
     */
    cursor?: play_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` play_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` play_histories.
     */
    skip?: number
    distinct?: Enumerable<Play_historyScalarFieldEnum>
  }


  /**
   * play_history create
   */
  export type play_historyCreateArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    /**
     * The data needed to create a play_history.
     */
    data: XOR<play_historyCreateInput, play_historyUncheckedCreateInput>
  }


  /**
   * play_history update
   */
  export type play_historyUpdateArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    /**
     * The data needed to update a play_history.
     */
    data: XOR<play_historyUpdateInput, play_historyUncheckedUpdateInput>
    /**
     * Choose, which play_history to update.
     */
    where: play_historyWhereUniqueInput
  }


  /**
   * play_history updateMany
   */
  export type play_historyUpdateManyArgs = {
    /**
     * The data used to update play_histories.
     */
    data: XOR<play_historyUpdateManyMutationInput, play_historyUncheckedUpdateManyInput>
    /**
     * Filter which play_histories to update
     */
    where?: play_historyWhereInput
  }


  /**
   * play_history upsert
   */
  export type play_historyUpsertArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    /**
     * The filter to search for the play_history to update in case it exists.
     */
    where: play_historyWhereUniqueInput
    /**
     * In case the play_history found by the `where` argument doesn't exist, create a new play_history with this data.
     */
    create: XOR<play_historyCreateInput, play_historyUncheckedCreateInput>
    /**
     * In case the play_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<play_historyUpdateInput, play_historyUncheckedUpdateInput>
  }


  /**
   * play_history delete
   */
  export type play_historyDeleteArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    /**
     * Filter which play_history to delete.
     */
    where: play_historyWhereUniqueInput
  }


  /**
   * play_history deleteMany
   */
  export type play_historyDeleteManyArgs = {
    /**
     * Filter which play_histories to delete
     */
    where?: play_historyWhereInput
  }


  /**
   * play_history without action
   */
  export type play_historyArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
  }



  /**
   * Model tv_profile_quick
   */


  export type AggregateTv_profile_quick = {
    _count: Tv_profile_quickCountAggregateOutputType | null
    _min: Tv_profile_quickMinAggregateOutputType | null
    _max: Tv_profile_quickMaxAggregateOutputType | null
  }

  export type Tv_profile_quickMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    name: string | null
    tv_profile_id: string | null
  }

  export type Tv_profile_quickMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    name: string | null
    tv_profile_id: string | null
  }

  export type Tv_profile_quickCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    name: number
    tv_profile_id: number
    _all: number
  }


  export type Tv_profile_quickMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    tv_profile_id?: true
  }

  export type Tv_profile_quickMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    tv_profile_id?: true
  }

  export type Tv_profile_quickCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    tv_profile_id?: true
    _all?: true
  }

  export type Tv_profile_quickAggregateArgs = {
    /**
     * Filter which tv_profile_quick to aggregate.
     */
    where?: tv_profile_quickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tv_profile_quicks to fetch.
     */
    orderBy?: Enumerable<tv_profile_quickOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tv_profile_quickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tv_profile_quicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tv_profile_quicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tv_profile_quicks
    **/
    _count?: true | Tv_profile_quickCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tv_profile_quickMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tv_profile_quickMaxAggregateInputType
  }

  export type GetTv_profile_quickAggregateType<T extends Tv_profile_quickAggregateArgs> = {
        [P in keyof T & keyof AggregateTv_profile_quick]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTv_profile_quick[P]>
      : GetScalarType<T[P], AggregateTv_profile_quick[P]>
  }




  export type Tv_profile_quickGroupByArgs = {
    where?: tv_profile_quickWhereInput
    orderBy?: Enumerable<tv_profile_quickOrderByWithAggregationInput>
    by: Tv_profile_quickScalarFieldEnum[]
    having?: tv_profile_quickScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tv_profile_quickCountAggregateInputType | true
    _min?: Tv_profile_quickMinAggregateInputType
    _max?: Tv_profile_quickMaxAggregateInputType
  }


  export type Tv_profile_quickGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    name: string
    tv_profile_id: string
    _count: Tv_profile_quickCountAggregateOutputType | null
    _min: Tv_profile_quickMinAggregateOutputType | null
    _max: Tv_profile_quickMaxAggregateOutputType | null
  }

  type GetTv_profile_quickGroupByPayload<T extends Tv_profile_quickGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tv_profile_quickGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tv_profile_quickGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tv_profile_quickGroupByOutputType[P]>
            : GetScalarType<T[P], Tv_profile_quickGroupByOutputType[P]>
        }
      >
    >


  export type tv_profile_quickSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    name?: boolean
    tv_profile_id?: boolean
    tv_profile?: boolean | tv_profileArgs
  }


  export type tv_profile_quickInclude = {
    tv_profile?: boolean | tv_profileArgs
  }

  export type tv_profile_quickGetPayload<S extends boolean | null | undefined | tv_profile_quickArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tv_profile_quick :
    S extends undefined ? never :
    S extends { include: any } & (tv_profile_quickArgs | tv_profile_quickFindManyArgs)
    ? tv_profile_quick  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tv_profile' ? tv_profileGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (tv_profile_quickArgs | tv_profile_quickFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tv_profile' ? tv_profileGetPayload<S['select'][P]> :  P extends keyof tv_profile_quick ? tv_profile_quick[P] : never
  } 
      : tv_profile_quick


  type tv_profile_quickCountArgs = 
    Omit<tv_profile_quickFindManyArgs, 'select' | 'include'> & {
      select?: Tv_profile_quickCountAggregateInputType | true
    }

  export interface tv_profile_quickDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tv_profile_quick that matches the filter.
     * @param {tv_profile_quickFindUniqueArgs} args - Arguments to find a Tv_profile_quick
     * @example
     * // Get one Tv_profile_quick
     * const tv_profile_quick = await prisma.tv_profile_quick.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tv_profile_quickFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tv_profile_quickFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tv_profile_quick'> extends True ? Prisma__tv_profile_quickClient<tv_profile_quickGetPayload<T>> : Prisma__tv_profile_quickClient<tv_profile_quickGetPayload<T> | null, null>

    /**
     * Find one Tv_profile_quick that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tv_profile_quickFindUniqueOrThrowArgs} args - Arguments to find a Tv_profile_quick
     * @example
     * // Get one Tv_profile_quick
     * const tv_profile_quick = await prisma.tv_profile_quick.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tv_profile_quickFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tv_profile_quickFindUniqueOrThrowArgs>
    ): Prisma__tv_profile_quickClient<tv_profile_quickGetPayload<T>>

    /**
     * Find the first Tv_profile_quick that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tv_profile_quickFindFirstArgs} args - Arguments to find a Tv_profile_quick
     * @example
     * // Get one Tv_profile_quick
     * const tv_profile_quick = await prisma.tv_profile_quick.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tv_profile_quickFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tv_profile_quickFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tv_profile_quick'> extends True ? Prisma__tv_profile_quickClient<tv_profile_quickGetPayload<T>> : Prisma__tv_profile_quickClient<tv_profile_quickGetPayload<T> | null, null>

    /**
     * Find the first Tv_profile_quick that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tv_profile_quickFindFirstOrThrowArgs} args - Arguments to find a Tv_profile_quick
     * @example
     * // Get one Tv_profile_quick
     * const tv_profile_quick = await prisma.tv_profile_quick.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tv_profile_quickFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tv_profile_quickFindFirstOrThrowArgs>
    ): Prisma__tv_profile_quickClient<tv_profile_quickGetPayload<T>>

    /**
     * Find zero or more Tv_profile_quicks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tv_profile_quickFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tv_profile_quicks
     * const tv_profile_quicks = await prisma.tv_profile_quick.findMany()
     * 
     * // Get first 10 Tv_profile_quicks
     * const tv_profile_quicks = await prisma.tv_profile_quick.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tv_profile_quickWithIdOnly = await prisma.tv_profile_quick.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tv_profile_quickFindManyArgs>(
      args?: SelectSubset<T, tv_profile_quickFindManyArgs>
    ): Prisma.PrismaPromise<Array<tv_profile_quickGetPayload<T>>>

    /**
     * Create a Tv_profile_quick.
     * @param {tv_profile_quickCreateArgs} args - Arguments to create a Tv_profile_quick.
     * @example
     * // Create one Tv_profile_quick
     * const Tv_profile_quick = await prisma.tv_profile_quick.create({
     *   data: {
     *     // ... data to create a Tv_profile_quick
     *   }
     * })
     * 
    **/
    create<T extends tv_profile_quickCreateArgs>(
      args: SelectSubset<T, tv_profile_quickCreateArgs>
    ): Prisma__tv_profile_quickClient<tv_profile_quickGetPayload<T>>

    /**
     * Delete a Tv_profile_quick.
     * @param {tv_profile_quickDeleteArgs} args - Arguments to delete one Tv_profile_quick.
     * @example
     * // Delete one Tv_profile_quick
     * const Tv_profile_quick = await prisma.tv_profile_quick.delete({
     *   where: {
     *     // ... filter to delete one Tv_profile_quick
     *   }
     * })
     * 
    **/
    delete<T extends tv_profile_quickDeleteArgs>(
      args: SelectSubset<T, tv_profile_quickDeleteArgs>
    ): Prisma__tv_profile_quickClient<tv_profile_quickGetPayload<T>>

    /**
     * Update one Tv_profile_quick.
     * @param {tv_profile_quickUpdateArgs} args - Arguments to update one Tv_profile_quick.
     * @example
     * // Update one Tv_profile_quick
     * const tv_profile_quick = await prisma.tv_profile_quick.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tv_profile_quickUpdateArgs>(
      args: SelectSubset<T, tv_profile_quickUpdateArgs>
    ): Prisma__tv_profile_quickClient<tv_profile_quickGetPayload<T>>

    /**
     * Delete zero or more Tv_profile_quicks.
     * @param {tv_profile_quickDeleteManyArgs} args - Arguments to filter Tv_profile_quicks to delete.
     * @example
     * // Delete a few Tv_profile_quicks
     * const { count } = await prisma.tv_profile_quick.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tv_profile_quickDeleteManyArgs>(
      args?: SelectSubset<T, tv_profile_quickDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tv_profile_quicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tv_profile_quickUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tv_profile_quicks
     * const tv_profile_quick = await prisma.tv_profile_quick.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tv_profile_quickUpdateManyArgs>(
      args: SelectSubset<T, tv_profile_quickUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tv_profile_quick.
     * @param {tv_profile_quickUpsertArgs} args - Arguments to update or create a Tv_profile_quick.
     * @example
     * // Update or create a Tv_profile_quick
     * const tv_profile_quick = await prisma.tv_profile_quick.upsert({
     *   create: {
     *     // ... data to create a Tv_profile_quick
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tv_profile_quick we want to update
     *   }
     * })
    **/
    upsert<T extends tv_profile_quickUpsertArgs>(
      args: SelectSubset<T, tv_profile_quickUpsertArgs>
    ): Prisma__tv_profile_quickClient<tv_profile_quickGetPayload<T>>

    /**
     * Count the number of Tv_profile_quicks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tv_profile_quickCountArgs} args - Arguments to filter Tv_profile_quicks to count.
     * @example
     * // Count the number of Tv_profile_quicks
     * const count = await prisma.tv_profile_quick.count({
     *   where: {
     *     // ... the filter for the Tv_profile_quicks we want to count
     *   }
     * })
    **/
    count<T extends tv_profile_quickCountArgs>(
      args?: Subset<T, tv_profile_quickCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tv_profile_quickCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tv_profile_quick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tv_profile_quickAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tv_profile_quickAggregateArgs>(args: Subset<T, Tv_profile_quickAggregateArgs>): Prisma.PrismaPromise<GetTv_profile_quickAggregateType<T>>

    /**
     * Group by Tv_profile_quick.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tv_profile_quickGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tv_profile_quickGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tv_profile_quickGroupByArgs['orderBy'] }
        : { orderBy?: Tv_profile_quickGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tv_profile_quickGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTv_profile_quickGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tv_profile_quick.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tv_profile_quickClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tv_profile<T extends tv_profileArgs= {}>(args?: Subset<T, tv_profileArgs>): Prisma__tv_profileClient<tv_profileGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tv_profile_quick base type for findUnique actions
   */
  export type tv_profile_quickFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tv_profile_quick
     */
    select?: tv_profile_quickSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profile_quickInclude | null
    /**
     * Filter, which tv_profile_quick to fetch.
     */
    where: tv_profile_quickWhereUniqueInput
  }

  /**
   * tv_profile_quick findUnique
   */
  export interface tv_profile_quickFindUniqueArgs extends tv_profile_quickFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tv_profile_quick findUniqueOrThrow
   */
  export type tv_profile_quickFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tv_profile_quick
     */
    select?: tv_profile_quickSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profile_quickInclude | null
    /**
     * Filter, which tv_profile_quick to fetch.
     */
    where: tv_profile_quickWhereUniqueInput
  }


  /**
   * tv_profile_quick base type for findFirst actions
   */
  export type tv_profile_quickFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tv_profile_quick
     */
    select?: tv_profile_quickSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profile_quickInclude | null
    /**
     * Filter, which tv_profile_quick to fetch.
     */
    where?: tv_profile_quickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tv_profile_quicks to fetch.
     */
    orderBy?: Enumerable<tv_profile_quickOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tv_profile_quicks.
     */
    cursor?: tv_profile_quickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tv_profile_quicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tv_profile_quicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tv_profile_quicks.
     */
    distinct?: Enumerable<Tv_profile_quickScalarFieldEnum>
  }

  /**
   * tv_profile_quick findFirst
   */
  export interface tv_profile_quickFindFirstArgs extends tv_profile_quickFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tv_profile_quick findFirstOrThrow
   */
  export type tv_profile_quickFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tv_profile_quick
     */
    select?: tv_profile_quickSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profile_quickInclude | null
    /**
     * Filter, which tv_profile_quick to fetch.
     */
    where?: tv_profile_quickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tv_profile_quicks to fetch.
     */
    orderBy?: Enumerable<tv_profile_quickOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tv_profile_quicks.
     */
    cursor?: tv_profile_quickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tv_profile_quicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tv_profile_quicks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tv_profile_quicks.
     */
    distinct?: Enumerable<Tv_profile_quickScalarFieldEnum>
  }


  /**
   * tv_profile_quick findMany
   */
  export type tv_profile_quickFindManyArgs = {
    /**
     * Select specific fields to fetch from the tv_profile_quick
     */
    select?: tv_profile_quickSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profile_quickInclude | null
    /**
     * Filter, which tv_profile_quicks to fetch.
     */
    where?: tv_profile_quickWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tv_profile_quicks to fetch.
     */
    orderBy?: Enumerable<tv_profile_quickOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tv_profile_quicks.
     */
    cursor?: tv_profile_quickWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tv_profile_quicks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tv_profile_quicks.
     */
    skip?: number
    distinct?: Enumerable<Tv_profile_quickScalarFieldEnum>
  }


  /**
   * tv_profile_quick create
   */
  export type tv_profile_quickCreateArgs = {
    /**
     * Select specific fields to fetch from the tv_profile_quick
     */
    select?: tv_profile_quickSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profile_quickInclude | null
    /**
     * The data needed to create a tv_profile_quick.
     */
    data: XOR<tv_profile_quickCreateInput, tv_profile_quickUncheckedCreateInput>
  }


  /**
   * tv_profile_quick update
   */
  export type tv_profile_quickUpdateArgs = {
    /**
     * Select specific fields to fetch from the tv_profile_quick
     */
    select?: tv_profile_quickSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profile_quickInclude | null
    /**
     * The data needed to update a tv_profile_quick.
     */
    data: XOR<tv_profile_quickUpdateInput, tv_profile_quickUncheckedUpdateInput>
    /**
     * Choose, which tv_profile_quick to update.
     */
    where: tv_profile_quickWhereUniqueInput
  }


  /**
   * tv_profile_quick updateMany
   */
  export type tv_profile_quickUpdateManyArgs = {
    /**
     * The data used to update tv_profile_quicks.
     */
    data: XOR<tv_profile_quickUpdateManyMutationInput, tv_profile_quickUncheckedUpdateManyInput>
    /**
     * Filter which tv_profile_quicks to update
     */
    where?: tv_profile_quickWhereInput
  }


  /**
   * tv_profile_quick upsert
   */
  export type tv_profile_quickUpsertArgs = {
    /**
     * Select specific fields to fetch from the tv_profile_quick
     */
    select?: tv_profile_quickSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profile_quickInclude | null
    /**
     * The filter to search for the tv_profile_quick to update in case it exists.
     */
    where: tv_profile_quickWhereUniqueInput
    /**
     * In case the tv_profile_quick found by the `where` argument doesn't exist, create a new tv_profile_quick with this data.
     */
    create: XOR<tv_profile_quickCreateInput, tv_profile_quickUncheckedCreateInput>
    /**
     * In case the tv_profile_quick was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tv_profile_quickUpdateInput, tv_profile_quickUncheckedUpdateInput>
  }


  /**
   * tv_profile_quick delete
   */
  export type tv_profile_quickDeleteArgs = {
    /**
     * Select specific fields to fetch from the tv_profile_quick
     */
    select?: tv_profile_quickSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profile_quickInclude | null
    /**
     * Filter which tv_profile_quick to delete.
     */
    where: tv_profile_quickWhereUniqueInput
  }


  /**
   * tv_profile_quick deleteMany
   */
  export type tv_profile_quickDeleteManyArgs = {
    /**
     * Filter which tv_profile_quicks to delete
     */
    where?: tv_profile_quickWhereInput
  }


  /**
   * tv_profile_quick without action
   */
  export type tv_profile_quickArgs = {
    /**
     * Select specific fields to fetch from the tv_profile_quick
     */
    select?: tv_profile_quickSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tv_profile_quickInclude | null
  }



  /**
   * Model shared_file
   */


  export type AggregateShared_file = {
    _count: Shared_fileCountAggregateOutputType | null
    _min: Shared_fileMinAggregateOutputType | null
    _max: Shared_fileMaxAggregateOutputType | null
  }

  export type Shared_fileMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    title: string | null
    url: string | null
    user_id: string | null
  }

  export type Shared_fileMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    title: string | null
    url: string | null
    user_id: string | null
  }

  export type Shared_fileCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    title: number
    url: number
    user_id: number
    _all: number
  }


  export type Shared_fileMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    title?: true
    url?: true
    user_id?: true
  }

  export type Shared_fileMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    title?: true
    url?: true
    user_id?: true
  }

  export type Shared_fileCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    title?: true
    url?: true
    user_id?: true
    _all?: true
  }

  export type Shared_fileAggregateArgs = {
    /**
     * Filter which shared_file to aggregate.
     */
    where?: shared_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shared_files to fetch.
     */
    orderBy?: Enumerable<shared_fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shared_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shared_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shared_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shared_files
    **/
    _count?: true | Shared_fileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Shared_fileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Shared_fileMaxAggregateInputType
  }

  export type GetShared_fileAggregateType<T extends Shared_fileAggregateArgs> = {
        [P in keyof T & keyof AggregateShared_file]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShared_file[P]>
      : GetScalarType<T[P], AggregateShared_file[P]>
  }




  export type Shared_fileGroupByArgs = {
    where?: shared_fileWhereInput
    orderBy?: Enumerable<shared_fileOrderByWithAggregationInput>
    by: Shared_fileScalarFieldEnum[]
    having?: shared_fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Shared_fileCountAggregateInputType | true
    _min?: Shared_fileMinAggregateInputType
    _max?: Shared_fileMaxAggregateInputType
  }


  export type Shared_fileGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    title: string | null
    url: string
    user_id: string
    _count: Shared_fileCountAggregateOutputType | null
    _min: Shared_fileMinAggregateOutputType | null
    _max: Shared_fileMaxAggregateOutputType | null
  }

  type GetShared_fileGroupByPayload<T extends Shared_fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Shared_fileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Shared_fileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Shared_fileGroupByOutputType[P]>
            : GetScalarType<T[P], Shared_fileGroupByOutputType[P]>
        }
      >
    >


  export type shared_fileSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    title?: boolean
    url?: boolean
    user_id?: boolean
    user?: boolean | userArgs
  }


  export type shared_fileInclude = {
    user?: boolean | userArgs
  }

  export type shared_fileGetPayload<S extends boolean | null | undefined | shared_fileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? shared_file :
    S extends undefined ? never :
    S extends { include: any } & (shared_fileArgs | shared_fileFindManyArgs)
    ? shared_file  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (shared_fileArgs | shared_fileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof shared_file ? shared_file[P] : never
  } 
      : shared_file


  type shared_fileCountArgs = 
    Omit<shared_fileFindManyArgs, 'select' | 'include'> & {
      select?: Shared_fileCountAggregateInputType | true
    }

  export interface shared_fileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Shared_file that matches the filter.
     * @param {shared_fileFindUniqueArgs} args - Arguments to find a Shared_file
     * @example
     * // Get one Shared_file
     * const shared_file = await prisma.shared_file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends shared_fileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, shared_fileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'shared_file'> extends True ? Prisma__shared_fileClient<shared_fileGetPayload<T>> : Prisma__shared_fileClient<shared_fileGetPayload<T> | null, null>

    /**
     * Find one Shared_file that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {shared_fileFindUniqueOrThrowArgs} args - Arguments to find a Shared_file
     * @example
     * // Get one Shared_file
     * const shared_file = await prisma.shared_file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends shared_fileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, shared_fileFindUniqueOrThrowArgs>
    ): Prisma__shared_fileClient<shared_fileGetPayload<T>>

    /**
     * Find the first Shared_file that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shared_fileFindFirstArgs} args - Arguments to find a Shared_file
     * @example
     * // Get one Shared_file
     * const shared_file = await prisma.shared_file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends shared_fileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, shared_fileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'shared_file'> extends True ? Prisma__shared_fileClient<shared_fileGetPayload<T>> : Prisma__shared_fileClient<shared_fileGetPayload<T> | null, null>

    /**
     * Find the first Shared_file that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shared_fileFindFirstOrThrowArgs} args - Arguments to find a Shared_file
     * @example
     * // Get one Shared_file
     * const shared_file = await prisma.shared_file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends shared_fileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, shared_fileFindFirstOrThrowArgs>
    ): Prisma__shared_fileClient<shared_fileGetPayload<T>>

    /**
     * Find zero or more Shared_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shared_fileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shared_files
     * const shared_files = await prisma.shared_file.findMany()
     * 
     * // Get first 10 Shared_files
     * const shared_files = await prisma.shared_file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shared_fileWithIdOnly = await prisma.shared_file.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends shared_fileFindManyArgs>(
      args?: SelectSubset<T, shared_fileFindManyArgs>
    ): Prisma.PrismaPromise<Array<shared_fileGetPayload<T>>>

    /**
     * Create a Shared_file.
     * @param {shared_fileCreateArgs} args - Arguments to create a Shared_file.
     * @example
     * // Create one Shared_file
     * const Shared_file = await prisma.shared_file.create({
     *   data: {
     *     // ... data to create a Shared_file
     *   }
     * })
     * 
    **/
    create<T extends shared_fileCreateArgs>(
      args: SelectSubset<T, shared_fileCreateArgs>
    ): Prisma__shared_fileClient<shared_fileGetPayload<T>>

    /**
     * Delete a Shared_file.
     * @param {shared_fileDeleteArgs} args - Arguments to delete one Shared_file.
     * @example
     * // Delete one Shared_file
     * const Shared_file = await prisma.shared_file.delete({
     *   where: {
     *     // ... filter to delete one Shared_file
     *   }
     * })
     * 
    **/
    delete<T extends shared_fileDeleteArgs>(
      args: SelectSubset<T, shared_fileDeleteArgs>
    ): Prisma__shared_fileClient<shared_fileGetPayload<T>>

    /**
     * Update one Shared_file.
     * @param {shared_fileUpdateArgs} args - Arguments to update one Shared_file.
     * @example
     * // Update one Shared_file
     * const shared_file = await prisma.shared_file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends shared_fileUpdateArgs>(
      args: SelectSubset<T, shared_fileUpdateArgs>
    ): Prisma__shared_fileClient<shared_fileGetPayload<T>>

    /**
     * Delete zero or more Shared_files.
     * @param {shared_fileDeleteManyArgs} args - Arguments to filter Shared_files to delete.
     * @example
     * // Delete a few Shared_files
     * const { count } = await prisma.shared_file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends shared_fileDeleteManyArgs>(
      args?: SelectSubset<T, shared_fileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shared_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shared_fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shared_files
     * const shared_file = await prisma.shared_file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends shared_fileUpdateManyArgs>(
      args: SelectSubset<T, shared_fileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shared_file.
     * @param {shared_fileUpsertArgs} args - Arguments to update or create a Shared_file.
     * @example
     * // Update or create a Shared_file
     * const shared_file = await prisma.shared_file.upsert({
     *   create: {
     *     // ... data to create a Shared_file
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shared_file we want to update
     *   }
     * })
    **/
    upsert<T extends shared_fileUpsertArgs>(
      args: SelectSubset<T, shared_fileUpsertArgs>
    ): Prisma__shared_fileClient<shared_fileGetPayload<T>>

    /**
     * Count the number of Shared_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shared_fileCountArgs} args - Arguments to filter Shared_files to count.
     * @example
     * // Count the number of Shared_files
     * const count = await prisma.shared_file.count({
     *   where: {
     *     // ... the filter for the Shared_files we want to count
     *   }
     * })
    **/
    count<T extends shared_fileCountArgs>(
      args?: Subset<T, shared_fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Shared_fileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shared_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shared_fileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Shared_fileAggregateArgs>(args: Subset<T, Shared_fileAggregateArgs>): Prisma.PrismaPromise<GetShared_fileAggregateType<T>>

    /**
     * Group by Shared_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shared_fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Shared_fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Shared_fileGroupByArgs['orderBy'] }
        : { orderBy?: Shared_fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Shared_fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShared_fileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for shared_file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__shared_fileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * shared_file base type for findUnique actions
   */
  export type shared_fileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the shared_file
     */
    select?: shared_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_fileInclude | null
    /**
     * Filter, which shared_file to fetch.
     */
    where: shared_fileWhereUniqueInput
  }

  /**
   * shared_file findUnique
   */
  export interface shared_fileFindUniqueArgs extends shared_fileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * shared_file findUniqueOrThrow
   */
  export type shared_fileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the shared_file
     */
    select?: shared_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_fileInclude | null
    /**
     * Filter, which shared_file to fetch.
     */
    where: shared_fileWhereUniqueInput
  }


  /**
   * shared_file base type for findFirst actions
   */
  export type shared_fileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the shared_file
     */
    select?: shared_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_fileInclude | null
    /**
     * Filter, which shared_file to fetch.
     */
    where?: shared_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shared_files to fetch.
     */
    orderBy?: Enumerable<shared_fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shared_files.
     */
    cursor?: shared_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shared_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shared_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shared_files.
     */
    distinct?: Enumerable<Shared_fileScalarFieldEnum>
  }

  /**
   * shared_file findFirst
   */
  export interface shared_fileFindFirstArgs extends shared_fileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * shared_file findFirstOrThrow
   */
  export type shared_fileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the shared_file
     */
    select?: shared_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_fileInclude | null
    /**
     * Filter, which shared_file to fetch.
     */
    where?: shared_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shared_files to fetch.
     */
    orderBy?: Enumerable<shared_fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shared_files.
     */
    cursor?: shared_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shared_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shared_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shared_files.
     */
    distinct?: Enumerable<Shared_fileScalarFieldEnum>
  }


  /**
   * shared_file findMany
   */
  export type shared_fileFindManyArgs = {
    /**
     * Select specific fields to fetch from the shared_file
     */
    select?: shared_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_fileInclude | null
    /**
     * Filter, which shared_files to fetch.
     */
    where?: shared_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shared_files to fetch.
     */
    orderBy?: Enumerable<shared_fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shared_files.
     */
    cursor?: shared_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shared_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shared_files.
     */
    skip?: number
    distinct?: Enumerable<Shared_fileScalarFieldEnum>
  }


  /**
   * shared_file create
   */
  export type shared_fileCreateArgs = {
    /**
     * Select specific fields to fetch from the shared_file
     */
    select?: shared_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_fileInclude | null
    /**
     * The data needed to create a shared_file.
     */
    data: XOR<shared_fileCreateInput, shared_fileUncheckedCreateInput>
  }


  /**
   * shared_file update
   */
  export type shared_fileUpdateArgs = {
    /**
     * Select specific fields to fetch from the shared_file
     */
    select?: shared_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_fileInclude | null
    /**
     * The data needed to update a shared_file.
     */
    data: XOR<shared_fileUpdateInput, shared_fileUncheckedUpdateInput>
    /**
     * Choose, which shared_file to update.
     */
    where: shared_fileWhereUniqueInput
  }


  /**
   * shared_file updateMany
   */
  export type shared_fileUpdateManyArgs = {
    /**
     * The data used to update shared_files.
     */
    data: XOR<shared_fileUpdateManyMutationInput, shared_fileUncheckedUpdateManyInput>
    /**
     * Filter which shared_files to update
     */
    where?: shared_fileWhereInput
  }


  /**
   * shared_file upsert
   */
  export type shared_fileUpsertArgs = {
    /**
     * Select specific fields to fetch from the shared_file
     */
    select?: shared_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_fileInclude | null
    /**
     * The filter to search for the shared_file to update in case it exists.
     */
    where: shared_fileWhereUniqueInput
    /**
     * In case the shared_file found by the `where` argument doesn't exist, create a new shared_file with this data.
     */
    create: XOR<shared_fileCreateInput, shared_fileUncheckedCreateInput>
    /**
     * In case the shared_file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shared_fileUpdateInput, shared_fileUncheckedUpdateInput>
  }


  /**
   * shared_file delete
   */
  export type shared_fileDeleteArgs = {
    /**
     * Select specific fields to fetch from the shared_file
     */
    select?: shared_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_fileInclude | null
    /**
     * Filter which shared_file to delete.
     */
    where: shared_fileWhereUniqueInput
  }


  /**
   * shared_file deleteMany
   */
  export type shared_fileDeleteManyArgs = {
    /**
     * Filter which shared_files to delete
     */
    where?: shared_fileWhereInput
  }


  /**
   * shared_file without action
   */
  export type shared_fileArgs = {
    /**
     * Select specific fields to fetch from the shared_file
     */
    select?: shared_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_fileInclude | null
  }



  /**
   * Model shared_file_in_progress
   */


  export type AggregateShared_file_in_progress = {
    _count: Shared_file_in_progressCountAggregateOutputType | null
    _min: Shared_file_in_progressMinAggregateOutputType | null
    _max: Shared_file_in_progressMaxAggregateOutputType | null
  }

  export type Shared_file_in_progressMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    url: string | null
    file_id: string | null
    name: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Shared_file_in_progressMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    url: string | null
    file_id: string | null
    name: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Shared_file_in_progressCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    url: number
    file_id: number
    name: number
    drive_id: number
    user_id: number
    _all: number
  }


  export type Shared_file_in_progressMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    url?: true
    file_id?: true
    name?: true
    drive_id?: true
    user_id?: true
  }

  export type Shared_file_in_progressMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    url?: true
    file_id?: true
    name?: true
    drive_id?: true
    user_id?: true
  }

  export type Shared_file_in_progressCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    url?: true
    file_id?: true
    name?: true
    drive_id?: true
    user_id?: true
    _all?: true
  }

  export type Shared_file_in_progressAggregateArgs = {
    /**
     * Filter which shared_file_in_progress to aggregate.
     */
    where?: shared_file_in_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shared_file_in_progresses to fetch.
     */
    orderBy?: Enumerable<shared_file_in_progressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: shared_file_in_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shared_file_in_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shared_file_in_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned shared_file_in_progresses
    **/
    _count?: true | Shared_file_in_progressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Shared_file_in_progressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Shared_file_in_progressMaxAggregateInputType
  }

  export type GetShared_file_in_progressAggregateType<T extends Shared_file_in_progressAggregateArgs> = {
        [P in keyof T & keyof AggregateShared_file_in_progress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShared_file_in_progress[P]>
      : GetScalarType<T[P], AggregateShared_file_in_progress[P]>
  }




  export type Shared_file_in_progressGroupByArgs = {
    where?: shared_file_in_progressWhereInput
    orderBy?: Enumerable<shared_file_in_progressOrderByWithAggregationInput>
    by: Shared_file_in_progressScalarFieldEnum[]
    having?: shared_file_in_progressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Shared_file_in_progressCountAggregateInputType | true
    _min?: Shared_file_in_progressMinAggregateInputType
    _max?: Shared_file_in_progressMaxAggregateInputType
  }


  export type Shared_file_in_progressGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    url: string
    file_id: string
    name: string
    drive_id: string
    user_id: string
    _count: Shared_file_in_progressCountAggregateOutputType | null
    _min: Shared_file_in_progressMinAggregateOutputType | null
    _max: Shared_file_in_progressMaxAggregateOutputType | null
  }

  type GetShared_file_in_progressGroupByPayload<T extends Shared_file_in_progressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Shared_file_in_progressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Shared_file_in_progressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Shared_file_in_progressGroupByOutputType[P]>
            : GetScalarType<T[P], Shared_file_in_progressGroupByOutputType[P]>
        }
      >
    >


  export type shared_file_in_progressSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    url?: boolean
    file_id?: boolean
    name?: boolean
    drive_id?: boolean
    user_id?: boolean
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }


  export type shared_file_in_progressInclude = {
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }

  export type shared_file_in_progressGetPayload<S extends boolean | null | undefined | shared_file_in_progressArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? shared_file_in_progress :
    S extends undefined ? never :
    S extends { include: any } & (shared_file_in_progressArgs | shared_file_in_progressFindManyArgs)
    ? shared_file_in_progress  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'drive' ? driveGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (shared_file_in_progressArgs | shared_file_in_progressFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'drive' ? driveGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof shared_file_in_progress ? shared_file_in_progress[P] : never
  } 
      : shared_file_in_progress


  type shared_file_in_progressCountArgs = 
    Omit<shared_file_in_progressFindManyArgs, 'select' | 'include'> & {
      select?: Shared_file_in_progressCountAggregateInputType | true
    }

  export interface shared_file_in_progressDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Shared_file_in_progress that matches the filter.
     * @param {shared_file_in_progressFindUniqueArgs} args - Arguments to find a Shared_file_in_progress
     * @example
     * // Get one Shared_file_in_progress
     * const shared_file_in_progress = await prisma.shared_file_in_progress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends shared_file_in_progressFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, shared_file_in_progressFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'shared_file_in_progress'> extends True ? Prisma__shared_file_in_progressClient<shared_file_in_progressGetPayload<T>> : Prisma__shared_file_in_progressClient<shared_file_in_progressGetPayload<T> | null, null>

    /**
     * Find one Shared_file_in_progress that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {shared_file_in_progressFindUniqueOrThrowArgs} args - Arguments to find a Shared_file_in_progress
     * @example
     * // Get one Shared_file_in_progress
     * const shared_file_in_progress = await prisma.shared_file_in_progress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends shared_file_in_progressFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, shared_file_in_progressFindUniqueOrThrowArgs>
    ): Prisma__shared_file_in_progressClient<shared_file_in_progressGetPayload<T>>

    /**
     * Find the first Shared_file_in_progress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shared_file_in_progressFindFirstArgs} args - Arguments to find a Shared_file_in_progress
     * @example
     * // Get one Shared_file_in_progress
     * const shared_file_in_progress = await prisma.shared_file_in_progress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends shared_file_in_progressFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, shared_file_in_progressFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'shared_file_in_progress'> extends True ? Prisma__shared_file_in_progressClient<shared_file_in_progressGetPayload<T>> : Prisma__shared_file_in_progressClient<shared_file_in_progressGetPayload<T> | null, null>

    /**
     * Find the first Shared_file_in_progress that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shared_file_in_progressFindFirstOrThrowArgs} args - Arguments to find a Shared_file_in_progress
     * @example
     * // Get one Shared_file_in_progress
     * const shared_file_in_progress = await prisma.shared_file_in_progress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends shared_file_in_progressFindFirstOrThrowArgs>(
      args?: SelectSubset<T, shared_file_in_progressFindFirstOrThrowArgs>
    ): Prisma__shared_file_in_progressClient<shared_file_in_progressGetPayload<T>>

    /**
     * Find zero or more Shared_file_in_progresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shared_file_in_progressFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shared_file_in_progresses
     * const shared_file_in_progresses = await prisma.shared_file_in_progress.findMany()
     * 
     * // Get first 10 Shared_file_in_progresses
     * const shared_file_in_progresses = await prisma.shared_file_in_progress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shared_file_in_progressWithIdOnly = await prisma.shared_file_in_progress.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends shared_file_in_progressFindManyArgs>(
      args?: SelectSubset<T, shared_file_in_progressFindManyArgs>
    ): Prisma.PrismaPromise<Array<shared_file_in_progressGetPayload<T>>>

    /**
     * Create a Shared_file_in_progress.
     * @param {shared_file_in_progressCreateArgs} args - Arguments to create a Shared_file_in_progress.
     * @example
     * // Create one Shared_file_in_progress
     * const Shared_file_in_progress = await prisma.shared_file_in_progress.create({
     *   data: {
     *     // ... data to create a Shared_file_in_progress
     *   }
     * })
     * 
    **/
    create<T extends shared_file_in_progressCreateArgs>(
      args: SelectSubset<T, shared_file_in_progressCreateArgs>
    ): Prisma__shared_file_in_progressClient<shared_file_in_progressGetPayload<T>>

    /**
     * Delete a Shared_file_in_progress.
     * @param {shared_file_in_progressDeleteArgs} args - Arguments to delete one Shared_file_in_progress.
     * @example
     * // Delete one Shared_file_in_progress
     * const Shared_file_in_progress = await prisma.shared_file_in_progress.delete({
     *   where: {
     *     // ... filter to delete one Shared_file_in_progress
     *   }
     * })
     * 
    **/
    delete<T extends shared_file_in_progressDeleteArgs>(
      args: SelectSubset<T, shared_file_in_progressDeleteArgs>
    ): Prisma__shared_file_in_progressClient<shared_file_in_progressGetPayload<T>>

    /**
     * Update one Shared_file_in_progress.
     * @param {shared_file_in_progressUpdateArgs} args - Arguments to update one Shared_file_in_progress.
     * @example
     * // Update one Shared_file_in_progress
     * const shared_file_in_progress = await prisma.shared_file_in_progress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends shared_file_in_progressUpdateArgs>(
      args: SelectSubset<T, shared_file_in_progressUpdateArgs>
    ): Prisma__shared_file_in_progressClient<shared_file_in_progressGetPayload<T>>

    /**
     * Delete zero or more Shared_file_in_progresses.
     * @param {shared_file_in_progressDeleteManyArgs} args - Arguments to filter Shared_file_in_progresses to delete.
     * @example
     * // Delete a few Shared_file_in_progresses
     * const { count } = await prisma.shared_file_in_progress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends shared_file_in_progressDeleteManyArgs>(
      args?: SelectSubset<T, shared_file_in_progressDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shared_file_in_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shared_file_in_progressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shared_file_in_progresses
     * const shared_file_in_progress = await prisma.shared_file_in_progress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends shared_file_in_progressUpdateManyArgs>(
      args: SelectSubset<T, shared_file_in_progressUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shared_file_in_progress.
     * @param {shared_file_in_progressUpsertArgs} args - Arguments to update or create a Shared_file_in_progress.
     * @example
     * // Update or create a Shared_file_in_progress
     * const shared_file_in_progress = await prisma.shared_file_in_progress.upsert({
     *   create: {
     *     // ... data to create a Shared_file_in_progress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shared_file_in_progress we want to update
     *   }
     * })
    **/
    upsert<T extends shared_file_in_progressUpsertArgs>(
      args: SelectSubset<T, shared_file_in_progressUpsertArgs>
    ): Prisma__shared_file_in_progressClient<shared_file_in_progressGetPayload<T>>

    /**
     * Count the number of Shared_file_in_progresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {shared_file_in_progressCountArgs} args - Arguments to filter Shared_file_in_progresses to count.
     * @example
     * // Count the number of Shared_file_in_progresses
     * const count = await prisma.shared_file_in_progress.count({
     *   where: {
     *     // ... the filter for the Shared_file_in_progresses we want to count
     *   }
     * })
    **/
    count<T extends shared_file_in_progressCountArgs>(
      args?: Subset<T, shared_file_in_progressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Shared_file_in_progressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shared_file_in_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shared_file_in_progressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Shared_file_in_progressAggregateArgs>(args: Subset<T, Shared_file_in_progressAggregateArgs>): Prisma.PrismaPromise<GetShared_file_in_progressAggregateType<T>>

    /**
     * Group by Shared_file_in_progress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Shared_file_in_progressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Shared_file_in_progressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Shared_file_in_progressGroupByArgs['orderBy'] }
        : { orderBy?: Shared_file_in_progressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Shared_file_in_progressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShared_file_in_progressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for shared_file_in_progress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__shared_file_in_progressClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    drive<T extends driveArgs= {}>(args?: Subset<T, driveArgs>): Prisma__driveClient<driveGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * shared_file_in_progress base type for findUnique actions
   */
  export type shared_file_in_progressFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
    /**
     * Filter, which shared_file_in_progress to fetch.
     */
    where: shared_file_in_progressWhereUniqueInput
  }

  /**
   * shared_file_in_progress findUnique
   */
  export interface shared_file_in_progressFindUniqueArgs extends shared_file_in_progressFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * shared_file_in_progress findUniqueOrThrow
   */
  export type shared_file_in_progressFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
    /**
     * Filter, which shared_file_in_progress to fetch.
     */
    where: shared_file_in_progressWhereUniqueInput
  }


  /**
   * shared_file_in_progress base type for findFirst actions
   */
  export type shared_file_in_progressFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
    /**
     * Filter, which shared_file_in_progress to fetch.
     */
    where?: shared_file_in_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shared_file_in_progresses to fetch.
     */
    orderBy?: Enumerable<shared_file_in_progressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shared_file_in_progresses.
     */
    cursor?: shared_file_in_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shared_file_in_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shared_file_in_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shared_file_in_progresses.
     */
    distinct?: Enumerable<Shared_file_in_progressScalarFieldEnum>
  }

  /**
   * shared_file_in_progress findFirst
   */
  export interface shared_file_in_progressFindFirstArgs extends shared_file_in_progressFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * shared_file_in_progress findFirstOrThrow
   */
  export type shared_file_in_progressFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
    /**
     * Filter, which shared_file_in_progress to fetch.
     */
    where?: shared_file_in_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shared_file_in_progresses to fetch.
     */
    orderBy?: Enumerable<shared_file_in_progressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for shared_file_in_progresses.
     */
    cursor?: shared_file_in_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shared_file_in_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shared_file_in_progresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of shared_file_in_progresses.
     */
    distinct?: Enumerable<Shared_file_in_progressScalarFieldEnum>
  }


  /**
   * shared_file_in_progress findMany
   */
  export type shared_file_in_progressFindManyArgs = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
    /**
     * Filter, which shared_file_in_progresses to fetch.
     */
    where?: shared_file_in_progressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of shared_file_in_progresses to fetch.
     */
    orderBy?: Enumerable<shared_file_in_progressOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing shared_file_in_progresses.
     */
    cursor?: shared_file_in_progressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` shared_file_in_progresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` shared_file_in_progresses.
     */
    skip?: number
    distinct?: Enumerable<Shared_file_in_progressScalarFieldEnum>
  }


  /**
   * shared_file_in_progress create
   */
  export type shared_file_in_progressCreateArgs = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
    /**
     * The data needed to create a shared_file_in_progress.
     */
    data: XOR<shared_file_in_progressCreateInput, shared_file_in_progressUncheckedCreateInput>
  }


  /**
   * shared_file_in_progress update
   */
  export type shared_file_in_progressUpdateArgs = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
    /**
     * The data needed to update a shared_file_in_progress.
     */
    data: XOR<shared_file_in_progressUpdateInput, shared_file_in_progressUncheckedUpdateInput>
    /**
     * Choose, which shared_file_in_progress to update.
     */
    where: shared_file_in_progressWhereUniqueInput
  }


  /**
   * shared_file_in_progress updateMany
   */
  export type shared_file_in_progressUpdateManyArgs = {
    /**
     * The data used to update shared_file_in_progresses.
     */
    data: XOR<shared_file_in_progressUpdateManyMutationInput, shared_file_in_progressUncheckedUpdateManyInput>
    /**
     * Filter which shared_file_in_progresses to update
     */
    where?: shared_file_in_progressWhereInput
  }


  /**
   * shared_file_in_progress upsert
   */
  export type shared_file_in_progressUpsertArgs = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
    /**
     * The filter to search for the shared_file_in_progress to update in case it exists.
     */
    where: shared_file_in_progressWhereUniqueInput
    /**
     * In case the shared_file_in_progress found by the `where` argument doesn't exist, create a new shared_file_in_progress with this data.
     */
    create: XOR<shared_file_in_progressCreateInput, shared_file_in_progressUncheckedCreateInput>
    /**
     * In case the shared_file_in_progress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<shared_file_in_progressUpdateInput, shared_file_in_progressUncheckedUpdateInput>
  }


  /**
   * shared_file_in_progress delete
   */
  export type shared_file_in_progressDeleteArgs = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
    /**
     * Filter which shared_file_in_progress to delete.
     */
    where: shared_file_in_progressWhereUniqueInput
  }


  /**
   * shared_file_in_progress deleteMany
   */
  export type shared_file_in_progressDeleteManyArgs = {
    /**
     * Filter which shared_file_in_progresses to delete
     */
    where?: shared_file_in_progressWhereInput
  }


  /**
   * shared_file_in_progress without action
   */
  export type shared_file_in_progressArgs = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
  }



  /**
   * Model bind_for_parsed_tv
   */


  export type AggregateBind_for_parsed_tv = {
    _count: Bind_for_parsed_tvCountAggregateOutputType | null
    _avg: Bind_for_parsed_tvAvgAggregateOutputType | null
    _sum: Bind_for_parsed_tvSumAggregateOutputType | null
    _min: Bind_for_parsed_tvMinAggregateOutputType | null
    _max: Bind_for_parsed_tvMaxAggregateOutputType | null
  }

  export type Bind_for_parsed_tvAvgAggregateOutputType = {
    in_production: number | null
    invalid: number | null
  }

  export type Bind_for_parsed_tvSumAggregateOutputType = {
    in_production: number | null
    invalid: number | null
  }

  export type Bind_for_parsed_tvMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    url: string | null
    file_id: string | null
    name: string | null
    file_id_link_resource: string | null
    file_name_link_resource: string | null
    in_production: number | null
    invalid: number | null
    season_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Bind_for_parsed_tvMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    url: string | null
    file_id: string | null
    name: string | null
    file_id_link_resource: string | null
    file_name_link_resource: string | null
    in_production: number | null
    invalid: number | null
    season_id: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Bind_for_parsed_tvCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    url: number
    file_id: number
    name: number
    file_id_link_resource: number
    file_name_link_resource: number
    in_production: number
    invalid: number
    season_id: number
    drive_id: number
    user_id: number
    _all: number
  }


  export type Bind_for_parsed_tvAvgAggregateInputType = {
    in_production?: true
    invalid?: true
  }

  export type Bind_for_parsed_tvSumAggregateInputType = {
    in_production?: true
    invalid?: true
  }

  export type Bind_for_parsed_tvMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    url?: true
    file_id?: true
    name?: true
    file_id_link_resource?: true
    file_name_link_resource?: true
    in_production?: true
    invalid?: true
    season_id?: true
    drive_id?: true
    user_id?: true
  }

  export type Bind_for_parsed_tvMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    url?: true
    file_id?: true
    name?: true
    file_id_link_resource?: true
    file_name_link_resource?: true
    in_production?: true
    invalid?: true
    season_id?: true
    drive_id?: true
    user_id?: true
  }

  export type Bind_for_parsed_tvCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    url?: true
    file_id?: true
    name?: true
    file_id_link_resource?: true
    file_name_link_resource?: true
    in_production?: true
    invalid?: true
    season_id?: true
    drive_id?: true
    user_id?: true
    _all?: true
  }

  export type Bind_for_parsed_tvAggregateArgs = {
    /**
     * Filter which bind_for_parsed_tv to aggregate.
     */
    where?: bind_for_parsed_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bind_for_parsed_tvs to fetch.
     */
    orderBy?: Enumerable<bind_for_parsed_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bind_for_parsed_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bind_for_parsed_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bind_for_parsed_tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bind_for_parsed_tvs
    **/
    _count?: true | Bind_for_parsed_tvCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bind_for_parsed_tvAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bind_for_parsed_tvSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bind_for_parsed_tvMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bind_for_parsed_tvMaxAggregateInputType
  }

  export type GetBind_for_parsed_tvAggregateType<T extends Bind_for_parsed_tvAggregateArgs> = {
        [P in keyof T & keyof AggregateBind_for_parsed_tv]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBind_for_parsed_tv[P]>
      : GetScalarType<T[P], AggregateBind_for_parsed_tv[P]>
  }




  export type Bind_for_parsed_tvGroupByArgs = {
    where?: bind_for_parsed_tvWhereInput
    orderBy?: Enumerable<bind_for_parsed_tvOrderByWithAggregationInput>
    by: Bind_for_parsed_tvScalarFieldEnum[]
    having?: bind_for_parsed_tvScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bind_for_parsed_tvCountAggregateInputType | true
    _avg?: Bind_for_parsed_tvAvgAggregateInputType
    _sum?: Bind_for_parsed_tvSumAggregateInputType
    _min?: Bind_for_parsed_tvMinAggregateInputType
    _max?: Bind_for_parsed_tvMaxAggregateInputType
  }


  export type Bind_for_parsed_tvGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    url: string
    file_id: string
    name: string
    file_id_link_resource: string
    file_name_link_resource: string
    in_production: number | null
    invalid: number | null
    season_id: string | null
    drive_id: string
    user_id: string
    _count: Bind_for_parsed_tvCountAggregateOutputType | null
    _avg: Bind_for_parsed_tvAvgAggregateOutputType | null
    _sum: Bind_for_parsed_tvSumAggregateOutputType | null
    _min: Bind_for_parsed_tvMinAggregateOutputType | null
    _max: Bind_for_parsed_tvMaxAggregateOutputType | null
  }

  type GetBind_for_parsed_tvGroupByPayload<T extends Bind_for_parsed_tvGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Bind_for_parsed_tvGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bind_for_parsed_tvGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bind_for_parsed_tvGroupByOutputType[P]>
            : GetScalarType<T[P], Bind_for_parsed_tvGroupByOutputType[P]>
        }
      >
    >


  export type bind_for_parsed_tvSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    url?: boolean
    file_id?: boolean
    name?: boolean
    file_id_link_resource?: boolean
    file_name_link_resource?: boolean
    in_production?: boolean
    invalid?: boolean
    season_id?: boolean
    drive_id?: boolean
    user_id?: boolean
    season?: boolean | seasonArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }


  export type bind_for_parsed_tvInclude = {
    season?: boolean | seasonArgs
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }

  export type bind_for_parsed_tvGetPayload<S extends boolean | null | undefined | bind_for_parsed_tvArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? bind_for_parsed_tv :
    S extends undefined ? never :
    S extends { include: any } & (bind_for_parsed_tvArgs | bind_for_parsed_tvFindManyArgs)
    ? bind_for_parsed_tv  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'season' ? seasonGetPayload<S['include'][P]> | null :
        P extends 'drive' ? driveGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (bind_for_parsed_tvArgs | bind_for_parsed_tvFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'season' ? seasonGetPayload<S['select'][P]> | null :
        P extends 'drive' ? driveGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof bind_for_parsed_tv ? bind_for_parsed_tv[P] : never
  } 
      : bind_for_parsed_tv


  type bind_for_parsed_tvCountArgs = 
    Omit<bind_for_parsed_tvFindManyArgs, 'select' | 'include'> & {
      select?: Bind_for_parsed_tvCountAggregateInputType | true
    }

  export interface bind_for_parsed_tvDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Bind_for_parsed_tv that matches the filter.
     * @param {bind_for_parsed_tvFindUniqueArgs} args - Arguments to find a Bind_for_parsed_tv
     * @example
     * // Get one Bind_for_parsed_tv
     * const bind_for_parsed_tv = await prisma.bind_for_parsed_tv.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends bind_for_parsed_tvFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, bind_for_parsed_tvFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'bind_for_parsed_tv'> extends True ? Prisma__bind_for_parsed_tvClient<bind_for_parsed_tvGetPayload<T>> : Prisma__bind_for_parsed_tvClient<bind_for_parsed_tvGetPayload<T> | null, null>

    /**
     * Find one Bind_for_parsed_tv that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {bind_for_parsed_tvFindUniqueOrThrowArgs} args - Arguments to find a Bind_for_parsed_tv
     * @example
     * // Get one Bind_for_parsed_tv
     * const bind_for_parsed_tv = await prisma.bind_for_parsed_tv.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends bind_for_parsed_tvFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, bind_for_parsed_tvFindUniqueOrThrowArgs>
    ): Prisma__bind_for_parsed_tvClient<bind_for_parsed_tvGetPayload<T>>

    /**
     * Find the first Bind_for_parsed_tv that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bind_for_parsed_tvFindFirstArgs} args - Arguments to find a Bind_for_parsed_tv
     * @example
     * // Get one Bind_for_parsed_tv
     * const bind_for_parsed_tv = await prisma.bind_for_parsed_tv.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends bind_for_parsed_tvFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, bind_for_parsed_tvFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'bind_for_parsed_tv'> extends True ? Prisma__bind_for_parsed_tvClient<bind_for_parsed_tvGetPayload<T>> : Prisma__bind_for_parsed_tvClient<bind_for_parsed_tvGetPayload<T> | null, null>

    /**
     * Find the first Bind_for_parsed_tv that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bind_for_parsed_tvFindFirstOrThrowArgs} args - Arguments to find a Bind_for_parsed_tv
     * @example
     * // Get one Bind_for_parsed_tv
     * const bind_for_parsed_tv = await prisma.bind_for_parsed_tv.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends bind_for_parsed_tvFindFirstOrThrowArgs>(
      args?: SelectSubset<T, bind_for_parsed_tvFindFirstOrThrowArgs>
    ): Prisma__bind_for_parsed_tvClient<bind_for_parsed_tvGetPayload<T>>

    /**
     * Find zero or more Bind_for_parsed_tvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bind_for_parsed_tvFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bind_for_parsed_tvs
     * const bind_for_parsed_tvs = await prisma.bind_for_parsed_tv.findMany()
     * 
     * // Get first 10 Bind_for_parsed_tvs
     * const bind_for_parsed_tvs = await prisma.bind_for_parsed_tv.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bind_for_parsed_tvWithIdOnly = await prisma.bind_for_parsed_tv.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends bind_for_parsed_tvFindManyArgs>(
      args?: SelectSubset<T, bind_for_parsed_tvFindManyArgs>
    ): Prisma.PrismaPromise<Array<bind_for_parsed_tvGetPayload<T>>>

    /**
     * Create a Bind_for_parsed_tv.
     * @param {bind_for_parsed_tvCreateArgs} args - Arguments to create a Bind_for_parsed_tv.
     * @example
     * // Create one Bind_for_parsed_tv
     * const Bind_for_parsed_tv = await prisma.bind_for_parsed_tv.create({
     *   data: {
     *     // ... data to create a Bind_for_parsed_tv
     *   }
     * })
     * 
    **/
    create<T extends bind_for_parsed_tvCreateArgs>(
      args: SelectSubset<T, bind_for_parsed_tvCreateArgs>
    ): Prisma__bind_for_parsed_tvClient<bind_for_parsed_tvGetPayload<T>>

    /**
     * Delete a Bind_for_parsed_tv.
     * @param {bind_for_parsed_tvDeleteArgs} args - Arguments to delete one Bind_for_parsed_tv.
     * @example
     * // Delete one Bind_for_parsed_tv
     * const Bind_for_parsed_tv = await prisma.bind_for_parsed_tv.delete({
     *   where: {
     *     // ... filter to delete one Bind_for_parsed_tv
     *   }
     * })
     * 
    **/
    delete<T extends bind_for_parsed_tvDeleteArgs>(
      args: SelectSubset<T, bind_for_parsed_tvDeleteArgs>
    ): Prisma__bind_for_parsed_tvClient<bind_for_parsed_tvGetPayload<T>>

    /**
     * Update one Bind_for_parsed_tv.
     * @param {bind_for_parsed_tvUpdateArgs} args - Arguments to update one Bind_for_parsed_tv.
     * @example
     * // Update one Bind_for_parsed_tv
     * const bind_for_parsed_tv = await prisma.bind_for_parsed_tv.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends bind_for_parsed_tvUpdateArgs>(
      args: SelectSubset<T, bind_for_parsed_tvUpdateArgs>
    ): Prisma__bind_for_parsed_tvClient<bind_for_parsed_tvGetPayload<T>>

    /**
     * Delete zero or more Bind_for_parsed_tvs.
     * @param {bind_for_parsed_tvDeleteManyArgs} args - Arguments to filter Bind_for_parsed_tvs to delete.
     * @example
     * // Delete a few Bind_for_parsed_tvs
     * const { count } = await prisma.bind_for_parsed_tv.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends bind_for_parsed_tvDeleteManyArgs>(
      args?: SelectSubset<T, bind_for_parsed_tvDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bind_for_parsed_tvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bind_for_parsed_tvUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bind_for_parsed_tvs
     * const bind_for_parsed_tv = await prisma.bind_for_parsed_tv.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends bind_for_parsed_tvUpdateManyArgs>(
      args: SelectSubset<T, bind_for_parsed_tvUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bind_for_parsed_tv.
     * @param {bind_for_parsed_tvUpsertArgs} args - Arguments to update or create a Bind_for_parsed_tv.
     * @example
     * // Update or create a Bind_for_parsed_tv
     * const bind_for_parsed_tv = await prisma.bind_for_parsed_tv.upsert({
     *   create: {
     *     // ... data to create a Bind_for_parsed_tv
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bind_for_parsed_tv we want to update
     *   }
     * })
    **/
    upsert<T extends bind_for_parsed_tvUpsertArgs>(
      args: SelectSubset<T, bind_for_parsed_tvUpsertArgs>
    ): Prisma__bind_for_parsed_tvClient<bind_for_parsed_tvGetPayload<T>>

    /**
     * Count the number of Bind_for_parsed_tvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bind_for_parsed_tvCountArgs} args - Arguments to filter Bind_for_parsed_tvs to count.
     * @example
     * // Count the number of Bind_for_parsed_tvs
     * const count = await prisma.bind_for_parsed_tv.count({
     *   where: {
     *     // ... the filter for the Bind_for_parsed_tvs we want to count
     *   }
     * })
    **/
    count<T extends bind_for_parsed_tvCountArgs>(
      args?: Subset<T, bind_for_parsed_tvCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bind_for_parsed_tvCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bind_for_parsed_tv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bind_for_parsed_tvAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bind_for_parsed_tvAggregateArgs>(args: Subset<T, Bind_for_parsed_tvAggregateArgs>): Prisma.PrismaPromise<GetBind_for_parsed_tvAggregateType<T>>

    /**
     * Group by Bind_for_parsed_tv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bind_for_parsed_tvGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Bind_for_parsed_tvGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Bind_for_parsed_tvGroupByArgs['orderBy'] }
        : { orderBy?: Bind_for_parsed_tvGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Bind_for_parsed_tvGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBind_for_parsed_tvGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for bind_for_parsed_tv.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__bind_for_parsed_tvClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    season<T extends seasonArgs= {}>(args?: Subset<T, seasonArgs>): Prisma__seasonClient<seasonGetPayload<T> | Null>;

    drive<T extends driveArgs= {}>(args?: Subset<T, driveArgs>): Prisma__driveClient<driveGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * bind_for_parsed_tv base type for findUnique actions
   */
  export type bind_for_parsed_tvFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    /**
     * Filter, which bind_for_parsed_tv to fetch.
     */
    where: bind_for_parsed_tvWhereUniqueInput
  }

  /**
   * bind_for_parsed_tv findUnique
   */
  export interface bind_for_parsed_tvFindUniqueArgs extends bind_for_parsed_tvFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * bind_for_parsed_tv findUniqueOrThrow
   */
  export type bind_for_parsed_tvFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    /**
     * Filter, which bind_for_parsed_tv to fetch.
     */
    where: bind_for_parsed_tvWhereUniqueInput
  }


  /**
   * bind_for_parsed_tv base type for findFirst actions
   */
  export type bind_for_parsed_tvFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    /**
     * Filter, which bind_for_parsed_tv to fetch.
     */
    where?: bind_for_parsed_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bind_for_parsed_tvs to fetch.
     */
    orderBy?: Enumerable<bind_for_parsed_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bind_for_parsed_tvs.
     */
    cursor?: bind_for_parsed_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bind_for_parsed_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bind_for_parsed_tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bind_for_parsed_tvs.
     */
    distinct?: Enumerable<Bind_for_parsed_tvScalarFieldEnum>
  }

  /**
   * bind_for_parsed_tv findFirst
   */
  export interface bind_for_parsed_tvFindFirstArgs extends bind_for_parsed_tvFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * bind_for_parsed_tv findFirstOrThrow
   */
  export type bind_for_parsed_tvFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    /**
     * Filter, which bind_for_parsed_tv to fetch.
     */
    where?: bind_for_parsed_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bind_for_parsed_tvs to fetch.
     */
    orderBy?: Enumerable<bind_for_parsed_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bind_for_parsed_tvs.
     */
    cursor?: bind_for_parsed_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bind_for_parsed_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bind_for_parsed_tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bind_for_parsed_tvs.
     */
    distinct?: Enumerable<Bind_for_parsed_tvScalarFieldEnum>
  }


  /**
   * bind_for_parsed_tv findMany
   */
  export type bind_for_parsed_tvFindManyArgs = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    /**
     * Filter, which bind_for_parsed_tvs to fetch.
     */
    where?: bind_for_parsed_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bind_for_parsed_tvs to fetch.
     */
    orderBy?: Enumerable<bind_for_parsed_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bind_for_parsed_tvs.
     */
    cursor?: bind_for_parsed_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bind_for_parsed_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bind_for_parsed_tvs.
     */
    skip?: number
    distinct?: Enumerable<Bind_for_parsed_tvScalarFieldEnum>
  }


  /**
   * bind_for_parsed_tv create
   */
  export type bind_for_parsed_tvCreateArgs = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    /**
     * The data needed to create a bind_for_parsed_tv.
     */
    data: XOR<bind_for_parsed_tvCreateInput, bind_for_parsed_tvUncheckedCreateInput>
  }


  /**
   * bind_for_parsed_tv update
   */
  export type bind_for_parsed_tvUpdateArgs = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    /**
     * The data needed to update a bind_for_parsed_tv.
     */
    data: XOR<bind_for_parsed_tvUpdateInput, bind_for_parsed_tvUncheckedUpdateInput>
    /**
     * Choose, which bind_for_parsed_tv to update.
     */
    where: bind_for_parsed_tvWhereUniqueInput
  }


  /**
   * bind_for_parsed_tv updateMany
   */
  export type bind_for_parsed_tvUpdateManyArgs = {
    /**
     * The data used to update bind_for_parsed_tvs.
     */
    data: XOR<bind_for_parsed_tvUpdateManyMutationInput, bind_for_parsed_tvUncheckedUpdateManyInput>
    /**
     * Filter which bind_for_parsed_tvs to update
     */
    where?: bind_for_parsed_tvWhereInput
  }


  /**
   * bind_for_parsed_tv upsert
   */
  export type bind_for_parsed_tvUpsertArgs = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    /**
     * The filter to search for the bind_for_parsed_tv to update in case it exists.
     */
    where: bind_for_parsed_tvWhereUniqueInput
    /**
     * In case the bind_for_parsed_tv found by the `where` argument doesn't exist, create a new bind_for_parsed_tv with this data.
     */
    create: XOR<bind_for_parsed_tvCreateInput, bind_for_parsed_tvUncheckedCreateInput>
    /**
     * In case the bind_for_parsed_tv was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bind_for_parsed_tvUpdateInput, bind_for_parsed_tvUncheckedUpdateInput>
  }


  /**
   * bind_for_parsed_tv delete
   */
  export type bind_for_parsed_tvDeleteArgs = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    /**
     * Filter which bind_for_parsed_tv to delete.
     */
    where: bind_for_parsed_tvWhereUniqueInput
  }


  /**
   * bind_for_parsed_tv deleteMany
   */
  export type bind_for_parsed_tvDeleteManyArgs = {
    /**
     * Filter which bind_for_parsed_tvs to delete
     */
    where?: bind_for_parsed_tvWhereInput
  }


  /**
   * bind_for_parsed_tv without action
   */
  export type bind_for_parsed_tvArgs = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
  }



  /**
   * Model drive_check_in
   */


  export type AggregateDrive_check_in = {
    _count: Drive_check_inCountAggregateOutputType | null
    _min: Drive_check_inMinAggregateOutputType | null
    _max: Drive_check_inMaxAggregateOutputType | null
  }

  export type Drive_check_inMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    checked_at: Date | null
    drive_id: string | null
  }

  export type Drive_check_inMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    checked_at: Date | null
    drive_id: string | null
  }

  export type Drive_check_inCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    checked_at: number
    drive_id: number
    _all: number
  }


  export type Drive_check_inMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    checked_at?: true
    drive_id?: true
  }

  export type Drive_check_inMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    checked_at?: true
    drive_id?: true
  }

  export type Drive_check_inCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    checked_at?: true
    drive_id?: true
    _all?: true
  }

  export type Drive_check_inAggregateArgs = {
    /**
     * Filter which drive_check_in to aggregate.
     */
    where?: drive_check_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drive_check_ins to fetch.
     */
    orderBy?: Enumerable<drive_check_inOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: drive_check_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drive_check_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drive_check_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned drive_check_ins
    **/
    _count?: true | Drive_check_inCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Drive_check_inMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Drive_check_inMaxAggregateInputType
  }

  export type GetDrive_check_inAggregateType<T extends Drive_check_inAggregateArgs> = {
        [P in keyof T & keyof AggregateDrive_check_in]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDrive_check_in[P]>
      : GetScalarType<T[P], AggregateDrive_check_in[P]>
  }




  export type Drive_check_inGroupByArgs = {
    where?: drive_check_inWhereInput
    orderBy?: Enumerable<drive_check_inOrderByWithAggregationInput>
    by: Drive_check_inScalarFieldEnum[]
    having?: drive_check_inScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Drive_check_inCountAggregateInputType | true
    _min?: Drive_check_inMinAggregateInputType
    _max?: Drive_check_inMaxAggregateInputType
  }


  export type Drive_check_inGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    checked_at: Date | null
    drive_id: string
    _count: Drive_check_inCountAggregateOutputType | null
    _min: Drive_check_inMinAggregateOutputType | null
    _max: Drive_check_inMaxAggregateOutputType | null
  }

  type GetDrive_check_inGroupByPayload<T extends Drive_check_inGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Drive_check_inGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Drive_check_inGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Drive_check_inGroupByOutputType[P]>
            : GetScalarType<T[P], Drive_check_inGroupByOutputType[P]>
        }
      >
    >


  export type drive_check_inSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    checked_at?: boolean
    drive_id?: boolean
    drive?: boolean | driveArgs
  }


  export type drive_check_inInclude = {
    drive?: boolean | driveArgs
  }

  export type drive_check_inGetPayload<S extends boolean | null | undefined | drive_check_inArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? drive_check_in :
    S extends undefined ? never :
    S extends { include: any } & (drive_check_inArgs | drive_check_inFindManyArgs)
    ? drive_check_in  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'drive' ? driveGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (drive_check_inArgs | drive_check_inFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'drive' ? driveGetPayload<S['select'][P]> :  P extends keyof drive_check_in ? drive_check_in[P] : never
  } 
      : drive_check_in


  type drive_check_inCountArgs = 
    Omit<drive_check_inFindManyArgs, 'select' | 'include'> & {
      select?: Drive_check_inCountAggregateInputType | true
    }

  export interface drive_check_inDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Drive_check_in that matches the filter.
     * @param {drive_check_inFindUniqueArgs} args - Arguments to find a Drive_check_in
     * @example
     * // Get one Drive_check_in
     * const drive_check_in = await prisma.drive_check_in.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends drive_check_inFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, drive_check_inFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'drive_check_in'> extends True ? Prisma__drive_check_inClient<drive_check_inGetPayload<T>> : Prisma__drive_check_inClient<drive_check_inGetPayload<T> | null, null>

    /**
     * Find one Drive_check_in that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {drive_check_inFindUniqueOrThrowArgs} args - Arguments to find a Drive_check_in
     * @example
     * // Get one Drive_check_in
     * const drive_check_in = await prisma.drive_check_in.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends drive_check_inFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, drive_check_inFindUniqueOrThrowArgs>
    ): Prisma__drive_check_inClient<drive_check_inGetPayload<T>>

    /**
     * Find the first Drive_check_in that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drive_check_inFindFirstArgs} args - Arguments to find a Drive_check_in
     * @example
     * // Get one Drive_check_in
     * const drive_check_in = await prisma.drive_check_in.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends drive_check_inFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, drive_check_inFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'drive_check_in'> extends True ? Prisma__drive_check_inClient<drive_check_inGetPayload<T>> : Prisma__drive_check_inClient<drive_check_inGetPayload<T> | null, null>

    /**
     * Find the first Drive_check_in that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drive_check_inFindFirstOrThrowArgs} args - Arguments to find a Drive_check_in
     * @example
     * // Get one Drive_check_in
     * const drive_check_in = await prisma.drive_check_in.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends drive_check_inFindFirstOrThrowArgs>(
      args?: SelectSubset<T, drive_check_inFindFirstOrThrowArgs>
    ): Prisma__drive_check_inClient<drive_check_inGetPayload<T>>

    /**
     * Find zero or more Drive_check_ins that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drive_check_inFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Drive_check_ins
     * const drive_check_ins = await prisma.drive_check_in.findMany()
     * 
     * // Get first 10 Drive_check_ins
     * const drive_check_ins = await prisma.drive_check_in.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const drive_check_inWithIdOnly = await prisma.drive_check_in.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends drive_check_inFindManyArgs>(
      args?: SelectSubset<T, drive_check_inFindManyArgs>
    ): Prisma.PrismaPromise<Array<drive_check_inGetPayload<T>>>

    /**
     * Create a Drive_check_in.
     * @param {drive_check_inCreateArgs} args - Arguments to create a Drive_check_in.
     * @example
     * // Create one Drive_check_in
     * const Drive_check_in = await prisma.drive_check_in.create({
     *   data: {
     *     // ... data to create a Drive_check_in
     *   }
     * })
     * 
    **/
    create<T extends drive_check_inCreateArgs>(
      args: SelectSubset<T, drive_check_inCreateArgs>
    ): Prisma__drive_check_inClient<drive_check_inGetPayload<T>>

    /**
     * Delete a Drive_check_in.
     * @param {drive_check_inDeleteArgs} args - Arguments to delete one Drive_check_in.
     * @example
     * // Delete one Drive_check_in
     * const Drive_check_in = await prisma.drive_check_in.delete({
     *   where: {
     *     // ... filter to delete one Drive_check_in
     *   }
     * })
     * 
    **/
    delete<T extends drive_check_inDeleteArgs>(
      args: SelectSubset<T, drive_check_inDeleteArgs>
    ): Prisma__drive_check_inClient<drive_check_inGetPayload<T>>

    /**
     * Update one Drive_check_in.
     * @param {drive_check_inUpdateArgs} args - Arguments to update one Drive_check_in.
     * @example
     * // Update one Drive_check_in
     * const drive_check_in = await prisma.drive_check_in.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends drive_check_inUpdateArgs>(
      args: SelectSubset<T, drive_check_inUpdateArgs>
    ): Prisma__drive_check_inClient<drive_check_inGetPayload<T>>

    /**
     * Delete zero or more Drive_check_ins.
     * @param {drive_check_inDeleteManyArgs} args - Arguments to filter Drive_check_ins to delete.
     * @example
     * // Delete a few Drive_check_ins
     * const { count } = await prisma.drive_check_in.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends drive_check_inDeleteManyArgs>(
      args?: SelectSubset<T, drive_check_inDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Drive_check_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drive_check_inUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Drive_check_ins
     * const drive_check_in = await prisma.drive_check_in.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends drive_check_inUpdateManyArgs>(
      args: SelectSubset<T, drive_check_inUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Drive_check_in.
     * @param {drive_check_inUpsertArgs} args - Arguments to update or create a Drive_check_in.
     * @example
     * // Update or create a Drive_check_in
     * const drive_check_in = await prisma.drive_check_in.upsert({
     *   create: {
     *     // ... data to create a Drive_check_in
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Drive_check_in we want to update
     *   }
     * })
    **/
    upsert<T extends drive_check_inUpsertArgs>(
      args: SelectSubset<T, drive_check_inUpsertArgs>
    ): Prisma__drive_check_inClient<drive_check_inGetPayload<T>>

    /**
     * Count the number of Drive_check_ins.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {drive_check_inCountArgs} args - Arguments to filter Drive_check_ins to count.
     * @example
     * // Count the number of Drive_check_ins
     * const count = await prisma.drive_check_in.count({
     *   where: {
     *     // ... the filter for the Drive_check_ins we want to count
     *   }
     * })
    **/
    count<T extends drive_check_inCountArgs>(
      args?: Subset<T, drive_check_inCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Drive_check_inCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Drive_check_in.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Drive_check_inAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Drive_check_inAggregateArgs>(args: Subset<T, Drive_check_inAggregateArgs>): Prisma.PrismaPromise<GetDrive_check_inAggregateType<T>>

    /**
     * Group by Drive_check_in.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Drive_check_inGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Drive_check_inGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Drive_check_inGroupByArgs['orderBy'] }
        : { orderBy?: Drive_check_inGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Drive_check_inGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDrive_check_inGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for drive_check_in.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__drive_check_inClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    drive<T extends driveArgs= {}>(args?: Subset<T, driveArgs>): Prisma__driveClient<driveGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * drive_check_in base type for findUnique actions
   */
  export type drive_check_inFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the drive_check_in
     */
    select?: drive_check_inSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_check_inInclude | null
    /**
     * Filter, which drive_check_in to fetch.
     */
    where: drive_check_inWhereUniqueInput
  }

  /**
   * drive_check_in findUnique
   */
  export interface drive_check_inFindUniqueArgs extends drive_check_inFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * drive_check_in findUniqueOrThrow
   */
  export type drive_check_inFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the drive_check_in
     */
    select?: drive_check_inSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_check_inInclude | null
    /**
     * Filter, which drive_check_in to fetch.
     */
    where: drive_check_inWhereUniqueInput
  }


  /**
   * drive_check_in base type for findFirst actions
   */
  export type drive_check_inFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the drive_check_in
     */
    select?: drive_check_inSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_check_inInclude | null
    /**
     * Filter, which drive_check_in to fetch.
     */
    where?: drive_check_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drive_check_ins to fetch.
     */
    orderBy?: Enumerable<drive_check_inOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drive_check_ins.
     */
    cursor?: drive_check_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drive_check_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drive_check_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drive_check_ins.
     */
    distinct?: Enumerable<Drive_check_inScalarFieldEnum>
  }

  /**
   * drive_check_in findFirst
   */
  export interface drive_check_inFindFirstArgs extends drive_check_inFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * drive_check_in findFirstOrThrow
   */
  export type drive_check_inFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the drive_check_in
     */
    select?: drive_check_inSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_check_inInclude | null
    /**
     * Filter, which drive_check_in to fetch.
     */
    where?: drive_check_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drive_check_ins to fetch.
     */
    orderBy?: Enumerable<drive_check_inOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for drive_check_ins.
     */
    cursor?: drive_check_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drive_check_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drive_check_ins.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of drive_check_ins.
     */
    distinct?: Enumerable<Drive_check_inScalarFieldEnum>
  }


  /**
   * drive_check_in findMany
   */
  export type drive_check_inFindManyArgs = {
    /**
     * Select specific fields to fetch from the drive_check_in
     */
    select?: drive_check_inSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_check_inInclude | null
    /**
     * Filter, which drive_check_ins to fetch.
     */
    where?: drive_check_inWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of drive_check_ins to fetch.
     */
    orderBy?: Enumerable<drive_check_inOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing drive_check_ins.
     */
    cursor?: drive_check_inWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` drive_check_ins from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` drive_check_ins.
     */
    skip?: number
    distinct?: Enumerable<Drive_check_inScalarFieldEnum>
  }


  /**
   * drive_check_in create
   */
  export type drive_check_inCreateArgs = {
    /**
     * Select specific fields to fetch from the drive_check_in
     */
    select?: drive_check_inSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_check_inInclude | null
    /**
     * The data needed to create a drive_check_in.
     */
    data: XOR<drive_check_inCreateInput, drive_check_inUncheckedCreateInput>
  }


  /**
   * drive_check_in update
   */
  export type drive_check_inUpdateArgs = {
    /**
     * Select specific fields to fetch from the drive_check_in
     */
    select?: drive_check_inSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_check_inInclude | null
    /**
     * The data needed to update a drive_check_in.
     */
    data: XOR<drive_check_inUpdateInput, drive_check_inUncheckedUpdateInput>
    /**
     * Choose, which drive_check_in to update.
     */
    where: drive_check_inWhereUniqueInput
  }


  /**
   * drive_check_in updateMany
   */
  export type drive_check_inUpdateManyArgs = {
    /**
     * The data used to update drive_check_ins.
     */
    data: XOR<drive_check_inUpdateManyMutationInput, drive_check_inUncheckedUpdateManyInput>
    /**
     * Filter which drive_check_ins to update
     */
    where?: drive_check_inWhereInput
  }


  /**
   * drive_check_in upsert
   */
  export type drive_check_inUpsertArgs = {
    /**
     * Select specific fields to fetch from the drive_check_in
     */
    select?: drive_check_inSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_check_inInclude | null
    /**
     * The filter to search for the drive_check_in to update in case it exists.
     */
    where: drive_check_inWhereUniqueInput
    /**
     * In case the drive_check_in found by the `where` argument doesn't exist, create a new drive_check_in with this data.
     */
    create: XOR<drive_check_inCreateInput, drive_check_inUncheckedCreateInput>
    /**
     * In case the drive_check_in was found with the provided `where` argument, update it with this data.
     */
    update: XOR<drive_check_inUpdateInput, drive_check_inUncheckedUpdateInput>
  }


  /**
   * drive_check_in delete
   */
  export type drive_check_inDeleteArgs = {
    /**
     * Select specific fields to fetch from the drive_check_in
     */
    select?: drive_check_inSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_check_inInclude | null
    /**
     * Filter which drive_check_in to delete.
     */
    where: drive_check_inWhereUniqueInput
  }


  /**
   * drive_check_in deleteMany
   */
  export type drive_check_inDeleteManyArgs = {
    /**
     * Filter which drive_check_ins to delete
     */
    where?: drive_check_inWhereInput
  }


  /**
   * drive_check_in without action
   */
  export type drive_check_inArgs = {
    /**
     * Select specific fields to fetch from the drive_check_in
     */
    select?: drive_check_inSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: drive_check_inInclude | null
  }



  /**
   * Model tmp_file
   */


  export type AggregateTmp_file = {
    _count: Tmp_fileCountAggregateOutputType | null
    _avg: Tmp_fileAvgAggregateOutputType | null
    _sum: Tmp_fileSumAggregateOutputType | null
    _min: Tmp_fileMinAggregateOutputType | null
    _max: Tmp_fileMaxAggregateOutputType | null
  }

  export type Tmp_fileAvgAggregateOutputType = {
    type: number | null
  }

  export type Tmp_fileSumAggregateOutputType = {
    type: number | null
  }

  export type Tmp_fileMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    name: string | null
    type: number | null
    parent_paths: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Tmp_fileMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    name: string | null
    type: number | null
    parent_paths: string | null
    drive_id: string | null
    user_id: string | null
  }

  export type Tmp_fileCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    name: number
    type: number
    parent_paths: number
    drive_id: number
    user_id: number
    _all: number
  }


  export type Tmp_fileAvgAggregateInputType = {
    type?: true
  }

  export type Tmp_fileSumAggregateInputType = {
    type?: true
  }

  export type Tmp_fileMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    type?: true
    parent_paths?: true
    drive_id?: true
    user_id?: true
  }

  export type Tmp_fileMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    type?: true
    parent_paths?: true
    drive_id?: true
    user_id?: true
  }

  export type Tmp_fileCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    name?: true
    type?: true
    parent_paths?: true
    drive_id?: true
    user_id?: true
    _all?: true
  }

  export type Tmp_fileAggregateArgs = {
    /**
     * Filter which tmp_file to aggregate.
     */
    where?: tmp_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tmp_files to fetch.
     */
    orderBy?: Enumerable<tmp_fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: tmp_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tmp_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tmp_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned tmp_files
    **/
    _count?: true | Tmp_fileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Tmp_fileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Tmp_fileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Tmp_fileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Tmp_fileMaxAggregateInputType
  }

  export type GetTmp_fileAggregateType<T extends Tmp_fileAggregateArgs> = {
        [P in keyof T & keyof AggregateTmp_file]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTmp_file[P]>
      : GetScalarType<T[P], AggregateTmp_file[P]>
  }




  export type Tmp_fileGroupByArgs = {
    where?: tmp_fileWhereInput
    orderBy?: Enumerable<tmp_fileOrderByWithAggregationInput>
    by: Tmp_fileScalarFieldEnum[]
    having?: tmp_fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Tmp_fileCountAggregateInputType | true
    _avg?: Tmp_fileAvgAggregateInputType
    _sum?: Tmp_fileSumAggregateInputType
    _min?: Tmp_fileMinAggregateInputType
    _max?: Tmp_fileMaxAggregateInputType
  }


  export type Tmp_fileGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    name: string
    type: number | null
    parent_paths: string
    drive_id: string
    user_id: string
    _count: Tmp_fileCountAggregateOutputType | null
    _avg: Tmp_fileAvgAggregateOutputType | null
    _sum: Tmp_fileSumAggregateOutputType | null
    _min: Tmp_fileMinAggregateOutputType | null
    _max: Tmp_fileMaxAggregateOutputType | null
  }

  type GetTmp_fileGroupByPayload<T extends Tmp_fileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Tmp_fileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Tmp_fileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Tmp_fileGroupByOutputType[P]>
            : GetScalarType<T[P], Tmp_fileGroupByOutputType[P]>
        }
      >
    >


  export type tmp_fileSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    name?: boolean
    type?: boolean
    parent_paths?: boolean
    drive_id?: boolean
    user_id?: boolean
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }


  export type tmp_fileInclude = {
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }

  export type tmp_fileGetPayload<S extends boolean | null | undefined | tmp_fileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? tmp_file :
    S extends undefined ? never :
    S extends { include: any } & (tmp_fileArgs | tmp_fileFindManyArgs)
    ? tmp_file  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'drive' ? driveGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (tmp_fileArgs | tmp_fileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'drive' ? driveGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof tmp_file ? tmp_file[P] : never
  } 
      : tmp_file


  type tmp_fileCountArgs = 
    Omit<tmp_fileFindManyArgs, 'select' | 'include'> & {
      select?: Tmp_fileCountAggregateInputType | true
    }

  export interface tmp_fileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Tmp_file that matches the filter.
     * @param {tmp_fileFindUniqueArgs} args - Arguments to find a Tmp_file
     * @example
     * // Get one Tmp_file
     * const tmp_file = await prisma.tmp_file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends tmp_fileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, tmp_fileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'tmp_file'> extends True ? Prisma__tmp_fileClient<tmp_fileGetPayload<T>> : Prisma__tmp_fileClient<tmp_fileGetPayload<T> | null, null>

    /**
     * Find one Tmp_file that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {tmp_fileFindUniqueOrThrowArgs} args - Arguments to find a Tmp_file
     * @example
     * // Get one Tmp_file
     * const tmp_file = await prisma.tmp_file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends tmp_fileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, tmp_fileFindUniqueOrThrowArgs>
    ): Prisma__tmp_fileClient<tmp_fileGetPayload<T>>

    /**
     * Find the first Tmp_file that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tmp_fileFindFirstArgs} args - Arguments to find a Tmp_file
     * @example
     * // Get one Tmp_file
     * const tmp_file = await prisma.tmp_file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends tmp_fileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, tmp_fileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'tmp_file'> extends True ? Prisma__tmp_fileClient<tmp_fileGetPayload<T>> : Prisma__tmp_fileClient<tmp_fileGetPayload<T> | null, null>

    /**
     * Find the first Tmp_file that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tmp_fileFindFirstOrThrowArgs} args - Arguments to find a Tmp_file
     * @example
     * // Get one Tmp_file
     * const tmp_file = await prisma.tmp_file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends tmp_fileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, tmp_fileFindFirstOrThrowArgs>
    ): Prisma__tmp_fileClient<tmp_fileGetPayload<T>>

    /**
     * Find zero or more Tmp_files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tmp_fileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Tmp_files
     * const tmp_files = await prisma.tmp_file.findMany()
     * 
     * // Get first 10 Tmp_files
     * const tmp_files = await prisma.tmp_file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tmp_fileWithIdOnly = await prisma.tmp_file.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends tmp_fileFindManyArgs>(
      args?: SelectSubset<T, tmp_fileFindManyArgs>
    ): Prisma.PrismaPromise<Array<tmp_fileGetPayload<T>>>

    /**
     * Create a Tmp_file.
     * @param {tmp_fileCreateArgs} args - Arguments to create a Tmp_file.
     * @example
     * // Create one Tmp_file
     * const Tmp_file = await prisma.tmp_file.create({
     *   data: {
     *     // ... data to create a Tmp_file
     *   }
     * })
     * 
    **/
    create<T extends tmp_fileCreateArgs>(
      args: SelectSubset<T, tmp_fileCreateArgs>
    ): Prisma__tmp_fileClient<tmp_fileGetPayload<T>>

    /**
     * Delete a Tmp_file.
     * @param {tmp_fileDeleteArgs} args - Arguments to delete one Tmp_file.
     * @example
     * // Delete one Tmp_file
     * const Tmp_file = await prisma.tmp_file.delete({
     *   where: {
     *     // ... filter to delete one Tmp_file
     *   }
     * })
     * 
    **/
    delete<T extends tmp_fileDeleteArgs>(
      args: SelectSubset<T, tmp_fileDeleteArgs>
    ): Prisma__tmp_fileClient<tmp_fileGetPayload<T>>

    /**
     * Update one Tmp_file.
     * @param {tmp_fileUpdateArgs} args - Arguments to update one Tmp_file.
     * @example
     * // Update one Tmp_file
     * const tmp_file = await prisma.tmp_file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends tmp_fileUpdateArgs>(
      args: SelectSubset<T, tmp_fileUpdateArgs>
    ): Prisma__tmp_fileClient<tmp_fileGetPayload<T>>

    /**
     * Delete zero or more Tmp_files.
     * @param {tmp_fileDeleteManyArgs} args - Arguments to filter Tmp_files to delete.
     * @example
     * // Delete a few Tmp_files
     * const { count } = await prisma.tmp_file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends tmp_fileDeleteManyArgs>(
      args?: SelectSubset<T, tmp_fileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Tmp_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tmp_fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Tmp_files
     * const tmp_file = await prisma.tmp_file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends tmp_fileUpdateManyArgs>(
      args: SelectSubset<T, tmp_fileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Tmp_file.
     * @param {tmp_fileUpsertArgs} args - Arguments to update or create a Tmp_file.
     * @example
     * // Update or create a Tmp_file
     * const tmp_file = await prisma.tmp_file.upsert({
     *   create: {
     *     // ... data to create a Tmp_file
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Tmp_file we want to update
     *   }
     * })
    **/
    upsert<T extends tmp_fileUpsertArgs>(
      args: SelectSubset<T, tmp_fileUpsertArgs>
    ): Prisma__tmp_fileClient<tmp_fileGetPayload<T>>

    /**
     * Count the number of Tmp_files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {tmp_fileCountArgs} args - Arguments to filter Tmp_files to count.
     * @example
     * // Count the number of Tmp_files
     * const count = await prisma.tmp_file.count({
     *   where: {
     *     // ... the filter for the Tmp_files we want to count
     *   }
     * })
    **/
    count<T extends tmp_fileCountArgs>(
      args?: Subset<T, tmp_fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Tmp_fileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Tmp_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tmp_fileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Tmp_fileAggregateArgs>(args: Subset<T, Tmp_fileAggregateArgs>): Prisma.PrismaPromise<GetTmp_fileAggregateType<T>>

    /**
     * Group by Tmp_file.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Tmp_fileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Tmp_fileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Tmp_fileGroupByArgs['orderBy'] }
        : { orderBy?: Tmp_fileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Tmp_fileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTmp_fileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for tmp_file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__tmp_fileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    drive<T extends driveArgs= {}>(args?: Subset<T, driveArgs>): Prisma__driveClient<driveGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * tmp_file base type for findUnique actions
   */
  export type tmp_fileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
    /**
     * Filter, which tmp_file to fetch.
     */
    where: tmp_fileWhereUniqueInput
  }

  /**
   * tmp_file findUnique
   */
  export interface tmp_fileFindUniqueArgs extends tmp_fileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tmp_file findUniqueOrThrow
   */
  export type tmp_fileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
    /**
     * Filter, which tmp_file to fetch.
     */
    where: tmp_fileWhereUniqueInput
  }


  /**
   * tmp_file base type for findFirst actions
   */
  export type tmp_fileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
    /**
     * Filter, which tmp_file to fetch.
     */
    where?: tmp_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tmp_files to fetch.
     */
    orderBy?: Enumerable<tmp_fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tmp_files.
     */
    cursor?: tmp_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tmp_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tmp_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tmp_files.
     */
    distinct?: Enumerable<Tmp_fileScalarFieldEnum>
  }

  /**
   * tmp_file findFirst
   */
  export interface tmp_fileFindFirstArgs extends tmp_fileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * tmp_file findFirstOrThrow
   */
  export type tmp_fileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
    /**
     * Filter, which tmp_file to fetch.
     */
    where?: tmp_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tmp_files to fetch.
     */
    orderBy?: Enumerable<tmp_fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for tmp_files.
     */
    cursor?: tmp_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tmp_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tmp_files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of tmp_files.
     */
    distinct?: Enumerable<Tmp_fileScalarFieldEnum>
  }


  /**
   * tmp_file findMany
   */
  export type tmp_fileFindManyArgs = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
    /**
     * Filter, which tmp_files to fetch.
     */
    where?: tmp_fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of tmp_files to fetch.
     */
    orderBy?: Enumerable<tmp_fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing tmp_files.
     */
    cursor?: tmp_fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` tmp_files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` tmp_files.
     */
    skip?: number
    distinct?: Enumerable<Tmp_fileScalarFieldEnum>
  }


  /**
   * tmp_file create
   */
  export type tmp_fileCreateArgs = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
    /**
     * The data needed to create a tmp_file.
     */
    data: XOR<tmp_fileCreateInput, tmp_fileUncheckedCreateInput>
  }


  /**
   * tmp_file update
   */
  export type tmp_fileUpdateArgs = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
    /**
     * The data needed to update a tmp_file.
     */
    data: XOR<tmp_fileUpdateInput, tmp_fileUncheckedUpdateInput>
    /**
     * Choose, which tmp_file to update.
     */
    where: tmp_fileWhereUniqueInput
  }


  /**
   * tmp_file updateMany
   */
  export type tmp_fileUpdateManyArgs = {
    /**
     * The data used to update tmp_files.
     */
    data: XOR<tmp_fileUpdateManyMutationInput, tmp_fileUncheckedUpdateManyInput>
    /**
     * Filter which tmp_files to update
     */
    where?: tmp_fileWhereInput
  }


  /**
   * tmp_file upsert
   */
  export type tmp_fileUpsertArgs = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
    /**
     * The filter to search for the tmp_file to update in case it exists.
     */
    where: tmp_fileWhereUniqueInput
    /**
     * In case the tmp_file found by the `where` argument doesn't exist, create a new tmp_file with this data.
     */
    create: XOR<tmp_fileCreateInput, tmp_fileUncheckedCreateInput>
    /**
     * In case the tmp_file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<tmp_fileUpdateInput, tmp_fileUncheckedUpdateInput>
  }


  /**
   * tmp_file delete
   */
  export type tmp_fileDeleteArgs = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
    /**
     * Filter which tmp_file to delete.
     */
    where: tmp_fileWhereUniqueInput
  }


  /**
   * tmp_file deleteMany
   */
  export type tmp_fileDeleteManyArgs = {
    /**
     * Filter which tmp_files to delete
     */
    where?: tmp_fileWhereInput
  }


  /**
   * tmp_file without action
   */
  export type tmp_fileArgs = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
  }



  /**
   * Model incomplete_tv
   */


  export type AggregateIncomplete_tv = {
    _count: Incomplete_tvCountAggregateOutputType | null
    _avg: Incomplete_tvAvgAggregateOutputType | null
    _sum: Incomplete_tvSumAggregateOutputType | null
    _min: Incomplete_tvMinAggregateOutputType | null
    _max: Incomplete_tvMaxAggregateOutputType | null
  }

  export type Incomplete_tvAvgAggregateOutputType = {
    episode_count: number | null
    cur_count: number | null
  }

  export type Incomplete_tvSumAggregateOutputType = {
    episode_count: number | null
    cur_count: number | null
  }

  export type Incomplete_tvMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    episode_count: number | null
    cur_count: number | null
    user_id: string | null
  }

  export type Incomplete_tvMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    episode_count: number | null
    cur_count: number | null
    user_id: string | null
  }

  export type Incomplete_tvCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    episode_count: number
    cur_count: number
    user_id: number
    _all: number
  }


  export type Incomplete_tvAvgAggregateInputType = {
    episode_count?: true
    cur_count?: true
  }

  export type Incomplete_tvSumAggregateInputType = {
    episode_count?: true
    cur_count?: true
  }

  export type Incomplete_tvMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    episode_count?: true
    cur_count?: true
    user_id?: true
  }

  export type Incomplete_tvMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    episode_count?: true
    cur_count?: true
    user_id?: true
  }

  export type Incomplete_tvCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    episode_count?: true
    cur_count?: true
    user_id?: true
    _all?: true
  }

  export type Incomplete_tvAggregateArgs = {
    /**
     * Filter which incomplete_tv to aggregate.
     */
    where?: incomplete_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incomplete_tvs to fetch.
     */
    orderBy?: Enumerable<incomplete_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: incomplete_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incomplete_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incomplete_tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned incomplete_tvs
    **/
    _count?: true | Incomplete_tvCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Incomplete_tvAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Incomplete_tvSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Incomplete_tvMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Incomplete_tvMaxAggregateInputType
  }

  export type GetIncomplete_tvAggregateType<T extends Incomplete_tvAggregateArgs> = {
        [P in keyof T & keyof AggregateIncomplete_tv]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateIncomplete_tv[P]>
      : GetScalarType<T[P], AggregateIncomplete_tv[P]>
  }




  export type Incomplete_tvGroupByArgs = {
    where?: incomplete_tvWhereInput
    orderBy?: Enumerable<incomplete_tvOrderByWithAggregationInput>
    by: Incomplete_tvScalarFieldEnum[]
    having?: incomplete_tvScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Incomplete_tvCountAggregateInputType | true
    _avg?: Incomplete_tvAvgAggregateInputType
    _sum?: Incomplete_tvSumAggregateInputType
    _min?: Incomplete_tvMinAggregateInputType
    _max?: Incomplete_tvMaxAggregateInputType
  }


  export type Incomplete_tvGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    episode_count: number | null
    cur_count: number | null
    user_id: string
    _count: Incomplete_tvCountAggregateOutputType | null
    _avg: Incomplete_tvAvgAggregateOutputType | null
    _sum: Incomplete_tvSumAggregateOutputType | null
    _min: Incomplete_tvMinAggregateOutputType | null
    _max: Incomplete_tvMaxAggregateOutputType | null
  }

  type GetIncomplete_tvGroupByPayload<T extends Incomplete_tvGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Incomplete_tvGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Incomplete_tvGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Incomplete_tvGroupByOutputType[P]>
            : GetScalarType<T[P], Incomplete_tvGroupByOutputType[P]>
        }
      >
    >


  export type incomplete_tvSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    episode_count?: boolean
    cur_count?: boolean
    user_id?: boolean
    user?: boolean | userArgs
  }


  export type incomplete_tvInclude = {
    user?: boolean | userArgs
  }

  export type incomplete_tvGetPayload<S extends boolean | null | undefined | incomplete_tvArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? incomplete_tv :
    S extends undefined ? never :
    S extends { include: any } & (incomplete_tvArgs | incomplete_tvFindManyArgs)
    ? incomplete_tv  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (incomplete_tvArgs | incomplete_tvFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof incomplete_tv ? incomplete_tv[P] : never
  } 
      : incomplete_tv


  type incomplete_tvCountArgs = 
    Omit<incomplete_tvFindManyArgs, 'select' | 'include'> & {
      select?: Incomplete_tvCountAggregateInputType | true
    }

  export interface incomplete_tvDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Incomplete_tv that matches the filter.
     * @param {incomplete_tvFindUniqueArgs} args - Arguments to find a Incomplete_tv
     * @example
     * // Get one Incomplete_tv
     * const incomplete_tv = await prisma.incomplete_tv.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends incomplete_tvFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, incomplete_tvFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'incomplete_tv'> extends True ? Prisma__incomplete_tvClient<incomplete_tvGetPayload<T>> : Prisma__incomplete_tvClient<incomplete_tvGetPayload<T> | null, null>

    /**
     * Find one Incomplete_tv that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {incomplete_tvFindUniqueOrThrowArgs} args - Arguments to find a Incomplete_tv
     * @example
     * // Get one Incomplete_tv
     * const incomplete_tv = await prisma.incomplete_tv.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends incomplete_tvFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, incomplete_tvFindUniqueOrThrowArgs>
    ): Prisma__incomplete_tvClient<incomplete_tvGetPayload<T>>

    /**
     * Find the first Incomplete_tv that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incomplete_tvFindFirstArgs} args - Arguments to find a Incomplete_tv
     * @example
     * // Get one Incomplete_tv
     * const incomplete_tv = await prisma.incomplete_tv.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends incomplete_tvFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, incomplete_tvFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'incomplete_tv'> extends True ? Prisma__incomplete_tvClient<incomplete_tvGetPayload<T>> : Prisma__incomplete_tvClient<incomplete_tvGetPayload<T> | null, null>

    /**
     * Find the first Incomplete_tv that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incomplete_tvFindFirstOrThrowArgs} args - Arguments to find a Incomplete_tv
     * @example
     * // Get one Incomplete_tv
     * const incomplete_tv = await prisma.incomplete_tv.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends incomplete_tvFindFirstOrThrowArgs>(
      args?: SelectSubset<T, incomplete_tvFindFirstOrThrowArgs>
    ): Prisma__incomplete_tvClient<incomplete_tvGetPayload<T>>

    /**
     * Find zero or more Incomplete_tvs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incomplete_tvFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Incomplete_tvs
     * const incomplete_tvs = await prisma.incomplete_tv.findMany()
     * 
     * // Get first 10 Incomplete_tvs
     * const incomplete_tvs = await prisma.incomplete_tv.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const incomplete_tvWithIdOnly = await prisma.incomplete_tv.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends incomplete_tvFindManyArgs>(
      args?: SelectSubset<T, incomplete_tvFindManyArgs>
    ): Prisma.PrismaPromise<Array<incomplete_tvGetPayload<T>>>

    /**
     * Create a Incomplete_tv.
     * @param {incomplete_tvCreateArgs} args - Arguments to create a Incomplete_tv.
     * @example
     * // Create one Incomplete_tv
     * const Incomplete_tv = await prisma.incomplete_tv.create({
     *   data: {
     *     // ... data to create a Incomplete_tv
     *   }
     * })
     * 
    **/
    create<T extends incomplete_tvCreateArgs>(
      args: SelectSubset<T, incomplete_tvCreateArgs>
    ): Prisma__incomplete_tvClient<incomplete_tvGetPayload<T>>

    /**
     * Delete a Incomplete_tv.
     * @param {incomplete_tvDeleteArgs} args - Arguments to delete one Incomplete_tv.
     * @example
     * // Delete one Incomplete_tv
     * const Incomplete_tv = await prisma.incomplete_tv.delete({
     *   where: {
     *     // ... filter to delete one Incomplete_tv
     *   }
     * })
     * 
    **/
    delete<T extends incomplete_tvDeleteArgs>(
      args: SelectSubset<T, incomplete_tvDeleteArgs>
    ): Prisma__incomplete_tvClient<incomplete_tvGetPayload<T>>

    /**
     * Update one Incomplete_tv.
     * @param {incomplete_tvUpdateArgs} args - Arguments to update one Incomplete_tv.
     * @example
     * // Update one Incomplete_tv
     * const incomplete_tv = await prisma.incomplete_tv.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends incomplete_tvUpdateArgs>(
      args: SelectSubset<T, incomplete_tvUpdateArgs>
    ): Prisma__incomplete_tvClient<incomplete_tvGetPayload<T>>

    /**
     * Delete zero or more Incomplete_tvs.
     * @param {incomplete_tvDeleteManyArgs} args - Arguments to filter Incomplete_tvs to delete.
     * @example
     * // Delete a few Incomplete_tvs
     * const { count } = await prisma.incomplete_tv.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends incomplete_tvDeleteManyArgs>(
      args?: SelectSubset<T, incomplete_tvDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Incomplete_tvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incomplete_tvUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Incomplete_tvs
     * const incomplete_tv = await prisma.incomplete_tv.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends incomplete_tvUpdateManyArgs>(
      args: SelectSubset<T, incomplete_tvUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Incomplete_tv.
     * @param {incomplete_tvUpsertArgs} args - Arguments to update or create a Incomplete_tv.
     * @example
     * // Update or create a Incomplete_tv
     * const incomplete_tv = await prisma.incomplete_tv.upsert({
     *   create: {
     *     // ... data to create a Incomplete_tv
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Incomplete_tv we want to update
     *   }
     * })
    **/
    upsert<T extends incomplete_tvUpsertArgs>(
      args: SelectSubset<T, incomplete_tvUpsertArgs>
    ): Prisma__incomplete_tvClient<incomplete_tvGetPayload<T>>

    /**
     * Count the number of Incomplete_tvs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {incomplete_tvCountArgs} args - Arguments to filter Incomplete_tvs to count.
     * @example
     * // Count the number of Incomplete_tvs
     * const count = await prisma.incomplete_tv.count({
     *   where: {
     *     // ... the filter for the Incomplete_tvs we want to count
     *   }
     * })
    **/
    count<T extends incomplete_tvCountArgs>(
      args?: Subset<T, incomplete_tvCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Incomplete_tvCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Incomplete_tv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Incomplete_tvAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Incomplete_tvAggregateArgs>(args: Subset<T, Incomplete_tvAggregateArgs>): Prisma.PrismaPromise<GetIncomplete_tvAggregateType<T>>

    /**
     * Group by Incomplete_tv.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Incomplete_tvGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Incomplete_tvGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Incomplete_tvGroupByArgs['orderBy'] }
        : { orderBy?: Incomplete_tvGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Incomplete_tvGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetIncomplete_tvGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for incomplete_tv.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__incomplete_tvClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * incomplete_tv base type for findUnique actions
   */
  export type incomplete_tvFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the incomplete_tv
     */
    select?: incomplete_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incomplete_tvInclude | null
    /**
     * Filter, which incomplete_tv to fetch.
     */
    where: incomplete_tvWhereUniqueInput
  }

  /**
   * incomplete_tv findUnique
   */
  export interface incomplete_tvFindUniqueArgs extends incomplete_tvFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * incomplete_tv findUniqueOrThrow
   */
  export type incomplete_tvFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the incomplete_tv
     */
    select?: incomplete_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incomplete_tvInclude | null
    /**
     * Filter, which incomplete_tv to fetch.
     */
    where: incomplete_tvWhereUniqueInput
  }


  /**
   * incomplete_tv base type for findFirst actions
   */
  export type incomplete_tvFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the incomplete_tv
     */
    select?: incomplete_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incomplete_tvInclude | null
    /**
     * Filter, which incomplete_tv to fetch.
     */
    where?: incomplete_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incomplete_tvs to fetch.
     */
    orderBy?: Enumerable<incomplete_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for incomplete_tvs.
     */
    cursor?: incomplete_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incomplete_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incomplete_tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of incomplete_tvs.
     */
    distinct?: Enumerable<Incomplete_tvScalarFieldEnum>
  }

  /**
   * incomplete_tv findFirst
   */
  export interface incomplete_tvFindFirstArgs extends incomplete_tvFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * incomplete_tv findFirstOrThrow
   */
  export type incomplete_tvFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the incomplete_tv
     */
    select?: incomplete_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incomplete_tvInclude | null
    /**
     * Filter, which incomplete_tv to fetch.
     */
    where?: incomplete_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incomplete_tvs to fetch.
     */
    orderBy?: Enumerable<incomplete_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for incomplete_tvs.
     */
    cursor?: incomplete_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incomplete_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incomplete_tvs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of incomplete_tvs.
     */
    distinct?: Enumerable<Incomplete_tvScalarFieldEnum>
  }


  /**
   * incomplete_tv findMany
   */
  export type incomplete_tvFindManyArgs = {
    /**
     * Select specific fields to fetch from the incomplete_tv
     */
    select?: incomplete_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incomplete_tvInclude | null
    /**
     * Filter, which incomplete_tvs to fetch.
     */
    where?: incomplete_tvWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of incomplete_tvs to fetch.
     */
    orderBy?: Enumerable<incomplete_tvOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing incomplete_tvs.
     */
    cursor?: incomplete_tvWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` incomplete_tvs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` incomplete_tvs.
     */
    skip?: number
    distinct?: Enumerable<Incomplete_tvScalarFieldEnum>
  }


  /**
   * incomplete_tv create
   */
  export type incomplete_tvCreateArgs = {
    /**
     * Select specific fields to fetch from the incomplete_tv
     */
    select?: incomplete_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incomplete_tvInclude | null
    /**
     * The data needed to create a incomplete_tv.
     */
    data: XOR<incomplete_tvCreateInput, incomplete_tvUncheckedCreateInput>
  }


  /**
   * incomplete_tv update
   */
  export type incomplete_tvUpdateArgs = {
    /**
     * Select specific fields to fetch from the incomplete_tv
     */
    select?: incomplete_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incomplete_tvInclude | null
    /**
     * The data needed to update a incomplete_tv.
     */
    data: XOR<incomplete_tvUpdateInput, incomplete_tvUncheckedUpdateInput>
    /**
     * Choose, which incomplete_tv to update.
     */
    where: incomplete_tvWhereUniqueInput
  }


  /**
   * incomplete_tv updateMany
   */
  export type incomplete_tvUpdateManyArgs = {
    /**
     * The data used to update incomplete_tvs.
     */
    data: XOR<incomplete_tvUpdateManyMutationInput, incomplete_tvUncheckedUpdateManyInput>
    /**
     * Filter which incomplete_tvs to update
     */
    where?: incomplete_tvWhereInput
  }


  /**
   * incomplete_tv upsert
   */
  export type incomplete_tvUpsertArgs = {
    /**
     * Select specific fields to fetch from the incomplete_tv
     */
    select?: incomplete_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incomplete_tvInclude | null
    /**
     * The filter to search for the incomplete_tv to update in case it exists.
     */
    where: incomplete_tvWhereUniqueInput
    /**
     * In case the incomplete_tv found by the `where` argument doesn't exist, create a new incomplete_tv with this data.
     */
    create: XOR<incomplete_tvCreateInput, incomplete_tvUncheckedCreateInput>
    /**
     * In case the incomplete_tv was found with the provided `where` argument, update it with this data.
     */
    update: XOR<incomplete_tvUpdateInput, incomplete_tvUncheckedUpdateInput>
  }


  /**
   * incomplete_tv delete
   */
  export type incomplete_tvDeleteArgs = {
    /**
     * Select specific fields to fetch from the incomplete_tv
     */
    select?: incomplete_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incomplete_tvInclude | null
    /**
     * Filter which incomplete_tv to delete.
     */
    where: incomplete_tvWhereUniqueInput
  }


  /**
   * incomplete_tv deleteMany
   */
  export type incomplete_tvDeleteManyArgs = {
    /**
     * Filter which incomplete_tvs to delete
     */
    where?: incomplete_tvWhereInput
  }


  /**
   * incomplete_tv without action
   */
  export type incomplete_tvArgs = {
    /**
     * Select specific fields to fetch from the incomplete_tv
     */
    select?: incomplete_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incomplete_tvInclude | null
  }



  /**
   * Model file
   */


  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    type: number | null
    size: number | null
  }

  export type FileSumAggregateOutputType = {
    type: number | null
    size: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    file_id: string | null
    name: string | null
    parent_file_id: string | null
    parent_paths: string | null
    type: number | null
    size: number | null
    drive_id: string | null
    user_id: string | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    file_id: string | null
    name: string | null
    parent_file_id: string | null
    parent_paths: string | null
    type: number | null
    size: number | null
    drive_id: string | null
    user_id: string | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    file_id: number
    name: number
    parent_file_id: number
    parent_paths: number
    type: number
    size: number
    drive_id: number
    user_id: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    type?: true
    size?: true
  }

  export type FileSumAggregateInputType = {
    type?: true
    size?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    file_id?: true
    name?: true
    parent_file_id?: true
    parent_paths?: true
    type?: true
    size?: true
    drive_id?: true
    user_id?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    file_id?: true
    name?: true
    parent_file_id?: true
    parent_paths?: true
    type?: true
    size?: true
    drive_id?: true
    user_id?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    file_id?: true
    name?: true
    parent_file_id?: true
    parent_paths?: true
    type?: true
    size?: true
    drive_id?: true
    user_id?: true
    _all?: true
  }

  export type FileAggregateArgs = {
    /**
     * Filter which file to aggregate.
     */
    where?: fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: Enumerable<fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs = {
    where?: fileWhereInput
    orderBy?: Enumerable<fileOrderByWithAggregationInput>
    by: FileScalarFieldEnum[]
    having?: fileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }


  export type FileGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    file_id: string
    name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size: number | null
    drive_id: string
    user_id: string
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type fileSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    file_id?: boolean
    name?: boolean
    parent_file_id?: boolean
    parent_paths?: boolean
    type?: boolean
    size?: boolean
    drive_id?: boolean
    user_id?: boolean
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }


  export type fileInclude = {
    drive?: boolean | driveArgs
    user?: boolean | userArgs
  }

  export type fileGetPayload<S extends boolean | null | undefined | fileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? file :
    S extends undefined ? never :
    S extends { include: any } & (fileArgs | fileFindManyArgs)
    ? file  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'drive' ? driveGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (fileArgs | fileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'drive' ? driveGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof file ? file[P] : never
  } 
      : file


  type fileCountArgs = 
    Omit<fileFindManyArgs, 'select' | 'include'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface fileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one File that matches the filter.
     * @param {fileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends fileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, fileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'file'> extends True ? Prisma__fileClient<fileGetPayload<T>> : Prisma__fileClient<fileGetPayload<T> | null, null>

    /**
     * Find one File that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {fileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends fileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, fileFindUniqueOrThrowArgs>
    ): Prisma__fileClient<fileGetPayload<T>>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends fileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, fileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'file'> extends True ? Prisma__fileClient<fileGetPayload<T>> : Prisma__fileClient<fileGetPayload<T> | null, null>

    /**
     * Find the first File that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends fileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, fileFindFirstOrThrowArgs>
    ): Prisma__fileClient<fileGetPayload<T>>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends fileFindManyArgs>(
      args?: SelectSubset<T, fileFindManyArgs>
    ): Prisma.PrismaPromise<Array<fileGetPayload<T>>>

    /**
     * Create a File.
     * @param {fileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
    **/
    create<T extends fileCreateArgs>(
      args: SelectSubset<T, fileCreateArgs>
    ): Prisma__fileClient<fileGetPayload<T>>

    /**
     * Delete a File.
     * @param {fileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
    **/
    delete<T extends fileDeleteArgs>(
      args: SelectSubset<T, fileDeleteArgs>
    ): Prisma__fileClient<fileGetPayload<T>>

    /**
     * Update one File.
     * @param {fileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends fileUpdateArgs>(
      args: SelectSubset<T, fileUpdateArgs>
    ): Prisma__fileClient<fileGetPayload<T>>

    /**
     * Delete zero or more Files.
     * @param {fileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends fileDeleteManyArgs>(
      args?: SelectSubset<T, fileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends fileUpdateManyArgs>(
      args: SelectSubset<T, fileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one File.
     * @param {fileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
    **/
    upsert<T extends fileUpsertArgs>(
      args: SelectSubset<T, fileUpsertArgs>
    ): Prisma__fileClient<fileGetPayload<T>>

    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {fileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends fileCountArgs>(
      args?: Subset<T, fileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for file.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__fileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    drive<T extends driveArgs= {}>(args?: Subset<T, driveArgs>): Prisma__driveClient<driveGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * file base type for findUnique actions
   */
  export type fileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
    /**
     * Filter, which file to fetch.
     */
    where: fileWhereUniqueInput
  }

  /**
   * file findUnique
   */
  export interface fileFindUniqueArgs extends fileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * file findUniqueOrThrow
   */
  export type fileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
    /**
     * Filter, which file to fetch.
     */
    where: fileWhereUniqueInput
  }


  /**
   * file base type for findFirst actions
   */
  export type fileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
    /**
     * Filter, which file to fetch.
     */
    where?: fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: Enumerable<fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: Enumerable<FileScalarFieldEnum>
  }

  /**
   * file findFirst
   */
  export interface fileFindFirstArgs extends fileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * file findFirstOrThrow
   */
  export type fileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
    /**
     * Filter, which file to fetch.
     */
    where?: fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: Enumerable<fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for files.
     */
    cursor?: fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of files.
     */
    distinct?: Enumerable<FileScalarFieldEnum>
  }


  /**
   * file findMany
   */
  export type fileFindManyArgs = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
    /**
     * Filter, which files to fetch.
     */
    where?: fileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of files to fetch.
     */
    orderBy?: Enumerable<fileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing files.
     */
    cursor?: fileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` files.
     */
    skip?: number
    distinct?: Enumerable<FileScalarFieldEnum>
  }


  /**
   * file create
   */
  export type fileCreateArgs = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
    /**
     * The data needed to create a file.
     */
    data: XOR<fileCreateInput, fileUncheckedCreateInput>
  }


  /**
   * file update
   */
  export type fileUpdateArgs = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
    /**
     * The data needed to update a file.
     */
    data: XOR<fileUpdateInput, fileUncheckedUpdateInput>
    /**
     * Choose, which file to update.
     */
    where: fileWhereUniqueInput
  }


  /**
   * file updateMany
   */
  export type fileUpdateManyArgs = {
    /**
     * The data used to update files.
     */
    data: XOR<fileUpdateManyMutationInput, fileUncheckedUpdateManyInput>
    /**
     * Filter which files to update
     */
    where?: fileWhereInput
  }


  /**
   * file upsert
   */
  export type fileUpsertArgs = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
    /**
     * The filter to search for the file to update in case it exists.
     */
    where: fileWhereUniqueInput
    /**
     * In case the file found by the `where` argument doesn't exist, create a new file with this data.
     */
    create: XOR<fileCreateInput, fileUncheckedCreateInput>
    /**
     * In case the file was found with the provided `where` argument, update it with this data.
     */
    update: XOR<fileUpdateInput, fileUncheckedUpdateInput>
  }


  /**
   * file delete
   */
  export type fileDeleteArgs = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
    /**
     * Filter which file to delete.
     */
    where: fileWhereUniqueInput
  }


  /**
   * file deleteMany
   */
  export type fileDeleteManyArgs = {
    /**
     * Filter which files to delete
     */
    where?: fileWhereInput
  }


  /**
   * file without action
   */
  export type fileArgs = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
  }



  /**
   * Model log
   */


  export type AggregateLog = {
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  export type LogMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    title: string | null
  }

  export type LogMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    title: string | null
  }

  export type LogCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    title: number
    _all: number
  }


  export type LogMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    title?: true
  }

  export type LogMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    title?: true
  }

  export type LogCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    title?: true
    _all?: true
  }

  export type LogAggregateArgs = {
    /**
     * Filter which log to aggregate.
     */
    where?: logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: Enumerable<logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned logs
    **/
    _count?: true | LogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LogMaxAggregateInputType
  }

  export type GetLogAggregateType<T extends LogAggregateArgs> = {
        [P in keyof T & keyof AggregateLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLog[P]>
      : GetScalarType<T[P], AggregateLog[P]>
  }




  export type LogGroupByArgs = {
    where?: logWhereInput
    orderBy?: Enumerable<logOrderByWithAggregationInput>
    by: LogScalarFieldEnum[]
    having?: logScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LogCountAggregateInputType | true
    _min?: LogMinAggregateInputType
    _max?: LogMaxAggregateInputType
  }


  export type LogGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    title: string
    _count: LogCountAggregateOutputType | null
    _min: LogMinAggregateOutputType | null
    _max: LogMaxAggregateOutputType | null
  }

  type GetLogGroupByPayload<T extends LogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<LogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LogGroupByOutputType[P]>
            : GetScalarType<T[P], LogGroupByOutputType[P]>
        }
      >
    >


  export type logSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    title?: boolean
  }


  export type logGetPayload<S extends boolean | null | undefined | logArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? log :
    S extends undefined ? never :
    S extends { include: any } & (logArgs | logFindManyArgs)
    ? log 
    : S extends { select: any } & (logArgs | logFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
    P extends keyof log ? log[P] : never
  } 
      : log


  type logCountArgs = 
    Omit<logFindManyArgs, 'select' | 'include'> & {
      select?: LogCountAggregateInputType | true
    }

  export interface logDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Log that matches the filter.
     * @param {logFindUniqueArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends logFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, logFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'log'> extends True ? Prisma__logClient<logGetPayload<T>> : Prisma__logClient<logGetPayload<T> | null, null>

    /**
     * Find one Log that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {logFindUniqueOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends logFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, logFindUniqueOrThrowArgs>
    ): Prisma__logClient<logGetPayload<T>>

    /**
     * Find the first Log that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logFindFirstArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends logFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, logFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'log'> extends True ? Prisma__logClient<logGetPayload<T>> : Prisma__logClient<logGetPayload<T> | null, null>

    /**
     * Find the first Log that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logFindFirstOrThrowArgs} args - Arguments to find a Log
     * @example
     * // Get one Log
     * const log = await prisma.log.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends logFindFirstOrThrowArgs>(
      args?: SelectSubset<T, logFindFirstOrThrowArgs>
    ): Prisma__logClient<logGetPayload<T>>

    /**
     * Find zero or more Logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Logs
     * const logs = await prisma.log.findMany()
     * 
     * // Get first 10 Logs
     * const logs = await prisma.log.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const logWithIdOnly = await prisma.log.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends logFindManyArgs>(
      args?: SelectSubset<T, logFindManyArgs>
    ): Prisma.PrismaPromise<Array<logGetPayload<T>>>

    /**
     * Create a Log.
     * @param {logCreateArgs} args - Arguments to create a Log.
     * @example
     * // Create one Log
     * const Log = await prisma.log.create({
     *   data: {
     *     // ... data to create a Log
     *   }
     * })
     * 
    **/
    create<T extends logCreateArgs>(
      args: SelectSubset<T, logCreateArgs>
    ): Prisma__logClient<logGetPayload<T>>

    /**
     * Delete a Log.
     * @param {logDeleteArgs} args - Arguments to delete one Log.
     * @example
     * // Delete one Log
     * const Log = await prisma.log.delete({
     *   where: {
     *     // ... filter to delete one Log
     *   }
     * })
     * 
    **/
    delete<T extends logDeleteArgs>(
      args: SelectSubset<T, logDeleteArgs>
    ): Prisma__logClient<logGetPayload<T>>

    /**
     * Update one Log.
     * @param {logUpdateArgs} args - Arguments to update one Log.
     * @example
     * // Update one Log
     * const log = await prisma.log.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends logUpdateArgs>(
      args: SelectSubset<T, logUpdateArgs>
    ): Prisma__logClient<logGetPayload<T>>

    /**
     * Delete zero or more Logs.
     * @param {logDeleteManyArgs} args - Arguments to filter Logs to delete.
     * @example
     * // Delete a few Logs
     * const { count } = await prisma.log.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends logDeleteManyArgs>(
      args?: SelectSubset<T, logDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Logs
     * const log = await prisma.log.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends logUpdateManyArgs>(
      args: SelectSubset<T, logUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Log.
     * @param {logUpsertArgs} args - Arguments to update or create a Log.
     * @example
     * // Update or create a Log
     * const log = await prisma.log.upsert({
     *   create: {
     *     // ... data to create a Log
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Log we want to update
     *   }
     * })
    **/
    upsert<T extends logUpsertArgs>(
      args: SelectSubset<T, logUpsertArgs>
    ): Prisma__logClient<logGetPayload<T>>

    /**
     * Count the number of Logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {logCountArgs} args - Arguments to filter Logs to count.
     * @example
     * // Count the number of Logs
     * const count = await prisma.log.count({
     *   where: {
     *     // ... the filter for the Logs we want to count
     *   }
     * })
    **/
    count<T extends logCountArgs>(
      args?: Subset<T, logCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LogAggregateArgs>(args: Subset<T, LogAggregateArgs>): Prisma.PrismaPromise<GetLogAggregateType<T>>

    /**
     * Group by Log.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LogGroupByArgs['orderBy'] }
        : { orderBy?: LogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for log.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__logClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);


    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * log base type for findUnique actions
   */
  export type logFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect | null
    /**
     * Filter, which log to fetch.
     */
    where: logWhereUniqueInput
  }

  /**
   * log findUnique
   */
  export interface logFindUniqueArgs extends logFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * log findUniqueOrThrow
   */
  export type logFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect | null
    /**
     * Filter, which log to fetch.
     */
    where: logWhereUniqueInput
  }


  /**
   * log base type for findFirst actions
   */
  export type logFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect | null
    /**
     * Filter, which log to fetch.
     */
    where?: logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: Enumerable<logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs.
     */
    cursor?: logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs.
     */
    distinct?: Enumerable<LogScalarFieldEnum>
  }

  /**
   * log findFirst
   */
  export interface logFindFirstArgs extends logFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * log findFirstOrThrow
   */
  export type logFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect | null
    /**
     * Filter, which log to fetch.
     */
    where?: logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: Enumerable<logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for logs.
     */
    cursor?: logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of logs.
     */
    distinct?: Enumerable<LogScalarFieldEnum>
  }


  /**
   * log findMany
   */
  export type logFindManyArgs = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect | null
    /**
     * Filter, which logs to fetch.
     */
    where?: logWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of logs to fetch.
     */
    orderBy?: Enumerable<logOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing logs.
     */
    cursor?: logWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` logs.
     */
    skip?: number
    distinct?: Enumerable<LogScalarFieldEnum>
  }


  /**
   * log create
   */
  export type logCreateArgs = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect | null
    /**
     * The data needed to create a log.
     */
    data: XOR<logCreateInput, logUncheckedCreateInput>
  }


  /**
   * log update
   */
  export type logUpdateArgs = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect | null
    /**
     * The data needed to update a log.
     */
    data: XOR<logUpdateInput, logUncheckedUpdateInput>
    /**
     * Choose, which log to update.
     */
    where: logWhereUniqueInput
  }


  /**
   * log updateMany
   */
  export type logUpdateManyArgs = {
    /**
     * The data used to update logs.
     */
    data: XOR<logUpdateManyMutationInput, logUncheckedUpdateManyInput>
    /**
     * Filter which logs to update
     */
    where?: logWhereInput
  }


  /**
   * log upsert
   */
  export type logUpsertArgs = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect | null
    /**
     * The filter to search for the log to update in case it exists.
     */
    where: logWhereUniqueInput
    /**
     * In case the log found by the `where` argument doesn't exist, create a new log with this data.
     */
    create: XOR<logCreateInput, logUncheckedCreateInput>
    /**
     * In case the log was found with the provided `where` argument, update it with this data.
     */
    update: XOR<logUpdateInput, logUncheckedUpdateInput>
  }


  /**
   * log delete
   */
  export type logDeleteArgs = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect | null
    /**
     * Filter which log to delete.
     */
    where: logWhereUniqueInput
  }


  /**
   * log deleteMany
   */
  export type logDeleteManyArgs = {
    /**
     * Filter which logs to delete
     */
    where?: logWhereInput
  }


  /**
   * log without action
   */
  export type logArgs = {
    /**
     * Select specific fields to fetch from the log
     */
    select?: logSelect | null
  }



  /**
   * Model member
   */


  export type AggregateMember = {
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  export type MemberAvgAggregateOutputType = {
    disabled: number | null
    delete: number | null
  }

  export type MemberSumAggregateOutputType = {
    disabled: number | null
    delete: number | null
  }

  export type MemberMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    email: string | null
    name: string | null
    avatar: string | null
    remark: string | null
    permission: string | null
    disabled: number | null
    delete: number | null
    inviter_id: string | null
    user_id: string | null
  }

  export type MemberMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    email: string | null
    name: string | null
    avatar: string | null
    remark: string | null
    permission: string | null
    disabled: number | null
    delete: number | null
    inviter_id: string | null
    user_id: string | null
  }

  export type MemberCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    email: number
    name: number
    avatar: number
    remark: number
    permission: number
    disabled: number
    delete: number
    inviter_id: number
    user_id: number
    _all: number
  }


  export type MemberAvgAggregateInputType = {
    disabled?: true
    delete?: true
  }

  export type MemberSumAggregateInputType = {
    disabled?: true
    delete?: true
  }

  export type MemberMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    email?: true
    name?: true
    avatar?: true
    remark?: true
    permission?: true
    disabled?: true
    delete?: true
    inviter_id?: true
    user_id?: true
  }

  export type MemberMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    email?: true
    name?: true
    avatar?: true
    remark?: true
    permission?: true
    disabled?: true
    delete?: true
    inviter_id?: true
    user_id?: true
  }

  export type MemberCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    email?: true
    name?: true
    avatar?: true
    remark?: true
    permission?: true
    disabled?: true
    delete?: true
    inviter_id?: true
    user_id?: true
    _all?: true
  }

  export type MemberAggregateArgs = {
    /**
     * Filter which member to aggregate.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: Enumerable<memberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned members
    **/
    _count?: true | MemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MemberAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MemberSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MemberMaxAggregateInputType
  }

  export type GetMemberAggregateType<T extends MemberAggregateArgs> = {
        [P in keyof T & keyof AggregateMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember[P]>
      : GetScalarType<T[P], AggregateMember[P]>
  }




  export type MemberGroupByArgs = {
    where?: memberWhereInput
    orderBy?: Enumerable<memberOrderByWithAggregationInput>
    by: MemberScalarFieldEnum[]
    having?: memberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MemberCountAggregateInputType | true
    _avg?: MemberAvgAggregateInputType
    _sum?: MemberSumAggregateInputType
    _min?: MemberMinAggregateInputType
    _max?: MemberMaxAggregateInputType
  }


  export type MemberGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    email: string | null
    name: string | null
    avatar: string | null
    remark: string
    permission: string | null
    disabled: number | null
    delete: number | null
    inviter_id: string | null
    user_id: string
    _count: MemberCountAggregateOutputType | null
    _avg: MemberAvgAggregateOutputType | null
    _sum: MemberSumAggregateOutputType | null
    _min: MemberMinAggregateOutputType | null
    _max: MemberMaxAggregateOutputType | null
  }

  type GetMemberGroupByPayload<T extends MemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<MemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MemberGroupByOutputType[P]>
            : GetScalarType<T[P], MemberGroupByOutputType[P]>
        }
      >
    >


  export type memberSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    email?: boolean
    name?: boolean
    avatar?: boolean
    remark?: boolean
    permission?: boolean
    disabled?: boolean
    delete?: boolean
    inviter_id?: boolean
    user_id?: boolean
    inviter?: boolean | memberArgs
    user?: boolean | userArgs
    member_setting?: boolean | member_settingArgs
    member_tokens?: boolean | member$member_tokensArgs
    play_histories?: boolean | member$play_historiesArgs
    reports?: boolean | member$reportsArgs
    invitees?: boolean | member$inviteesArgs
    notifications?: boolean | member$notificationsArgs
    _count?: boolean | MemberCountOutputTypeArgs
  }


  export type memberInclude = {
    inviter?: boolean | memberArgs
    user?: boolean | userArgs
    member_setting?: boolean | member_settingArgs
    member_tokens?: boolean | member$member_tokensArgs
    play_histories?: boolean | member$play_historiesArgs
    reports?: boolean | member$reportsArgs
    invitees?: boolean | member$inviteesArgs
    notifications?: boolean | member$notificationsArgs
    _count?: boolean | MemberCountOutputTypeArgs
  }

  export type memberGetPayload<S extends boolean | null | undefined | memberArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? member :
    S extends undefined ? never :
    S extends { include: any } & (memberArgs | memberFindManyArgs)
    ? member  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'inviter' ? memberGetPayload<S['include'][P]> | null :
        P extends 'user' ? userGetPayload<S['include'][P]> :
        P extends 'member_setting' ? member_settingGetPayload<S['include'][P]> | null :
        P extends 'member_tokens' ? Array < member_tokenGetPayload<S['include'][P]>>  :
        P extends 'play_histories' ? Array < play_historyGetPayload<S['include'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'invitees' ? Array < memberGetPayload<S['include'][P]>>  :
        P extends 'notifications' ? Array < member_notificationGetPayload<S['include'][P]>>  :
        P extends '_count' ? MemberCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (memberArgs | memberFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'inviter' ? memberGetPayload<S['select'][P]> | null :
        P extends 'user' ? userGetPayload<S['select'][P]> :
        P extends 'member_setting' ? member_settingGetPayload<S['select'][P]> | null :
        P extends 'member_tokens' ? Array < member_tokenGetPayload<S['select'][P]>>  :
        P extends 'play_histories' ? Array < play_historyGetPayload<S['select'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'invitees' ? Array < memberGetPayload<S['select'][P]>>  :
        P extends 'notifications' ? Array < member_notificationGetPayload<S['select'][P]>>  :
        P extends '_count' ? MemberCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof member ? member[P] : never
  } 
      : member


  type memberCountArgs = 
    Omit<memberFindManyArgs, 'select' | 'include'> & {
      select?: MemberCountAggregateInputType | true
    }

  export interface memberDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Member that matches the filter.
     * @param {memberFindUniqueArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends memberFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, memberFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'member'> extends True ? Prisma__memberClient<memberGetPayload<T>> : Prisma__memberClient<memberGetPayload<T> | null, null>

    /**
     * Find one Member that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {memberFindUniqueOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends memberFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, memberFindUniqueOrThrowArgs>
    ): Prisma__memberClient<memberGetPayload<T>>

    /**
     * Find the first Member that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindFirstArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends memberFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, memberFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'member'> extends True ? Prisma__memberClient<memberGetPayload<T>> : Prisma__memberClient<memberGetPayload<T> | null, null>

    /**
     * Find the first Member that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindFirstOrThrowArgs} args - Arguments to find a Member
     * @example
     * // Get one Member
     * const member = await prisma.member.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends memberFindFirstOrThrowArgs>(
      args?: SelectSubset<T, memberFindFirstOrThrowArgs>
    ): Prisma__memberClient<memberGetPayload<T>>

    /**
     * Find zero or more Members that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Members
     * const members = await prisma.member.findMany()
     * 
     * // Get first 10 Members
     * const members = await prisma.member.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const memberWithIdOnly = await prisma.member.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends memberFindManyArgs>(
      args?: SelectSubset<T, memberFindManyArgs>
    ): Prisma.PrismaPromise<Array<memberGetPayload<T>>>

    /**
     * Create a Member.
     * @param {memberCreateArgs} args - Arguments to create a Member.
     * @example
     * // Create one Member
     * const Member = await prisma.member.create({
     *   data: {
     *     // ... data to create a Member
     *   }
     * })
     * 
    **/
    create<T extends memberCreateArgs>(
      args: SelectSubset<T, memberCreateArgs>
    ): Prisma__memberClient<memberGetPayload<T>>

    /**
     * Delete a Member.
     * @param {memberDeleteArgs} args - Arguments to delete one Member.
     * @example
     * // Delete one Member
     * const Member = await prisma.member.delete({
     *   where: {
     *     // ... filter to delete one Member
     *   }
     * })
     * 
    **/
    delete<T extends memberDeleteArgs>(
      args: SelectSubset<T, memberDeleteArgs>
    ): Prisma__memberClient<memberGetPayload<T>>

    /**
     * Update one Member.
     * @param {memberUpdateArgs} args - Arguments to update one Member.
     * @example
     * // Update one Member
     * const member = await prisma.member.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends memberUpdateArgs>(
      args: SelectSubset<T, memberUpdateArgs>
    ): Prisma__memberClient<memberGetPayload<T>>

    /**
     * Delete zero or more Members.
     * @param {memberDeleteManyArgs} args - Arguments to filter Members to delete.
     * @example
     * // Delete a few Members
     * const { count } = await prisma.member.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends memberDeleteManyArgs>(
      args?: SelectSubset<T, memberDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Members
     * const member = await prisma.member.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends memberUpdateManyArgs>(
      args: SelectSubset<T, memberUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member.
     * @param {memberUpsertArgs} args - Arguments to update or create a Member.
     * @example
     * // Update or create a Member
     * const member = await prisma.member.upsert({
     *   create: {
     *     // ... data to create a Member
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member we want to update
     *   }
     * })
    **/
    upsert<T extends memberUpsertArgs>(
      args: SelectSubset<T, memberUpsertArgs>
    ): Prisma__memberClient<memberGetPayload<T>>

    /**
     * Count the number of Members.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {memberCountArgs} args - Arguments to filter Members to count.
     * @example
     * // Count the number of Members
     * const count = await prisma.member.count({
     *   where: {
     *     // ... the filter for the Members we want to count
     *   }
     * })
    **/
    count<T extends memberCountArgs>(
      args?: Subset<T, memberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MemberAggregateArgs>(args: Subset<T, MemberAggregateArgs>): Prisma.PrismaPromise<GetMemberAggregateType<T>>

    /**
     * Group by Member.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MemberGroupByArgs['orderBy'] }
        : { orderBy?: MemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for member.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__memberClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    inviter<T extends memberArgs= {}>(args?: Subset<T, memberArgs>): Prisma__memberClient<memberGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    member_setting<T extends member_settingArgs= {}>(args?: Subset<T, member_settingArgs>): Prisma__member_settingClient<member_settingGetPayload<T> | Null>;

    member_tokens<T extends member$member_tokensArgs= {}>(args?: Subset<T, member$member_tokensArgs>): Prisma.PrismaPromise<Array<member_tokenGetPayload<T>>| Null>;

    play_histories<T extends member$play_historiesArgs= {}>(args?: Subset<T, member$play_historiesArgs>): Prisma.PrismaPromise<Array<play_historyGetPayload<T>>| Null>;

    reports<T extends member$reportsArgs= {}>(args?: Subset<T, member$reportsArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    invitees<T extends member$inviteesArgs= {}>(args?: Subset<T, member$inviteesArgs>): Prisma.PrismaPromise<Array<memberGetPayload<T>>| Null>;

    notifications<T extends member$notificationsArgs= {}>(args?: Subset<T, member$notificationsArgs>): Prisma.PrismaPromise<Array<member_notificationGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * member base type for findUnique actions
   */
  export type memberFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
    /**
     * Filter, which member to fetch.
     */
    where: memberWhereUniqueInput
  }

  /**
   * member findUnique
   */
  export interface memberFindUniqueArgs extends memberFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * member findUniqueOrThrow
   */
  export type memberFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
    /**
     * Filter, which member to fetch.
     */
    where: memberWhereUniqueInput
  }


  /**
   * member base type for findFirst actions
   */
  export type memberFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
    /**
     * Filter, which member to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: Enumerable<memberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of members.
     */
    distinct?: Enumerable<MemberScalarFieldEnum>
  }

  /**
   * member findFirst
   */
  export interface memberFindFirstArgs extends memberFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * member findFirstOrThrow
   */
  export type memberFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
    /**
     * Filter, which member to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: Enumerable<memberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of members.
     */
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * member findMany
   */
  export type memberFindManyArgs = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
    /**
     * Filter, which members to fetch.
     */
    where?: memberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of members to fetch.
     */
    orderBy?: Enumerable<memberOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing members.
     */
    cursor?: memberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` members from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` members.
     */
    skip?: number
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * member create
   */
  export type memberCreateArgs = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
    /**
     * The data needed to create a member.
     */
    data: XOR<memberCreateInput, memberUncheckedCreateInput>
  }


  /**
   * member update
   */
  export type memberUpdateArgs = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
    /**
     * The data needed to update a member.
     */
    data: XOR<memberUpdateInput, memberUncheckedUpdateInput>
    /**
     * Choose, which member to update.
     */
    where: memberWhereUniqueInput
  }


  /**
   * member updateMany
   */
  export type memberUpdateManyArgs = {
    /**
     * The data used to update members.
     */
    data: XOR<memberUpdateManyMutationInput, memberUncheckedUpdateManyInput>
    /**
     * Filter which members to update
     */
    where?: memberWhereInput
  }


  /**
   * member upsert
   */
  export type memberUpsertArgs = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
    /**
     * The filter to search for the member to update in case it exists.
     */
    where: memberWhereUniqueInput
    /**
     * In case the member found by the `where` argument doesn't exist, create a new member with this data.
     */
    create: XOR<memberCreateInput, memberUncheckedCreateInput>
    /**
     * In case the member was found with the provided `where` argument, update it with this data.
     */
    update: XOR<memberUpdateInput, memberUncheckedUpdateInput>
  }


  /**
   * member delete
   */
  export type memberDeleteArgs = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
    /**
     * Filter which member to delete.
     */
    where: memberWhereUniqueInput
  }


  /**
   * member deleteMany
   */
  export type memberDeleteManyArgs = {
    /**
     * Filter which members to delete
     */
    where?: memberWhereInput
  }


  /**
   * member.member_tokens
   */
  export type member$member_tokensArgs = {
    /**
     * Select specific fields to fetch from the member_token
     */
    select?: member_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_tokenInclude | null
    where?: member_tokenWhereInput
    orderBy?: Enumerable<member_tokenOrderByWithRelationInput>
    cursor?: member_tokenWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Member_tokenScalarFieldEnum>
  }


  /**
   * member.play_histories
   */
  export type member$play_historiesArgs = {
    /**
     * Select specific fields to fetch from the play_history
     */
    select?: play_historySelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: play_historyInclude | null
    where?: play_historyWhereInput
    orderBy?: Enumerable<play_historyOrderByWithRelationInput>
    cursor?: play_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Play_historyScalarFieldEnum>
  }


  /**
   * member.reports
   */
  export type member$reportsArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * member.invitees
   */
  export type member$inviteesArgs = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
    where?: memberWhereInput
    orderBy?: Enumerable<memberOrderByWithRelationInput>
    cursor?: memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * member.notifications
   */
  export type member$notificationsArgs = {
    /**
     * Select specific fields to fetch from the member_notification
     */
    select?: member_notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_notificationInclude | null
    where?: member_notificationWhereInput
    orderBy?: Enumerable<member_notificationOrderByWithRelationInput>
    cursor?: member_notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Member_notificationScalarFieldEnum>
  }


  /**
   * member without action
   */
  export type memberArgs = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
  }



  /**
   * Model member_token
   */


  export type AggregateMember_token = {
    _count: Member_tokenCountAggregateOutputType | null
    _avg: Member_tokenAvgAggregateOutputType | null
    _sum: Member_tokenSumAggregateOutputType | null
    _min: Member_tokenMinAggregateOutputType | null
    _max: Member_tokenMaxAggregateOutputType | null
  }

  export type Member_tokenAvgAggregateOutputType = {
    used: number | null
  }

  export type Member_tokenSumAggregateOutputType = {
    used: number | null
  }

  export type Member_tokenMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    token: string | null
    used: number | null
    expired_at: string | null
    member_id: string | null
  }

  export type Member_tokenMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    token: string | null
    used: number | null
    expired_at: string | null
    member_id: string | null
  }

  export type Member_tokenCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    token: number
    used: number
    expired_at: number
    member_id: number
    _all: number
  }


  export type Member_tokenAvgAggregateInputType = {
    used?: true
  }

  export type Member_tokenSumAggregateInputType = {
    used?: true
  }

  export type Member_tokenMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    token?: true
    used?: true
    expired_at?: true
    member_id?: true
  }

  export type Member_tokenMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    token?: true
    used?: true
    expired_at?: true
    member_id?: true
  }

  export type Member_tokenCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    token?: true
    used?: true
    expired_at?: true
    member_id?: true
    _all?: true
  }

  export type Member_tokenAggregateArgs = {
    /**
     * Filter which member_token to aggregate.
     */
    where?: member_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_tokens to fetch.
     */
    orderBy?: Enumerable<member_tokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: member_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned member_tokens
    **/
    _count?: true | Member_tokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Member_tokenAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Member_tokenSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Member_tokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Member_tokenMaxAggregateInputType
  }

  export type GetMember_tokenAggregateType<T extends Member_tokenAggregateArgs> = {
        [P in keyof T & keyof AggregateMember_token]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember_token[P]>
      : GetScalarType<T[P], AggregateMember_token[P]>
  }




  export type Member_tokenGroupByArgs = {
    where?: member_tokenWhereInput
    orderBy?: Enumerable<member_tokenOrderByWithAggregationInput>
    by: Member_tokenScalarFieldEnum[]
    having?: member_tokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Member_tokenCountAggregateInputType | true
    _avg?: Member_tokenAvgAggregateInputType
    _sum?: Member_tokenSumAggregateInputType
    _min?: Member_tokenMinAggregateInputType
    _max?: Member_tokenMaxAggregateInputType
  }


  export type Member_tokenGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    token: string
    used: number | null
    expired_at: string | null
    member_id: string
    _count: Member_tokenCountAggregateOutputType | null
    _avg: Member_tokenAvgAggregateOutputType | null
    _sum: Member_tokenSumAggregateOutputType | null
    _min: Member_tokenMinAggregateOutputType | null
    _max: Member_tokenMaxAggregateOutputType | null
  }

  type GetMember_tokenGroupByPayload<T extends Member_tokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Member_tokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Member_tokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Member_tokenGroupByOutputType[P]>
            : GetScalarType<T[P], Member_tokenGroupByOutputType[P]>
        }
      >
    >


  export type member_tokenSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    token?: boolean
    used?: boolean
    expired_at?: boolean
    member_id?: boolean
    member?: boolean | memberArgs
  }


  export type member_tokenInclude = {
    member?: boolean | memberArgs
  }

  export type member_tokenGetPayload<S extends boolean | null | undefined | member_tokenArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? member_token :
    S extends undefined ? never :
    S extends { include: any } & (member_tokenArgs | member_tokenFindManyArgs)
    ? member_token  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'member' ? memberGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (member_tokenArgs | member_tokenFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'member' ? memberGetPayload<S['select'][P]> :  P extends keyof member_token ? member_token[P] : never
  } 
      : member_token


  type member_tokenCountArgs = 
    Omit<member_tokenFindManyArgs, 'select' | 'include'> & {
      select?: Member_tokenCountAggregateInputType | true
    }

  export interface member_tokenDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Member_token that matches the filter.
     * @param {member_tokenFindUniqueArgs} args - Arguments to find a Member_token
     * @example
     * // Get one Member_token
     * const member_token = await prisma.member_token.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends member_tokenFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, member_tokenFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'member_token'> extends True ? Prisma__member_tokenClient<member_tokenGetPayload<T>> : Prisma__member_tokenClient<member_tokenGetPayload<T> | null, null>

    /**
     * Find one Member_token that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {member_tokenFindUniqueOrThrowArgs} args - Arguments to find a Member_token
     * @example
     * // Get one Member_token
     * const member_token = await prisma.member_token.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends member_tokenFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, member_tokenFindUniqueOrThrowArgs>
    ): Prisma__member_tokenClient<member_tokenGetPayload<T>>

    /**
     * Find the first Member_token that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_tokenFindFirstArgs} args - Arguments to find a Member_token
     * @example
     * // Get one Member_token
     * const member_token = await prisma.member_token.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends member_tokenFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, member_tokenFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'member_token'> extends True ? Prisma__member_tokenClient<member_tokenGetPayload<T>> : Prisma__member_tokenClient<member_tokenGetPayload<T> | null, null>

    /**
     * Find the first Member_token that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_tokenFindFirstOrThrowArgs} args - Arguments to find a Member_token
     * @example
     * // Get one Member_token
     * const member_token = await prisma.member_token.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends member_tokenFindFirstOrThrowArgs>(
      args?: SelectSubset<T, member_tokenFindFirstOrThrowArgs>
    ): Prisma__member_tokenClient<member_tokenGetPayload<T>>

    /**
     * Find zero or more Member_tokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_tokenFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Member_tokens
     * const member_tokens = await prisma.member_token.findMany()
     * 
     * // Get first 10 Member_tokens
     * const member_tokens = await prisma.member_token.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const member_tokenWithIdOnly = await prisma.member_token.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends member_tokenFindManyArgs>(
      args?: SelectSubset<T, member_tokenFindManyArgs>
    ): Prisma.PrismaPromise<Array<member_tokenGetPayload<T>>>

    /**
     * Create a Member_token.
     * @param {member_tokenCreateArgs} args - Arguments to create a Member_token.
     * @example
     * // Create one Member_token
     * const Member_token = await prisma.member_token.create({
     *   data: {
     *     // ... data to create a Member_token
     *   }
     * })
     * 
    **/
    create<T extends member_tokenCreateArgs>(
      args: SelectSubset<T, member_tokenCreateArgs>
    ): Prisma__member_tokenClient<member_tokenGetPayload<T>>

    /**
     * Delete a Member_token.
     * @param {member_tokenDeleteArgs} args - Arguments to delete one Member_token.
     * @example
     * // Delete one Member_token
     * const Member_token = await prisma.member_token.delete({
     *   where: {
     *     // ... filter to delete one Member_token
     *   }
     * })
     * 
    **/
    delete<T extends member_tokenDeleteArgs>(
      args: SelectSubset<T, member_tokenDeleteArgs>
    ): Prisma__member_tokenClient<member_tokenGetPayload<T>>

    /**
     * Update one Member_token.
     * @param {member_tokenUpdateArgs} args - Arguments to update one Member_token.
     * @example
     * // Update one Member_token
     * const member_token = await prisma.member_token.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends member_tokenUpdateArgs>(
      args: SelectSubset<T, member_tokenUpdateArgs>
    ): Prisma__member_tokenClient<member_tokenGetPayload<T>>

    /**
     * Delete zero or more Member_tokens.
     * @param {member_tokenDeleteManyArgs} args - Arguments to filter Member_tokens to delete.
     * @example
     * // Delete a few Member_tokens
     * const { count } = await prisma.member_token.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends member_tokenDeleteManyArgs>(
      args?: SelectSubset<T, member_tokenDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Member_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_tokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Member_tokens
     * const member_token = await prisma.member_token.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends member_tokenUpdateManyArgs>(
      args: SelectSubset<T, member_tokenUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member_token.
     * @param {member_tokenUpsertArgs} args - Arguments to update or create a Member_token.
     * @example
     * // Update or create a Member_token
     * const member_token = await prisma.member_token.upsert({
     *   create: {
     *     // ... data to create a Member_token
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member_token we want to update
     *   }
     * })
    **/
    upsert<T extends member_tokenUpsertArgs>(
      args: SelectSubset<T, member_tokenUpsertArgs>
    ): Prisma__member_tokenClient<member_tokenGetPayload<T>>

    /**
     * Count the number of Member_tokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_tokenCountArgs} args - Arguments to filter Member_tokens to count.
     * @example
     * // Count the number of Member_tokens
     * const count = await prisma.member_token.count({
     *   where: {
     *     // ... the filter for the Member_tokens we want to count
     *   }
     * })
    **/
    count<T extends member_tokenCountArgs>(
      args?: Subset<T, member_tokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Member_tokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Member_tokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Member_tokenAggregateArgs>(args: Subset<T, Member_tokenAggregateArgs>): Prisma.PrismaPromise<GetMember_tokenAggregateType<T>>

    /**
     * Group by Member_token.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Member_tokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Member_tokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Member_tokenGroupByArgs['orderBy'] }
        : { orderBy?: Member_tokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Member_tokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMember_tokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for member_token.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__member_tokenClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    member<T extends memberArgs= {}>(args?: Subset<T, memberArgs>): Prisma__memberClient<memberGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * member_token base type for findUnique actions
   */
  export type member_tokenFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the member_token
     */
    select?: member_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_tokenInclude | null
    /**
     * Filter, which member_token to fetch.
     */
    where: member_tokenWhereUniqueInput
  }

  /**
   * member_token findUnique
   */
  export interface member_tokenFindUniqueArgs extends member_tokenFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * member_token findUniqueOrThrow
   */
  export type member_tokenFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the member_token
     */
    select?: member_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_tokenInclude | null
    /**
     * Filter, which member_token to fetch.
     */
    where: member_tokenWhereUniqueInput
  }


  /**
   * member_token base type for findFirst actions
   */
  export type member_tokenFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the member_token
     */
    select?: member_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_tokenInclude | null
    /**
     * Filter, which member_token to fetch.
     */
    where?: member_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_tokens to fetch.
     */
    orderBy?: Enumerable<member_tokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for member_tokens.
     */
    cursor?: member_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of member_tokens.
     */
    distinct?: Enumerable<Member_tokenScalarFieldEnum>
  }

  /**
   * member_token findFirst
   */
  export interface member_tokenFindFirstArgs extends member_tokenFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * member_token findFirstOrThrow
   */
  export type member_tokenFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the member_token
     */
    select?: member_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_tokenInclude | null
    /**
     * Filter, which member_token to fetch.
     */
    where?: member_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_tokens to fetch.
     */
    orderBy?: Enumerable<member_tokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for member_tokens.
     */
    cursor?: member_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_tokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of member_tokens.
     */
    distinct?: Enumerable<Member_tokenScalarFieldEnum>
  }


  /**
   * member_token findMany
   */
  export type member_tokenFindManyArgs = {
    /**
     * Select specific fields to fetch from the member_token
     */
    select?: member_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_tokenInclude | null
    /**
     * Filter, which member_tokens to fetch.
     */
    where?: member_tokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_tokens to fetch.
     */
    orderBy?: Enumerable<member_tokenOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing member_tokens.
     */
    cursor?: member_tokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_tokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_tokens.
     */
    skip?: number
    distinct?: Enumerable<Member_tokenScalarFieldEnum>
  }


  /**
   * member_token create
   */
  export type member_tokenCreateArgs = {
    /**
     * Select specific fields to fetch from the member_token
     */
    select?: member_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_tokenInclude | null
    /**
     * The data needed to create a member_token.
     */
    data: XOR<member_tokenCreateInput, member_tokenUncheckedCreateInput>
  }


  /**
   * member_token update
   */
  export type member_tokenUpdateArgs = {
    /**
     * Select specific fields to fetch from the member_token
     */
    select?: member_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_tokenInclude | null
    /**
     * The data needed to update a member_token.
     */
    data: XOR<member_tokenUpdateInput, member_tokenUncheckedUpdateInput>
    /**
     * Choose, which member_token to update.
     */
    where: member_tokenWhereUniqueInput
  }


  /**
   * member_token updateMany
   */
  export type member_tokenUpdateManyArgs = {
    /**
     * The data used to update member_tokens.
     */
    data: XOR<member_tokenUpdateManyMutationInput, member_tokenUncheckedUpdateManyInput>
    /**
     * Filter which member_tokens to update
     */
    where?: member_tokenWhereInput
  }


  /**
   * member_token upsert
   */
  export type member_tokenUpsertArgs = {
    /**
     * Select specific fields to fetch from the member_token
     */
    select?: member_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_tokenInclude | null
    /**
     * The filter to search for the member_token to update in case it exists.
     */
    where: member_tokenWhereUniqueInput
    /**
     * In case the member_token found by the `where` argument doesn't exist, create a new member_token with this data.
     */
    create: XOR<member_tokenCreateInput, member_tokenUncheckedCreateInput>
    /**
     * In case the member_token was found with the provided `where` argument, update it with this data.
     */
    update: XOR<member_tokenUpdateInput, member_tokenUncheckedUpdateInput>
  }


  /**
   * member_token delete
   */
  export type member_tokenDeleteArgs = {
    /**
     * Select specific fields to fetch from the member_token
     */
    select?: member_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_tokenInclude | null
    /**
     * Filter which member_token to delete.
     */
    where: member_tokenWhereUniqueInput
  }


  /**
   * member_token deleteMany
   */
  export type member_tokenDeleteManyArgs = {
    /**
     * Filter which member_tokens to delete
     */
    where?: member_tokenWhereInput
  }


  /**
   * member_token without action
   */
  export type member_tokenArgs = {
    /**
     * Select specific fields to fetch from the member_token
     */
    select?: member_tokenSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_tokenInclude | null
  }



  /**
   * Model member_setting
   */


  export type AggregateMember_setting = {
    _count: Member_settingCountAggregateOutputType | null
    _min: Member_settingMinAggregateOutputType | null
    _max: Member_settingMaxAggregateOutputType | null
  }

  export type Member_settingMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    data: string | null
    member_id: string | null
  }

  export type Member_settingMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    data: string | null
    member_id: string | null
  }

  export type Member_settingCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    data: number
    member_id: number
    _all: number
  }


  export type Member_settingMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    data?: true
    member_id?: true
  }

  export type Member_settingMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    data?: true
    member_id?: true
  }

  export type Member_settingCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    data?: true
    member_id?: true
    _all?: true
  }

  export type Member_settingAggregateArgs = {
    /**
     * Filter which member_setting to aggregate.
     */
    where?: member_settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_settings to fetch.
     */
    orderBy?: Enumerable<member_settingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: member_settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned member_settings
    **/
    _count?: true | Member_settingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Member_settingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Member_settingMaxAggregateInputType
  }

  export type GetMember_settingAggregateType<T extends Member_settingAggregateArgs> = {
        [P in keyof T & keyof AggregateMember_setting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember_setting[P]>
      : GetScalarType<T[P], AggregateMember_setting[P]>
  }




  export type Member_settingGroupByArgs = {
    where?: member_settingWhereInput
    orderBy?: Enumerable<member_settingOrderByWithAggregationInput>
    by: Member_settingScalarFieldEnum[]
    having?: member_settingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Member_settingCountAggregateInputType | true
    _min?: Member_settingMinAggregateInputType
    _max?: Member_settingMaxAggregateInputType
  }


  export type Member_settingGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    data: string
    member_id: string
    _count: Member_settingCountAggregateOutputType | null
    _min: Member_settingMinAggregateOutputType | null
    _max: Member_settingMaxAggregateOutputType | null
  }

  type GetMember_settingGroupByPayload<T extends Member_settingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Member_settingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Member_settingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Member_settingGroupByOutputType[P]>
            : GetScalarType<T[P], Member_settingGroupByOutputType[P]>
        }
      >
    >


  export type member_settingSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    data?: boolean
    member_id?: boolean
    member?: boolean | memberArgs
  }


  export type member_settingInclude = {
    member?: boolean | memberArgs
  }

  export type member_settingGetPayload<S extends boolean | null | undefined | member_settingArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? member_setting :
    S extends undefined ? never :
    S extends { include: any } & (member_settingArgs | member_settingFindManyArgs)
    ? member_setting  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'member' ? memberGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (member_settingArgs | member_settingFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'member' ? memberGetPayload<S['select'][P]> :  P extends keyof member_setting ? member_setting[P] : never
  } 
      : member_setting


  type member_settingCountArgs = 
    Omit<member_settingFindManyArgs, 'select' | 'include'> & {
      select?: Member_settingCountAggregateInputType | true
    }

  export interface member_settingDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Member_setting that matches the filter.
     * @param {member_settingFindUniqueArgs} args - Arguments to find a Member_setting
     * @example
     * // Get one Member_setting
     * const member_setting = await prisma.member_setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends member_settingFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, member_settingFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'member_setting'> extends True ? Prisma__member_settingClient<member_settingGetPayload<T>> : Prisma__member_settingClient<member_settingGetPayload<T> | null, null>

    /**
     * Find one Member_setting that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {member_settingFindUniqueOrThrowArgs} args - Arguments to find a Member_setting
     * @example
     * // Get one Member_setting
     * const member_setting = await prisma.member_setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends member_settingFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, member_settingFindUniqueOrThrowArgs>
    ): Prisma__member_settingClient<member_settingGetPayload<T>>

    /**
     * Find the first Member_setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_settingFindFirstArgs} args - Arguments to find a Member_setting
     * @example
     * // Get one Member_setting
     * const member_setting = await prisma.member_setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends member_settingFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, member_settingFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'member_setting'> extends True ? Prisma__member_settingClient<member_settingGetPayload<T>> : Prisma__member_settingClient<member_settingGetPayload<T> | null, null>

    /**
     * Find the first Member_setting that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_settingFindFirstOrThrowArgs} args - Arguments to find a Member_setting
     * @example
     * // Get one Member_setting
     * const member_setting = await prisma.member_setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends member_settingFindFirstOrThrowArgs>(
      args?: SelectSubset<T, member_settingFindFirstOrThrowArgs>
    ): Prisma__member_settingClient<member_settingGetPayload<T>>

    /**
     * Find zero or more Member_settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_settingFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Member_settings
     * const member_settings = await prisma.member_setting.findMany()
     * 
     * // Get first 10 Member_settings
     * const member_settings = await prisma.member_setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const member_settingWithIdOnly = await prisma.member_setting.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends member_settingFindManyArgs>(
      args?: SelectSubset<T, member_settingFindManyArgs>
    ): Prisma.PrismaPromise<Array<member_settingGetPayload<T>>>

    /**
     * Create a Member_setting.
     * @param {member_settingCreateArgs} args - Arguments to create a Member_setting.
     * @example
     * // Create one Member_setting
     * const Member_setting = await prisma.member_setting.create({
     *   data: {
     *     // ... data to create a Member_setting
     *   }
     * })
     * 
    **/
    create<T extends member_settingCreateArgs>(
      args: SelectSubset<T, member_settingCreateArgs>
    ): Prisma__member_settingClient<member_settingGetPayload<T>>

    /**
     * Delete a Member_setting.
     * @param {member_settingDeleteArgs} args - Arguments to delete one Member_setting.
     * @example
     * // Delete one Member_setting
     * const Member_setting = await prisma.member_setting.delete({
     *   where: {
     *     // ... filter to delete one Member_setting
     *   }
     * })
     * 
    **/
    delete<T extends member_settingDeleteArgs>(
      args: SelectSubset<T, member_settingDeleteArgs>
    ): Prisma__member_settingClient<member_settingGetPayload<T>>

    /**
     * Update one Member_setting.
     * @param {member_settingUpdateArgs} args - Arguments to update one Member_setting.
     * @example
     * // Update one Member_setting
     * const member_setting = await prisma.member_setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends member_settingUpdateArgs>(
      args: SelectSubset<T, member_settingUpdateArgs>
    ): Prisma__member_settingClient<member_settingGetPayload<T>>

    /**
     * Delete zero or more Member_settings.
     * @param {member_settingDeleteManyArgs} args - Arguments to filter Member_settings to delete.
     * @example
     * // Delete a few Member_settings
     * const { count } = await prisma.member_setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends member_settingDeleteManyArgs>(
      args?: SelectSubset<T, member_settingDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Member_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_settingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Member_settings
     * const member_setting = await prisma.member_setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends member_settingUpdateManyArgs>(
      args: SelectSubset<T, member_settingUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member_setting.
     * @param {member_settingUpsertArgs} args - Arguments to update or create a Member_setting.
     * @example
     * // Update or create a Member_setting
     * const member_setting = await prisma.member_setting.upsert({
     *   create: {
     *     // ... data to create a Member_setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member_setting we want to update
     *   }
     * })
    **/
    upsert<T extends member_settingUpsertArgs>(
      args: SelectSubset<T, member_settingUpsertArgs>
    ): Prisma__member_settingClient<member_settingGetPayload<T>>

    /**
     * Count the number of Member_settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_settingCountArgs} args - Arguments to filter Member_settings to count.
     * @example
     * // Count the number of Member_settings
     * const count = await prisma.member_setting.count({
     *   where: {
     *     // ... the filter for the Member_settings we want to count
     *   }
     * })
    **/
    count<T extends member_settingCountArgs>(
      args?: Subset<T, member_settingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Member_settingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member_setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Member_settingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Member_settingAggregateArgs>(args: Subset<T, Member_settingAggregateArgs>): Prisma.PrismaPromise<GetMember_settingAggregateType<T>>

    /**
     * Group by Member_setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Member_settingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Member_settingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Member_settingGroupByArgs['orderBy'] }
        : { orderBy?: Member_settingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Member_settingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMember_settingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for member_setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__member_settingClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    member<T extends memberArgs= {}>(args?: Subset<T, memberArgs>): Prisma__memberClient<memberGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * member_setting base type for findUnique actions
   */
  export type member_settingFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the member_setting
     */
    select?: member_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_settingInclude | null
    /**
     * Filter, which member_setting to fetch.
     */
    where: member_settingWhereUniqueInput
  }

  /**
   * member_setting findUnique
   */
  export interface member_settingFindUniqueArgs extends member_settingFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * member_setting findUniqueOrThrow
   */
  export type member_settingFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the member_setting
     */
    select?: member_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_settingInclude | null
    /**
     * Filter, which member_setting to fetch.
     */
    where: member_settingWhereUniqueInput
  }


  /**
   * member_setting base type for findFirst actions
   */
  export type member_settingFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the member_setting
     */
    select?: member_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_settingInclude | null
    /**
     * Filter, which member_setting to fetch.
     */
    where?: member_settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_settings to fetch.
     */
    orderBy?: Enumerable<member_settingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for member_settings.
     */
    cursor?: member_settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of member_settings.
     */
    distinct?: Enumerable<Member_settingScalarFieldEnum>
  }

  /**
   * member_setting findFirst
   */
  export interface member_settingFindFirstArgs extends member_settingFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * member_setting findFirstOrThrow
   */
  export type member_settingFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the member_setting
     */
    select?: member_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_settingInclude | null
    /**
     * Filter, which member_setting to fetch.
     */
    where?: member_settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_settings to fetch.
     */
    orderBy?: Enumerable<member_settingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for member_settings.
     */
    cursor?: member_settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of member_settings.
     */
    distinct?: Enumerable<Member_settingScalarFieldEnum>
  }


  /**
   * member_setting findMany
   */
  export type member_settingFindManyArgs = {
    /**
     * Select specific fields to fetch from the member_setting
     */
    select?: member_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_settingInclude | null
    /**
     * Filter, which member_settings to fetch.
     */
    where?: member_settingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_settings to fetch.
     */
    orderBy?: Enumerable<member_settingOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing member_settings.
     */
    cursor?: member_settingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_settings.
     */
    skip?: number
    distinct?: Enumerable<Member_settingScalarFieldEnum>
  }


  /**
   * member_setting create
   */
  export type member_settingCreateArgs = {
    /**
     * Select specific fields to fetch from the member_setting
     */
    select?: member_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_settingInclude | null
    /**
     * The data needed to create a member_setting.
     */
    data: XOR<member_settingCreateInput, member_settingUncheckedCreateInput>
  }


  /**
   * member_setting update
   */
  export type member_settingUpdateArgs = {
    /**
     * Select specific fields to fetch from the member_setting
     */
    select?: member_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_settingInclude | null
    /**
     * The data needed to update a member_setting.
     */
    data: XOR<member_settingUpdateInput, member_settingUncheckedUpdateInput>
    /**
     * Choose, which member_setting to update.
     */
    where: member_settingWhereUniqueInput
  }


  /**
   * member_setting updateMany
   */
  export type member_settingUpdateManyArgs = {
    /**
     * The data used to update member_settings.
     */
    data: XOR<member_settingUpdateManyMutationInput, member_settingUncheckedUpdateManyInput>
    /**
     * Filter which member_settings to update
     */
    where?: member_settingWhereInput
  }


  /**
   * member_setting upsert
   */
  export type member_settingUpsertArgs = {
    /**
     * Select specific fields to fetch from the member_setting
     */
    select?: member_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_settingInclude | null
    /**
     * The filter to search for the member_setting to update in case it exists.
     */
    where: member_settingWhereUniqueInput
    /**
     * In case the member_setting found by the `where` argument doesn't exist, create a new member_setting with this data.
     */
    create: XOR<member_settingCreateInput, member_settingUncheckedCreateInput>
    /**
     * In case the member_setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<member_settingUpdateInput, member_settingUncheckedUpdateInput>
  }


  /**
   * member_setting delete
   */
  export type member_settingDeleteArgs = {
    /**
     * Select specific fields to fetch from the member_setting
     */
    select?: member_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_settingInclude | null
    /**
     * Filter which member_setting to delete.
     */
    where: member_settingWhereUniqueInput
  }


  /**
   * member_setting deleteMany
   */
  export type member_settingDeleteManyArgs = {
    /**
     * Filter which member_settings to delete
     */
    where?: member_settingWhereInput
  }


  /**
   * member_setting without action
   */
  export type member_settingArgs = {
    /**
     * Select specific fields to fetch from the member_setting
     */
    select?: member_settingSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_settingInclude | null
  }



  /**
   * Model permission
   */


  export type AggregatePermission = {
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  export type PermissionMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    desc: string | null
    code: string | null
    user_id: string | null
  }

  export type PermissionMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    desc: string | null
    code: string | null
    user_id: string | null
  }

  export type PermissionCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    desc: number
    code: number
    user_id: number
    _all: number
  }


  export type PermissionMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    desc?: true
    code?: true
    user_id?: true
  }

  export type PermissionMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    desc?: true
    code?: true
    user_id?: true
  }

  export type PermissionCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    desc?: true
    code?: true
    user_id?: true
    _all?: true
  }

  export type PermissionAggregateArgs = {
    /**
     * Filter which permission to aggregate.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: Enumerable<permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned permissions
    **/
    _count?: true | PermissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PermissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PermissionMaxAggregateInputType
  }

  export type GetPermissionAggregateType<T extends PermissionAggregateArgs> = {
        [P in keyof T & keyof AggregatePermission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePermission[P]>
      : GetScalarType<T[P], AggregatePermission[P]>
  }




  export type PermissionGroupByArgs = {
    where?: permissionWhereInput
    orderBy?: Enumerable<permissionOrderByWithAggregationInput>
    by: PermissionScalarFieldEnum[]
    having?: permissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PermissionCountAggregateInputType | true
    _min?: PermissionMinAggregateInputType
    _max?: PermissionMaxAggregateInputType
  }


  export type PermissionGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    desc: string
    code: string
    user_id: string
    _count: PermissionCountAggregateOutputType | null
    _min: PermissionMinAggregateOutputType | null
    _max: PermissionMaxAggregateOutputType | null
  }

  type GetPermissionGroupByPayload<T extends PermissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<PermissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PermissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PermissionGroupByOutputType[P]>
            : GetScalarType<T[P], PermissionGroupByOutputType[P]>
        }
      >
    >


  export type permissionSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    desc?: boolean
    code?: boolean
    user_id?: boolean
    user?: boolean | userArgs
  }


  export type permissionInclude = {
    user?: boolean | userArgs
  }

  export type permissionGetPayload<S extends boolean | null | undefined | permissionArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? permission :
    S extends undefined ? never :
    S extends { include: any } & (permissionArgs | permissionFindManyArgs)
    ? permission  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (permissionArgs | permissionFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof permission ? permission[P] : never
  } 
      : permission


  type permissionCountArgs = 
    Omit<permissionFindManyArgs, 'select' | 'include'> & {
      select?: PermissionCountAggregateInputType | true
    }

  export interface permissionDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Permission that matches the filter.
     * @param {permissionFindUniqueArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends permissionFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, permissionFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'permission'> extends True ? Prisma__permissionClient<permissionGetPayload<T>> : Prisma__permissionClient<permissionGetPayload<T> | null, null>

    /**
     * Find one Permission that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {permissionFindUniqueOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends permissionFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, permissionFindUniqueOrThrowArgs>
    ): Prisma__permissionClient<permissionGetPayload<T>>

    /**
     * Find the first Permission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends permissionFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, permissionFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'permission'> extends True ? Prisma__permissionClient<permissionGetPayload<T>> : Prisma__permissionClient<permissionGetPayload<T> | null, null>

    /**
     * Find the first Permission that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindFirstOrThrowArgs} args - Arguments to find a Permission
     * @example
     * // Get one Permission
     * const permission = await prisma.permission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends permissionFindFirstOrThrowArgs>(
      args?: SelectSubset<T, permissionFindFirstOrThrowArgs>
    ): Prisma__permissionClient<permissionGetPayload<T>>

    /**
     * Find zero or more Permissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Permissions
     * const permissions = await prisma.permission.findMany()
     * 
     * // Get first 10 Permissions
     * const permissions = await prisma.permission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const permissionWithIdOnly = await prisma.permission.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends permissionFindManyArgs>(
      args?: SelectSubset<T, permissionFindManyArgs>
    ): Prisma.PrismaPromise<Array<permissionGetPayload<T>>>

    /**
     * Create a Permission.
     * @param {permissionCreateArgs} args - Arguments to create a Permission.
     * @example
     * // Create one Permission
     * const Permission = await prisma.permission.create({
     *   data: {
     *     // ... data to create a Permission
     *   }
     * })
     * 
    **/
    create<T extends permissionCreateArgs>(
      args: SelectSubset<T, permissionCreateArgs>
    ): Prisma__permissionClient<permissionGetPayload<T>>

    /**
     * Delete a Permission.
     * @param {permissionDeleteArgs} args - Arguments to delete one Permission.
     * @example
     * // Delete one Permission
     * const Permission = await prisma.permission.delete({
     *   where: {
     *     // ... filter to delete one Permission
     *   }
     * })
     * 
    **/
    delete<T extends permissionDeleteArgs>(
      args: SelectSubset<T, permissionDeleteArgs>
    ): Prisma__permissionClient<permissionGetPayload<T>>

    /**
     * Update one Permission.
     * @param {permissionUpdateArgs} args - Arguments to update one Permission.
     * @example
     * // Update one Permission
     * const permission = await prisma.permission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends permissionUpdateArgs>(
      args: SelectSubset<T, permissionUpdateArgs>
    ): Prisma__permissionClient<permissionGetPayload<T>>

    /**
     * Delete zero or more Permissions.
     * @param {permissionDeleteManyArgs} args - Arguments to filter Permissions to delete.
     * @example
     * // Delete a few Permissions
     * const { count } = await prisma.permission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends permissionDeleteManyArgs>(
      args?: SelectSubset<T, permissionDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Permissions
     * const permission = await prisma.permission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends permissionUpdateManyArgs>(
      args: SelectSubset<T, permissionUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Permission.
     * @param {permissionUpsertArgs} args - Arguments to update or create a Permission.
     * @example
     * // Update or create a Permission
     * const permission = await prisma.permission.upsert({
     *   create: {
     *     // ... data to create a Permission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Permission we want to update
     *   }
     * })
    **/
    upsert<T extends permissionUpsertArgs>(
      args: SelectSubset<T, permissionUpsertArgs>
    ): Prisma__permissionClient<permissionGetPayload<T>>

    /**
     * Count the number of Permissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {permissionCountArgs} args - Arguments to filter Permissions to count.
     * @example
     * // Count the number of Permissions
     * const count = await prisma.permission.count({
     *   where: {
     *     // ... the filter for the Permissions we want to count
     *   }
     * })
    **/
    count<T extends permissionCountArgs>(
      args?: Subset<T, permissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PermissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PermissionAggregateArgs>(args: Subset<T, PermissionAggregateArgs>): Prisma.PrismaPromise<GetPermissionAggregateType<T>>

    /**
     * Group by Permission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PermissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PermissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PermissionGroupByArgs['orderBy'] }
        : { orderBy?: PermissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PermissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPermissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for permission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__permissionClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * permission base type for findUnique actions
   */
  export type permissionFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }

  /**
   * permission findUnique
   */
  export interface permissionFindUniqueArgs extends permissionFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * permission findUniqueOrThrow
   */
  export type permissionFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude | null
    /**
     * Filter, which permission to fetch.
     */
    where: permissionWhereUniqueInput
  }


  /**
   * permission base type for findFirst actions
   */
  export type permissionFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: Enumerable<permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }

  /**
   * permission findFirst
   */
  export interface permissionFindFirstArgs extends permissionFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * permission findFirstOrThrow
   */
  export type permissionFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude | null
    /**
     * Filter, which permission to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: Enumerable<permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of permissions.
     */
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * permission findMany
   */
  export type permissionFindManyArgs = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude | null
    /**
     * Filter, which permissions to fetch.
     */
    where?: permissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of permissions to fetch.
     */
    orderBy?: Enumerable<permissionOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing permissions.
     */
    cursor?: permissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` permissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` permissions.
     */
    skip?: number
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * permission create
   */
  export type permissionCreateArgs = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude | null
    /**
     * The data needed to create a permission.
     */
    data: XOR<permissionCreateInput, permissionUncheckedCreateInput>
  }


  /**
   * permission update
   */
  export type permissionUpdateArgs = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude | null
    /**
     * The data needed to update a permission.
     */
    data: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
    /**
     * Choose, which permission to update.
     */
    where: permissionWhereUniqueInput
  }


  /**
   * permission updateMany
   */
  export type permissionUpdateManyArgs = {
    /**
     * The data used to update permissions.
     */
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyInput>
    /**
     * Filter which permissions to update
     */
    where?: permissionWhereInput
  }


  /**
   * permission upsert
   */
  export type permissionUpsertArgs = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude | null
    /**
     * The filter to search for the permission to update in case it exists.
     */
    where: permissionWhereUniqueInput
    /**
     * In case the permission found by the `where` argument doesn't exist, create a new permission with this data.
     */
    create: XOR<permissionCreateInput, permissionUncheckedCreateInput>
    /**
     * In case the permission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<permissionUpdateInput, permissionUncheckedUpdateInput>
  }


  /**
   * permission delete
   */
  export type permissionDeleteArgs = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude | null
    /**
     * Filter which permission to delete.
     */
    where: permissionWhereUniqueInput
  }


  /**
   * permission deleteMany
   */
  export type permissionDeleteManyArgs = {
    /**
     * Filter which permissions to delete
     */
    where?: permissionWhereInput
  }


  /**
   * permission without action
   */
  export type permissionArgs = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude | null
  }



  /**
   * Model member_notification
   */


  export type AggregateMember_notification = {
    _count: Member_notificationCountAggregateOutputType | null
    _avg: Member_notificationAvgAggregateOutputType | null
    _sum: Member_notificationSumAggregateOutputType | null
    _min: Member_notificationMinAggregateOutputType | null
    _max: Member_notificationMaxAggregateOutputType | null
  }

  export type Member_notificationAvgAggregateOutputType = {
    type: number | null
    status: number | null
    is_delete: number | null
  }

  export type Member_notificationSumAggregateOutputType = {
    type: number | null
    status: number | null
    is_delete: number | null
  }

  export type Member_notificationMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    content: string | null
    type: number | null
    status: number | null
    is_delete: number | null
    member_id: string | null
  }

  export type Member_notificationMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    content: string | null
    type: number | null
    status: number | null
    is_delete: number | null
    member_id: string | null
  }

  export type Member_notificationCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    unique_id: number
    content: number
    type: number
    status: number
    is_delete: number
    member_id: number
    _all: number
  }


  export type Member_notificationAvgAggregateInputType = {
    type?: true
    status?: true
    is_delete?: true
  }

  export type Member_notificationSumAggregateInputType = {
    type?: true
    status?: true
    is_delete?: true
  }

  export type Member_notificationMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    content?: true
    type?: true
    status?: true
    is_delete?: true
    member_id?: true
  }

  export type Member_notificationMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    content?: true
    type?: true
    status?: true
    is_delete?: true
    member_id?: true
  }

  export type Member_notificationCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    content?: true
    type?: true
    status?: true
    is_delete?: true
    member_id?: true
    _all?: true
  }

  export type Member_notificationAggregateArgs = {
    /**
     * Filter which member_notification to aggregate.
     */
    where?: member_notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_notifications to fetch.
     */
    orderBy?: Enumerable<member_notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: member_notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned member_notifications
    **/
    _count?: true | Member_notificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Member_notificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Member_notificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Member_notificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Member_notificationMaxAggregateInputType
  }

  export type GetMember_notificationAggregateType<T extends Member_notificationAggregateArgs> = {
        [P in keyof T & keyof AggregateMember_notification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMember_notification[P]>
      : GetScalarType<T[P], AggregateMember_notification[P]>
  }




  export type Member_notificationGroupByArgs = {
    where?: member_notificationWhereInput
    orderBy?: Enumerable<member_notificationOrderByWithAggregationInput>
    by: Member_notificationScalarFieldEnum[]
    having?: member_notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Member_notificationCountAggregateInputType | true
    _avg?: Member_notificationAvgAggregateInputType
    _sum?: Member_notificationSumAggregateInputType
    _min?: Member_notificationMinAggregateInputType
    _max?: Member_notificationMaxAggregateInputType
  }


  export type Member_notificationGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    unique_id: string
    content: string | null
    type: number | null
    status: number | null
    is_delete: number | null
    member_id: string
    _count: Member_notificationCountAggregateOutputType | null
    _avg: Member_notificationAvgAggregateOutputType | null
    _sum: Member_notificationSumAggregateOutputType | null
    _min: Member_notificationMinAggregateOutputType | null
    _max: Member_notificationMaxAggregateOutputType | null
  }

  type GetMember_notificationGroupByPayload<T extends Member_notificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<Member_notificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Member_notificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Member_notificationGroupByOutputType[P]>
            : GetScalarType<T[P], Member_notificationGroupByOutputType[P]>
        }
      >
    >


  export type member_notificationSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    unique_id?: boolean
    content?: boolean
    type?: boolean
    status?: boolean
    is_delete?: boolean
    member_id?: boolean
    member?: boolean | memberArgs
  }


  export type member_notificationInclude = {
    member?: boolean | memberArgs
  }

  export type member_notificationGetPayload<S extends boolean | null | undefined | member_notificationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? member_notification :
    S extends undefined ? never :
    S extends { include: any } & (member_notificationArgs | member_notificationFindManyArgs)
    ? member_notification  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'member' ? memberGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (member_notificationArgs | member_notificationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'member' ? memberGetPayload<S['select'][P]> :  P extends keyof member_notification ? member_notification[P] : never
  } 
      : member_notification


  type member_notificationCountArgs = 
    Omit<member_notificationFindManyArgs, 'select' | 'include'> & {
      select?: Member_notificationCountAggregateInputType | true
    }

  export interface member_notificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Member_notification that matches the filter.
     * @param {member_notificationFindUniqueArgs} args - Arguments to find a Member_notification
     * @example
     * // Get one Member_notification
     * const member_notification = await prisma.member_notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends member_notificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, member_notificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'member_notification'> extends True ? Prisma__member_notificationClient<member_notificationGetPayload<T>> : Prisma__member_notificationClient<member_notificationGetPayload<T> | null, null>

    /**
     * Find one Member_notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {member_notificationFindUniqueOrThrowArgs} args - Arguments to find a Member_notification
     * @example
     * // Get one Member_notification
     * const member_notification = await prisma.member_notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends member_notificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, member_notificationFindUniqueOrThrowArgs>
    ): Prisma__member_notificationClient<member_notificationGetPayload<T>>

    /**
     * Find the first Member_notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_notificationFindFirstArgs} args - Arguments to find a Member_notification
     * @example
     * // Get one Member_notification
     * const member_notification = await prisma.member_notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends member_notificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, member_notificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'member_notification'> extends True ? Prisma__member_notificationClient<member_notificationGetPayload<T>> : Prisma__member_notificationClient<member_notificationGetPayload<T> | null, null>

    /**
     * Find the first Member_notification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_notificationFindFirstOrThrowArgs} args - Arguments to find a Member_notification
     * @example
     * // Get one Member_notification
     * const member_notification = await prisma.member_notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends member_notificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, member_notificationFindFirstOrThrowArgs>
    ): Prisma__member_notificationClient<member_notificationGetPayload<T>>

    /**
     * Find zero or more Member_notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_notificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Member_notifications
     * const member_notifications = await prisma.member_notification.findMany()
     * 
     * // Get first 10 Member_notifications
     * const member_notifications = await prisma.member_notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const member_notificationWithIdOnly = await prisma.member_notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends member_notificationFindManyArgs>(
      args?: SelectSubset<T, member_notificationFindManyArgs>
    ): Prisma.PrismaPromise<Array<member_notificationGetPayload<T>>>

    /**
     * Create a Member_notification.
     * @param {member_notificationCreateArgs} args - Arguments to create a Member_notification.
     * @example
     * // Create one Member_notification
     * const Member_notification = await prisma.member_notification.create({
     *   data: {
     *     // ... data to create a Member_notification
     *   }
     * })
     * 
    **/
    create<T extends member_notificationCreateArgs>(
      args: SelectSubset<T, member_notificationCreateArgs>
    ): Prisma__member_notificationClient<member_notificationGetPayload<T>>

    /**
     * Delete a Member_notification.
     * @param {member_notificationDeleteArgs} args - Arguments to delete one Member_notification.
     * @example
     * // Delete one Member_notification
     * const Member_notification = await prisma.member_notification.delete({
     *   where: {
     *     // ... filter to delete one Member_notification
     *   }
     * })
     * 
    **/
    delete<T extends member_notificationDeleteArgs>(
      args: SelectSubset<T, member_notificationDeleteArgs>
    ): Prisma__member_notificationClient<member_notificationGetPayload<T>>

    /**
     * Update one Member_notification.
     * @param {member_notificationUpdateArgs} args - Arguments to update one Member_notification.
     * @example
     * // Update one Member_notification
     * const member_notification = await prisma.member_notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends member_notificationUpdateArgs>(
      args: SelectSubset<T, member_notificationUpdateArgs>
    ): Prisma__member_notificationClient<member_notificationGetPayload<T>>

    /**
     * Delete zero or more Member_notifications.
     * @param {member_notificationDeleteManyArgs} args - Arguments to filter Member_notifications to delete.
     * @example
     * // Delete a few Member_notifications
     * const { count } = await prisma.member_notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends member_notificationDeleteManyArgs>(
      args?: SelectSubset<T, member_notificationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Member_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Member_notifications
     * const member_notification = await prisma.member_notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends member_notificationUpdateManyArgs>(
      args: SelectSubset<T, member_notificationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Member_notification.
     * @param {member_notificationUpsertArgs} args - Arguments to update or create a Member_notification.
     * @example
     * // Update or create a Member_notification
     * const member_notification = await prisma.member_notification.upsert({
     *   create: {
     *     // ... data to create a Member_notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Member_notification we want to update
     *   }
     * })
    **/
    upsert<T extends member_notificationUpsertArgs>(
      args: SelectSubset<T, member_notificationUpsertArgs>
    ): Prisma__member_notificationClient<member_notificationGetPayload<T>>

    /**
     * Count the number of Member_notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {member_notificationCountArgs} args - Arguments to filter Member_notifications to count.
     * @example
     * // Count the number of Member_notifications
     * const count = await prisma.member_notification.count({
     *   where: {
     *     // ... the filter for the Member_notifications we want to count
     *   }
     * })
    **/
    count<T extends member_notificationCountArgs>(
      args?: Subset<T, member_notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Member_notificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Member_notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Member_notificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Member_notificationAggregateArgs>(args: Subset<T, Member_notificationAggregateArgs>): Prisma.PrismaPromise<GetMember_notificationAggregateType<T>>

    /**
     * Group by Member_notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Member_notificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends Member_notificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: Member_notificationGroupByArgs['orderBy'] }
        : { orderBy?: Member_notificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, Member_notificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMember_notificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for member_notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__member_notificationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    member<T extends memberArgs= {}>(args?: Subset<T, memberArgs>): Prisma__memberClient<memberGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * member_notification base type for findUnique actions
   */
  export type member_notificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the member_notification
     */
    select?: member_notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_notificationInclude | null
    /**
     * Filter, which member_notification to fetch.
     */
    where: member_notificationWhereUniqueInput
  }

  /**
   * member_notification findUnique
   */
  export interface member_notificationFindUniqueArgs extends member_notificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * member_notification findUniqueOrThrow
   */
  export type member_notificationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the member_notification
     */
    select?: member_notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_notificationInclude | null
    /**
     * Filter, which member_notification to fetch.
     */
    where: member_notificationWhereUniqueInput
  }


  /**
   * member_notification base type for findFirst actions
   */
  export type member_notificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the member_notification
     */
    select?: member_notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_notificationInclude | null
    /**
     * Filter, which member_notification to fetch.
     */
    where?: member_notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_notifications to fetch.
     */
    orderBy?: Enumerable<member_notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for member_notifications.
     */
    cursor?: member_notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of member_notifications.
     */
    distinct?: Enumerable<Member_notificationScalarFieldEnum>
  }

  /**
   * member_notification findFirst
   */
  export interface member_notificationFindFirstArgs extends member_notificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * member_notification findFirstOrThrow
   */
  export type member_notificationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the member_notification
     */
    select?: member_notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_notificationInclude | null
    /**
     * Filter, which member_notification to fetch.
     */
    where?: member_notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_notifications to fetch.
     */
    orderBy?: Enumerable<member_notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for member_notifications.
     */
    cursor?: member_notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of member_notifications.
     */
    distinct?: Enumerable<Member_notificationScalarFieldEnum>
  }


  /**
   * member_notification findMany
   */
  export type member_notificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the member_notification
     */
    select?: member_notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_notificationInclude | null
    /**
     * Filter, which member_notifications to fetch.
     */
    where?: member_notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of member_notifications to fetch.
     */
    orderBy?: Enumerable<member_notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing member_notifications.
     */
    cursor?: member_notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` member_notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` member_notifications.
     */
    skip?: number
    distinct?: Enumerable<Member_notificationScalarFieldEnum>
  }


  /**
   * member_notification create
   */
  export type member_notificationCreateArgs = {
    /**
     * Select specific fields to fetch from the member_notification
     */
    select?: member_notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_notificationInclude | null
    /**
     * The data needed to create a member_notification.
     */
    data: XOR<member_notificationCreateInput, member_notificationUncheckedCreateInput>
  }


  /**
   * member_notification update
   */
  export type member_notificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the member_notification
     */
    select?: member_notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_notificationInclude | null
    /**
     * The data needed to update a member_notification.
     */
    data: XOR<member_notificationUpdateInput, member_notificationUncheckedUpdateInput>
    /**
     * Choose, which member_notification to update.
     */
    where: member_notificationWhereUniqueInput
  }


  /**
   * member_notification updateMany
   */
  export type member_notificationUpdateManyArgs = {
    /**
     * The data used to update member_notifications.
     */
    data: XOR<member_notificationUpdateManyMutationInput, member_notificationUncheckedUpdateManyInput>
    /**
     * Filter which member_notifications to update
     */
    where?: member_notificationWhereInput
  }


  /**
   * member_notification upsert
   */
  export type member_notificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the member_notification
     */
    select?: member_notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_notificationInclude | null
    /**
     * The filter to search for the member_notification to update in case it exists.
     */
    where: member_notificationWhereUniqueInput
    /**
     * In case the member_notification found by the `where` argument doesn't exist, create a new member_notification with this data.
     */
    create: XOR<member_notificationCreateInput, member_notificationUncheckedCreateInput>
    /**
     * In case the member_notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<member_notificationUpdateInput, member_notificationUncheckedUpdateInput>
  }


  /**
   * member_notification delete
   */
  export type member_notificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the member_notification
     */
    select?: member_notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_notificationInclude | null
    /**
     * Filter which member_notification to delete.
     */
    where: member_notificationWhereUniqueInput
  }


  /**
   * member_notification deleteMany
   */
  export type member_notificationDeleteManyArgs = {
    /**
     * Filter which member_notifications to delete
     */
    where?: member_notificationWhereInput
  }


  /**
   * member_notification without action
   */
  export type member_notificationArgs = {
    /**
     * Select specific fields to fetch from the member_notification
     */
    select?: member_notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: member_notificationInclude | null
  }



  /**
   * Model notification
   */


  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationAvgAggregateOutputType = {
    type: number | null
    status: number | null
    is_delete: number | null
  }

  export type NotificationSumAggregateOutputType = {
    type: number | null
    status: number | null
    is_delete: number | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    content: string | null
    type: number | null
    status: number | null
    is_delete: number | null
    user_id: string | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    unique_id: string | null
    content: string | null
    type: number | null
    status: number | null
    is_delete: number | null
    user_id: string | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    unique_id: number
    content: number
    type: number
    status: number
    is_delete: number
    user_id: number
    _all: number
  }


  export type NotificationAvgAggregateInputType = {
    type?: true
    status?: true
    is_delete?: true
  }

  export type NotificationSumAggregateInputType = {
    type?: true
    status?: true
    is_delete?: true
  }

  export type NotificationMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    content?: true
    type?: true
    status?: true
    is_delete?: true
    user_id?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    content?: true
    type?: true
    status?: true
    is_delete?: true
    user_id?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    unique_id?: true
    content?: true
    type?: true
    status?: true
    is_delete?: true
    user_id?: true
    _all?: true
  }

  export type NotificationAggregateArgs = {
    /**
     * Filter which notification to aggregate.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: Enumerable<notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: NotificationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: NotificationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs = {
    where?: notificationWhereInput
    orderBy?: Enumerable<notificationOrderByWithAggregationInput>
    by: NotificationScalarFieldEnum[]
    having?: notificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _avg?: NotificationAvgAggregateInputType
    _sum?: NotificationSumAggregateInputType
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }


  export type NotificationGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    unique_id: string
    content: string | null
    type: number | null
    status: number | null
    is_delete: number | null
    user_id: string
    _count: NotificationCountAggregateOutputType | null
    _avg: NotificationAvgAggregateOutputType | null
    _sum: NotificationSumAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type notificationSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    unique_id?: boolean
    content?: boolean
    type?: boolean
    status?: boolean
    is_delete?: boolean
    user_id?: boolean
    user?: boolean | userArgs
  }


  export type notificationInclude = {
    user?: boolean | userArgs
  }

  export type notificationGetPayload<S extends boolean | null | undefined | notificationArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? notification :
    S extends undefined ? never :
    S extends { include: any } & (notificationArgs | notificationFindManyArgs)
    ? notification  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (notificationArgs | notificationFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof notification ? notification[P] : never
  } 
      : notification


  type notificationCountArgs = 
    Omit<notificationFindManyArgs, 'select' | 'include'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface notificationDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Notification that matches the filter.
     * @param {notificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends notificationFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, notificationFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'notification'> extends True ? Prisma__notificationClient<notificationGetPayload<T>> : Prisma__notificationClient<notificationGetPayload<T> | null, null>

    /**
     * Find one Notification that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {notificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends notificationFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, notificationFindUniqueOrThrowArgs>
    ): Prisma__notificationClient<notificationGetPayload<T>>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends notificationFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, notificationFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'notification'> extends True ? Prisma__notificationClient<notificationGetPayload<T>> : Prisma__notificationClient<notificationGetPayload<T> | null, null>

    /**
     * Find the first Notification that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends notificationFindFirstOrThrowArgs>(
      args?: SelectSubset<T, notificationFindFirstOrThrowArgs>
    ): Prisma__notificationClient<notificationGetPayload<T>>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends notificationFindManyArgs>(
      args?: SelectSubset<T, notificationFindManyArgs>
    ): Prisma.PrismaPromise<Array<notificationGetPayload<T>>>

    /**
     * Create a Notification.
     * @param {notificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
    **/
    create<T extends notificationCreateArgs>(
      args: SelectSubset<T, notificationCreateArgs>
    ): Prisma__notificationClient<notificationGetPayload<T>>

    /**
     * Delete a Notification.
     * @param {notificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
    **/
    delete<T extends notificationDeleteArgs>(
      args: SelectSubset<T, notificationDeleteArgs>
    ): Prisma__notificationClient<notificationGetPayload<T>>

    /**
     * Update one Notification.
     * @param {notificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends notificationUpdateArgs>(
      args: SelectSubset<T, notificationUpdateArgs>
    ): Prisma__notificationClient<notificationGetPayload<T>>

    /**
     * Delete zero or more Notifications.
     * @param {notificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends notificationDeleteManyArgs>(
      args?: SelectSubset<T, notificationDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends notificationUpdateManyArgs>(
      args: SelectSubset<T, notificationUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {notificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
    **/
    upsert<T extends notificationUpsertArgs>(
      args: SelectSubset<T, notificationUpsertArgs>
    ): Prisma__notificationClient<notificationGetPayload<T>>

    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {notificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends notificationCountArgs>(
      args?: Subset<T, notificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__notificationClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * notification base type for findUnique actions
   */
  export type notificationFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }

  /**
   * notification findUnique
   */
  export interface notificationFindUniqueArgs extends notificationFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * notification findUniqueOrThrow
   */
  export type notificationFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude | null
    /**
     * Filter, which notification to fetch.
     */
    where: notificationWhereUniqueInput
  }


  /**
   * notification base type for findFirst actions
   */
  export type notificationFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: Enumerable<notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }

  /**
   * notification findFirst
   */
  export interface notificationFindFirstArgs extends notificationFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * notification findFirstOrThrow
   */
  export type notificationFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude | null
    /**
     * Filter, which notification to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: Enumerable<notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of notifications.
     */
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * notification findMany
   */
  export type notificationFindManyArgs = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude | null
    /**
     * Filter, which notifications to fetch.
     */
    where?: notificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of notifications to fetch.
     */
    orderBy?: Enumerable<notificationOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing notifications.
     */
    cursor?: notificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` notifications.
     */
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * notification create
   */
  export type notificationCreateArgs = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude | null
    /**
     * The data needed to create a notification.
     */
    data: XOR<notificationCreateInput, notificationUncheckedCreateInput>
  }


  /**
   * notification update
   */
  export type notificationUpdateArgs = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude | null
    /**
     * The data needed to update a notification.
     */
    data: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
    /**
     * Choose, which notification to update.
     */
    where: notificationWhereUniqueInput
  }


  /**
   * notification updateMany
   */
  export type notificationUpdateManyArgs = {
    /**
     * The data used to update notifications.
     */
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyInput>
    /**
     * Filter which notifications to update
     */
    where?: notificationWhereInput
  }


  /**
   * notification upsert
   */
  export type notificationUpsertArgs = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude | null
    /**
     * The filter to search for the notification to update in case it exists.
     */
    where: notificationWhereUniqueInput
    /**
     * In case the notification found by the `where` argument doesn't exist, create a new notification with this data.
     */
    create: XOR<notificationCreateInput, notificationUncheckedCreateInput>
    /**
     * In case the notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<notificationUpdateInput, notificationUncheckedUpdateInput>
  }


  /**
   * notification delete
   */
  export type notificationDeleteArgs = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude | null
    /**
     * Filter which notification to delete.
     */
    where: notificationWhereUniqueInput
  }


  /**
   * notification deleteMany
   */
  export type notificationDeleteManyArgs = {
    /**
     * Filter which notifications to delete
     */
    where?: notificationWhereInput
  }


  /**
   * notification without action
   */
  export type notificationArgs = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude | null
  }



  /**
   * Model report
   */


  export type AggregateReport = {
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  export type ReportAvgAggregateOutputType = {
    type: number | null
  }

  export type ReportSumAggregateOutputType = {
    type: number | null
  }

  export type ReportMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    type: number | null
    data: string | null
    answer: string | null
    tv_id: string | null
    season_id: string | null
    episode_id: string | null
    movie_id: string | null
    member_id: string | null
    user_id: string | null
  }

  export type ReportMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    type: number | null
    data: string | null
    answer: string | null
    tv_id: string | null
    season_id: string | null
    episode_id: string | null
    movie_id: string | null
    member_id: string | null
    user_id: string | null
  }

  export type ReportCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    type: number
    data: number
    answer: number
    tv_id: number
    season_id: number
    episode_id: number
    movie_id: number
    member_id: number
    user_id: number
    _all: number
  }


  export type ReportAvgAggregateInputType = {
    type?: true
  }

  export type ReportSumAggregateInputType = {
    type?: true
  }

  export type ReportMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    type?: true
    data?: true
    answer?: true
    tv_id?: true
    season_id?: true
    episode_id?: true
    movie_id?: true
    member_id?: true
    user_id?: true
  }

  export type ReportMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    type?: true
    data?: true
    answer?: true
    tv_id?: true
    season_id?: true
    episode_id?: true
    movie_id?: true
    member_id?: true
    user_id?: true
  }

  export type ReportCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    type?: true
    data?: true
    answer?: true
    tv_id?: true
    season_id?: true
    episode_id?: true
    movie_id?: true
    member_id?: true
    user_id?: true
    _all?: true
  }

  export type ReportAggregateArgs = {
    /**
     * Filter which report to aggregate.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned reports
    **/
    _count?: true | ReportCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ReportAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ReportSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ReportMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ReportMaxAggregateInputType
  }

  export type GetReportAggregateType<T extends ReportAggregateArgs> = {
        [P in keyof T & keyof AggregateReport]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateReport[P]>
      : GetScalarType<T[P], AggregateReport[P]>
  }




  export type ReportGroupByArgs = {
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithAggregationInput>
    by: ReportScalarFieldEnum[]
    having?: reportScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ReportCountAggregateInputType | true
    _avg?: ReportAvgAggregateInputType
    _sum?: ReportSumAggregateInputType
    _min?: ReportMinAggregateInputType
    _max?: ReportMaxAggregateInputType
  }


  export type ReportGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    type: number
    data: string
    answer: string
    tv_id: string | null
    season_id: string | null
    episode_id: string | null
    movie_id: string | null
    member_id: string
    user_id: string
    _count: ReportCountAggregateOutputType | null
    _avg: ReportAvgAggregateOutputType | null
    _sum: ReportSumAggregateOutputType | null
    _min: ReportMinAggregateOutputType | null
    _max: ReportMaxAggregateOutputType | null
  }

  type GetReportGroupByPayload<T extends ReportGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ReportGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ReportGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ReportGroupByOutputType[P]>
            : GetScalarType<T[P], ReportGroupByOutputType[P]>
        }
      >
    >


  export type reportSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    type?: boolean
    data?: boolean
    answer?: boolean
    tv_id?: boolean
    season_id?: boolean
    episode_id?: boolean
    movie_id?: boolean
    member_id?: boolean
    user_id?: boolean
    tv?: boolean | tvArgs
    season?: boolean | seasonArgs
    episode?: boolean | episodeArgs
    movie?: boolean | movieArgs
    member?: boolean | memberArgs
    user?: boolean | userArgs
  }


  export type reportInclude = {
    tv?: boolean | tvArgs
    season?: boolean | seasonArgs
    episode?: boolean | episodeArgs
    movie?: boolean | movieArgs
    member?: boolean | memberArgs
    user?: boolean | userArgs
  }

  export type reportGetPayload<S extends boolean | null | undefined | reportArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? report :
    S extends undefined ? never :
    S extends { include: any } & (reportArgs | reportFindManyArgs)
    ? report  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'tv' ? tvGetPayload<S['include'][P]> | null :
        P extends 'season' ? seasonGetPayload<S['include'][P]> | null :
        P extends 'episode' ? episodeGetPayload<S['include'][P]> | null :
        P extends 'movie' ? movieGetPayload<S['include'][P]> | null :
        P extends 'member' ? memberGetPayload<S['include'][P]> :
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (reportArgs | reportFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'tv' ? tvGetPayload<S['select'][P]> | null :
        P extends 'season' ? seasonGetPayload<S['select'][P]> | null :
        P extends 'episode' ? episodeGetPayload<S['select'][P]> | null :
        P extends 'movie' ? movieGetPayload<S['select'][P]> | null :
        P extends 'member' ? memberGetPayload<S['select'][P]> :
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof report ? report[P] : never
  } 
      : report


  type reportCountArgs = 
    Omit<reportFindManyArgs, 'select' | 'include'> & {
      select?: ReportCountAggregateInputType | true
    }

  export interface reportDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Report that matches the filter.
     * @param {reportFindUniqueArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends reportFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, reportFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'report'> extends True ? Prisma__reportClient<reportGetPayload<T>> : Prisma__reportClient<reportGetPayload<T> | null, null>

    /**
     * Find one Report that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {reportFindUniqueOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends reportFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, reportFindUniqueOrThrowArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Find the first Report that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindFirstArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends reportFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, reportFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'report'> extends True ? Prisma__reportClient<reportGetPayload<T>> : Prisma__reportClient<reportGetPayload<T> | null, null>

    /**
     * Find the first Report that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindFirstOrThrowArgs} args - Arguments to find a Report
     * @example
     * // Get one Report
     * const report = await prisma.report.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends reportFindFirstOrThrowArgs>(
      args?: SelectSubset<T, reportFindFirstOrThrowArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Find zero or more Reports that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Reports
     * const reports = await prisma.report.findMany()
     * 
     * // Get first 10 Reports
     * const reports = await prisma.report.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const reportWithIdOnly = await prisma.report.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends reportFindManyArgs>(
      args?: SelectSubset<T, reportFindManyArgs>
    ): Prisma.PrismaPromise<Array<reportGetPayload<T>>>

    /**
     * Create a Report.
     * @param {reportCreateArgs} args - Arguments to create a Report.
     * @example
     * // Create one Report
     * const Report = await prisma.report.create({
     *   data: {
     *     // ... data to create a Report
     *   }
     * })
     * 
    **/
    create<T extends reportCreateArgs>(
      args: SelectSubset<T, reportCreateArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Delete a Report.
     * @param {reportDeleteArgs} args - Arguments to delete one Report.
     * @example
     * // Delete one Report
     * const Report = await prisma.report.delete({
     *   where: {
     *     // ... filter to delete one Report
     *   }
     * })
     * 
    **/
    delete<T extends reportDeleteArgs>(
      args: SelectSubset<T, reportDeleteArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Update one Report.
     * @param {reportUpdateArgs} args - Arguments to update one Report.
     * @example
     * // Update one Report
     * const report = await prisma.report.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends reportUpdateArgs>(
      args: SelectSubset<T, reportUpdateArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Delete zero or more Reports.
     * @param {reportDeleteManyArgs} args - Arguments to filter Reports to delete.
     * @example
     * // Delete a few Reports
     * const { count } = await prisma.report.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends reportDeleteManyArgs>(
      args?: SelectSubset<T, reportDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Reports
     * const report = await prisma.report.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends reportUpdateManyArgs>(
      args: SelectSubset<T, reportUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Report.
     * @param {reportUpsertArgs} args - Arguments to update or create a Report.
     * @example
     * // Update or create a Report
     * const report = await prisma.report.upsert({
     *   create: {
     *     // ... data to create a Report
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Report we want to update
     *   }
     * })
    **/
    upsert<T extends reportUpsertArgs>(
      args: SelectSubset<T, reportUpsertArgs>
    ): Prisma__reportClient<reportGetPayload<T>>

    /**
     * Count the number of Reports.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {reportCountArgs} args - Arguments to filter Reports to count.
     * @example
     * // Count the number of Reports
     * const count = await prisma.report.count({
     *   where: {
     *     // ... the filter for the Reports we want to count
     *   }
     * })
    **/
    count<T extends reportCountArgs>(
      args?: Subset<T, reportCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ReportCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ReportAggregateArgs>(args: Subset<T, ReportAggregateArgs>): Prisma.PrismaPromise<GetReportAggregateType<T>>

    /**
     * Group by Report.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ReportGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ReportGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ReportGroupByArgs['orderBy'] }
        : { orderBy?: ReportGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ReportGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetReportGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for report.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__reportClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    tv<T extends tvArgs= {}>(args?: Subset<T, tvArgs>): Prisma__tvClient<tvGetPayload<T> | Null>;

    season<T extends seasonArgs= {}>(args?: Subset<T, seasonArgs>): Prisma__seasonClient<seasonGetPayload<T> | Null>;

    episode<T extends episodeArgs= {}>(args?: Subset<T, episodeArgs>): Prisma__episodeClient<episodeGetPayload<T> | Null>;

    movie<T extends movieArgs= {}>(args?: Subset<T, movieArgs>): Prisma__movieClient<movieGetPayload<T> | Null>;

    member<T extends memberArgs= {}>(args?: Subset<T, memberArgs>): Prisma__memberClient<memberGetPayload<T> | Null>;

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * report base type for findUnique actions
   */
  export type reportFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter, which report to fetch.
     */
    where: reportWhereUniqueInput
  }

  /**
   * report findUnique
   */
  export interface reportFindUniqueArgs extends reportFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * report findUniqueOrThrow
   */
  export type reportFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter, which report to fetch.
     */
    where: reportWhereUniqueInput
  }


  /**
   * report base type for findFirst actions
   */
  export type reportFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter, which report to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: Enumerable<ReportScalarFieldEnum>
  }

  /**
   * report findFirst
   */
  export interface reportFindFirstArgs extends reportFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * report findFirstOrThrow
   */
  export type reportFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter, which report to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of reports.
     */
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * report findMany
   */
  export type reportFindManyArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter, which reports to fetch.
     */
    where?: reportWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of reports to fetch.
     */
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing reports.
     */
    cursor?: reportWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` reports from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` reports.
     */
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * report create
   */
  export type reportCreateArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * The data needed to create a report.
     */
    data: XOR<reportCreateInput, reportUncheckedCreateInput>
  }


  /**
   * report update
   */
  export type reportUpdateArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * The data needed to update a report.
     */
    data: XOR<reportUpdateInput, reportUncheckedUpdateInput>
    /**
     * Choose, which report to update.
     */
    where: reportWhereUniqueInput
  }


  /**
   * report updateMany
   */
  export type reportUpdateManyArgs = {
    /**
     * The data used to update reports.
     */
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyInput>
    /**
     * Filter which reports to update
     */
    where?: reportWhereInput
  }


  /**
   * report upsert
   */
  export type reportUpsertArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * The filter to search for the report to update in case it exists.
     */
    where: reportWhereUniqueInput
    /**
     * In case the report found by the `where` argument doesn't exist, create a new report with this data.
     */
    create: XOR<reportCreateInput, reportUncheckedCreateInput>
    /**
     * In case the report was found with the provided `where` argument, update it with this data.
     */
    update: XOR<reportUpdateInput, reportUncheckedUpdateInput>
  }


  /**
   * report delete
   */
  export type reportDeleteArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    /**
     * Filter which report to delete.
     */
    where: reportWhereUniqueInput
  }


  /**
   * report deleteMany
   */
  export type reportDeleteManyArgs = {
    /**
     * Filter which reports to delete
     */
    where?: reportWhereInput
  }


  /**
   * report without action
   */
  export type reportArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
  }



  /**
   * Model account
   */


  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    type: string | null
    provider: string | null
    provider_account_id: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    user_id: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    type: string | null
    provider: string | null
    provider_account_id: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    user_id: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    type: number
    provider: number
    provider_account_id: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    user_id: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    type?: true
    provider?: true
    provider_account_id?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    user_id?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    type?: true
    provider?: true
    provider_account_id?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    user_id?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    type?: true
    provider?: true
    provider_account_id?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    user_id?: true
    _all?: true
  }

  export type AccountAggregateArgs = {
    /**
     * Filter which account to aggregate.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: Enumerable<accountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs = {
    where?: accountWhereInput
    orderBy?: Enumerable<accountOrderByWithAggregationInput>
    by: AccountScalarFieldEnum[]
    having?: accountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }


  export type AccountGroupByOutputType = {
    id: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    user_id: string
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type accountSelect = {
    id?: boolean
    type?: boolean
    provider?: boolean
    provider_account_id?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user_id?: boolean
    user?: boolean | userArgs
  }


  export type accountInclude = {
    user?: boolean | userArgs
  }

  export type accountGetPayload<S extends boolean | null | undefined | accountArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? account :
    S extends undefined ? never :
    S extends { include: any } & (accountArgs | accountFindManyArgs)
    ? account  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (accountArgs | accountFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof account ? account[P] : never
  } 
      : account


  type accountCountArgs = 
    Omit<accountFindManyArgs, 'select' | 'include'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface accountDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Account that matches the filter.
     * @param {accountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends accountFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, accountFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'account'> extends True ? Prisma__accountClient<accountGetPayload<T>> : Prisma__accountClient<accountGetPayload<T> | null, null>

    /**
     * Find one Account that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {accountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends accountFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, accountFindUniqueOrThrowArgs>
    ): Prisma__accountClient<accountGetPayload<T>>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends accountFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, accountFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'account'> extends True ? Prisma__accountClient<accountGetPayload<T>> : Prisma__accountClient<accountGetPayload<T> | null, null>

    /**
     * Find the first Account that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends accountFindFirstOrThrowArgs>(
      args?: SelectSubset<T, accountFindFirstOrThrowArgs>
    ): Prisma__accountClient<accountGetPayload<T>>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends accountFindManyArgs>(
      args?: SelectSubset<T, accountFindManyArgs>
    ): Prisma.PrismaPromise<Array<accountGetPayload<T>>>

    /**
     * Create a Account.
     * @param {accountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
    **/
    create<T extends accountCreateArgs>(
      args: SelectSubset<T, accountCreateArgs>
    ): Prisma__accountClient<accountGetPayload<T>>

    /**
     * Delete a Account.
     * @param {accountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
    **/
    delete<T extends accountDeleteArgs>(
      args: SelectSubset<T, accountDeleteArgs>
    ): Prisma__accountClient<accountGetPayload<T>>

    /**
     * Update one Account.
     * @param {accountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends accountUpdateArgs>(
      args: SelectSubset<T, accountUpdateArgs>
    ): Prisma__accountClient<accountGetPayload<T>>

    /**
     * Delete zero or more Accounts.
     * @param {accountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends accountDeleteManyArgs>(
      args?: SelectSubset<T, accountDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends accountUpdateManyArgs>(
      args: SelectSubset<T, accountUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Account.
     * @param {accountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
    **/
    upsert<T extends accountUpsertArgs>(
      args: SelectSubset<T, accountUpsertArgs>
    ): Prisma__accountClient<accountGetPayload<T>>

    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {accountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends accountCountArgs>(
      args?: Subset<T, accountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__accountClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * account base type for findUnique actions
   */
  export type accountFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude | null
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput
  }

  /**
   * account findUnique
   */
  export interface accountFindUniqueArgs extends accountFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * account findUniqueOrThrow
   */
  export type accountFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude | null
    /**
     * Filter, which account to fetch.
     */
    where: accountWhereUniqueInput
  }


  /**
   * account base type for findFirst actions
   */
  export type accountFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude | null
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: Enumerable<accountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }

  /**
   * account findFirst
   */
  export interface accountFindFirstArgs extends accountFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * account findFirstOrThrow
   */
  export type accountFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude | null
    /**
     * Filter, which account to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: Enumerable<accountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of accounts.
     */
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * account findMany
   */
  export type accountFindManyArgs = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude | null
    /**
     * Filter, which accounts to fetch.
     */
    where?: accountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of accounts to fetch.
     */
    orderBy?: Enumerable<accountOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing accounts.
     */
    cursor?: accountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` accounts.
     */
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * account create
   */
  export type accountCreateArgs = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude | null
    /**
     * The data needed to create a account.
     */
    data: XOR<accountCreateInput, accountUncheckedCreateInput>
  }


  /**
   * account update
   */
  export type accountUpdateArgs = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude | null
    /**
     * The data needed to update a account.
     */
    data: XOR<accountUpdateInput, accountUncheckedUpdateInput>
    /**
     * Choose, which account to update.
     */
    where: accountWhereUniqueInput
  }


  /**
   * account updateMany
   */
  export type accountUpdateManyArgs = {
    /**
     * The data used to update accounts.
     */
    data: XOR<accountUpdateManyMutationInput, accountUncheckedUpdateManyInput>
    /**
     * Filter which accounts to update
     */
    where?: accountWhereInput
  }


  /**
   * account upsert
   */
  export type accountUpsertArgs = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude | null
    /**
     * The filter to search for the account to update in case it exists.
     */
    where: accountWhereUniqueInput
    /**
     * In case the account found by the `where` argument doesn't exist, create a new account with this data.
     */
    create: XOR<accountCreateInput, accountUncheckedCreateInput>
    /**
     * In case the account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<accountUpdateInput, accountUncheckedUpdateInput>
  }


  /**
   * account delete
   */
  export type accountDeleteArgs = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude | null
    /**
     * Filter which account to delete.
     */
    where: accountWhereUniqueInput
  }


  /**
   * account deleteMany
   */
  export type accountDeleteManyArgs = {
    /**
     * Filter which accounts to delete
     */
    where?: accountWhereInput
  }


  /**
   * account without action
   */
  export type accountArgs = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude | null
  }



  /**
   * Model credential
   */


  export type AggregateCredential = {
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  export type CredentialMinAggregateOutputType = {
    id: string | null
    password: string | null
    salt: string | null
    verified: boolean | null
    email: string | null
    user_id: string | null
  }

  export type CredentialMaxAggregateOutputType = {
    id: string | null
    password: string | null
    salt: string | null
    verified: boolean | null
    email: string | null
    user_id: string | null
  }

  export type CredentialCountAggregateOutputType = {
    id: number
    password: number
    salt: number
    verified: number
    email: number
    user_id: number
    _all: number
  }


  export type CredentialMinAggregateInputType = {
    id?: true
    password?: true
    salt?: true
    verified?: true
    email?: true
    user_id?: true
  }

  export type CredentialMaxAggregateInputType = {
    id?: true
    password?: true
    salt?: true
    verified?: true
    email?: true
    user_id?: true
  }

  export type CredentialCountAggregateInputType = {
    id?: true
    password?: true
    salt?: true
    verified?: true
    email?: true
    user_id?: true
    _all?: true
  }

  export type CredentialAggregateArgs = {
    /**
     * Filter which credential to aggregate.
     */
    where?: credentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credentials to fetch.
     */
    orderBy?: Enumerable<credentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: credentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned credentials
    **/
    _count?: true | CredentialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CredentialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CredentialMaxAggregateInputType
  }

  export type GetCredentialAggregateType<T extends CredentialAggregateArgs> = {
        [P in keyof T & keyof AggregateCredential]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCredential[P]>
      : GetScalarType<T[P], AggregateCredential[P]>
  }




  export type CredentialGroupByArgs = {
    where?: credentialWhereInput
    orderBy?: Enumerable<credentialOrderByWithAggregationInput>
    by: CredentialScalarFieldEnum[]
    having?: credentialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CredentialCountAggregateInputType | true
    _min?: CredentialMinAggregateInputType
    _max?: CredentialMaxAggregateInputType
  }


  export type CredentialGroupByOutputType = {
    id: string
    password: string
    salt: string
    verified: boolean
    email: string
    user_id: string
    _count: CredentialCountAggregateOutputType | null
    _min: CredentialMinAggregateOutputType | null
    _max: CredentialMaxAggregateOutputType | null
  }

  type GetCredentialGroupByPayload<T extends CredentialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<CredentialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CredentialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CredentialGroupByOutputType[P]>
            : GetScalarType<T[P], CredentialGroupByOutputType[P]>
        }
      >
    >


  export type credentialSelect = {
    id?: boolean
    password?: boolean
    salt?: boolean
    verified?: boolean
    email?: boolean
    user_id?: boolean
    user?: boolean | userArgs
  }


  export type credentialInclude = {
    user?: boolean | userArgs
  }

  export type credentialGetPayload<S extends boolean | null | undefined | credentialArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? credential :
    S extends undefined ? never :
    S extends { include: any } & (credentialArgs | credentialFindManyArgs)
    ? credential  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (credentialArgs | credentialFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof credential ? credential[P] : never
  } 
      : credential


  type credentialCountArgs = 
    Omit<credentialFindManyArgs, 'select' | 'include'> & {
      select?: CredentialCountAggregateInputType | true
    }

  export interface credentialDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Credential that matches the filter.
     * @param {credentialFindUniqueArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends credentialFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, credentialFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'credential'> extends True ? Prisma__credentialClient<credentialGetPayload<T>> : Prisma__credentialClient<credentialGetPayload<T> | null, null>

    /**
     * Find one Credential that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {credentialFindUniqueOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends credentialFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, credentialFindUniqueOrThrowArgs>
    ): Prisma__credentialClient<credentialGetPayload<T>>

    /**
     * Find the first Credential that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credentialFindFirstArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends credentialFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, credentialFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'credential'> extends True ? Prisma__credentialClient<credentialGetPayload<T>> : Prisma__credentialClient<credentialGetPayload<T> | null, null>

    /**
     * Find the first Credential that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credentialFindFirstOrThrowArgs} args - Arguments to find a Credential
     * @example
     * // Get one Credential
     * const credential = await prisma.credential.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends credentialFindFirstOrThrowArgs>(
      args?: SelectSubset<T, credentialFindFirstOrThrowArgs>
    ): Prisma__credentialClient<credentialGetPayload<T>>

    /**
     * Find zero or more Credentials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credentialFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Credentials
     * const credentials = await prisma.credential.findMany()
     * 
     * // Get first 10 Credentials
     * const credentials = await prisma.credential.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const credentialWithIdOnly = await prisma.credential.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends credentialFindManyArgs>(
      args?: SelectSubset<T, credentialFindManyArgs>
    ): Prisma.PrismaPromise<Array<credentialGetPayload<T>>>

    /**
     * Create a Credential.
     * @param {credentialCreateArgs} args - Arguments to create a Credential.
     * @example
     * // Create one Credential
     * const Credential = await prisma.credential.create({
     *   data: {
     *     // ... data to create a Credential
     *   }
     * })
     * 
    **/
    create<T extends credentialCreateArgs>(
      args: SelectSubset<T, credentialCreateArgs>
    ): Prisma__credentialClient<credentialGetPayload<T>>

    /**
     * Delete a Credential.
     * @param {credentialDeleteArgs} args - Arguments to delete one Credential.
     * @example
     * // Delete one Credential
     * const Credential = await prisma.credential.delete({
     *   where: {
     *     // ... filter to delete one Credential
     *   }
     * })
     * 
    **/
    delete<T extends credentialDeleteArgs>(
      args: SelectSubset<T, credentialDeleteArgs>
    ): Prisma__credentialClient<credentialGetPayload<T>>

    /**
     * Update one Credential.
     * @param {credentialUpdateArgs} args - Arguments to update one Credential.
     * @example
     * // Update one Credential
     * const credential = await prisma.credential.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends credentialUpdateArgs>(
      args: SelectSubset<T, credentialUpdateArgs>
    ): Prisma__credentialClient<credentialGetPayload<T>>

    /**
     * Delete zero or more Credentials.
     * @param {credentialDeleteManyArgs} args - Arguments to filter Credentials to delete.
     * @example
     * // Delete a few Credentials
     * const { count } = await prisma.credential.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends credentialDeleteManyArgs>(
      args?: SelectSubset<T, credentialDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credentialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Credentials
     * const credential = await prisma.credential.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends credentialUpdateManyArgs>(
      args: SelectSubset<T, credentialUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Credential.
     * @param {credentialUpsertArgs} args - Arguments to update or create a Credential.
     * @example
     * // Update or create a Credential
     * const credential = await prisma.credential.upsert({
     *   create: {
     *     // ... data to create a Credential
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Credential we want to update
     *   }
     * })
    **/
    upsert<T extends credentialUpsertArgs>(
      args: SelectSubset<T, credentialUpsertArgs>
    ): Prisma__credentialClient<credentialGetPayload<T>>

    /**
     * Count the number of Credentials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {credentialCountArgs} args - Arguments to filter Credentials to count.
     * @example
     * // Count the number of Credentials
     * const count = await prisma.credential.count({
     *   where: {
     *     // ... the filter for the Credentials we want to count
     *   }
     * })
    **/
    count<T extends credentialCountArgs>(
      args?: Subset<T, credentialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CredentialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CredentialAggregateArgs>(args: Subset<T, CredentialAggregateArgs>): Prisma.PrismaPromise<GetCredentialAggregateType<T>>

    /**
     * Group by Credential.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CredentialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CredentialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CredentialGroupByArgs['orderBy'] }
        : { orderBy?: CredentialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CredentialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCredentialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for credential.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__credentialClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * credential base type for findUnique actions
   */
  export type credentialFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the credential
     */
    select?: credentialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credentialInclude | null
    /**
     * Filter, which credential to fetch.
     */
    where: credentialWhereUniqueInput
  }

  /**
   * credential findUnique
   */
  export interface credentialFindUniqueArgs extends credentialFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * credential findUniqueOrThrow
   */
  export type credentialFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the credential
     */
    select?: credentialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credentialInclude | null
    /**
     * Filter, which credential to fetch.
     */
    where: credentialWhereUniqueInput
  }


  /**
   * credential base type for findFirst actions
   */
  export type credentialFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the credential
     */
    select?: credentialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credentialInclude | null
    /**
     * Filter, which credential to fetch.
     */
    where?: credentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credentials to fetch.
     */
    orderBy?: Enumerable<credentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credentials.
     */
    cursor?: credentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credentials.
     */
    distinct?: Enumerable<CredentialScalarFieldEnum>
  }

  /**
   * credential findFirst
   */
  export interface credentialFindFirstArgs extends credentialFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * credential findFirstOrThrow
   */
  export type credentialFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the credential
     */
    select?: credentialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credentialInclude | null
    /**
     * Filter, which credential to fetch.
     */
    where?: credentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credentials to fetch.
     */
    orderBy?: Enumerable<credentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for credentials.
     */
    cursor?: credentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credentials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of credentials.
     */
    distinct?: Enumerable<CredentialScalarFieldEnum>
  }


  /**
   * credential findMany
   */
  export type credentialFindManyArgs = {
    /**
     * Select specific fields to fetch from the credential
     */
    select?: credentialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credentialInclude | null
    /**
     * Filter, which credentials to fetch.
     */
    where?: credentialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of credentials to fetch.
     */
    orderBy?: Enumerable<credentialOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing credentials.
     */
    cursor?: credentialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` credentials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` credentials.
     */
    skip?: number
    distinct?: Enumerable<CredentialScalarFieldEnum>
  }


  /**
   * credential create
   */
  export type credentialCreateArgs = {
    /**
     * Select specific fields to fetch from the credential
     */
    select?: credentialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credentialInclude | null
    /**
     * The data needed to create a credential.
     */
    data: XOR<credentialCreateInput, credentialUncheckedCreateInput>
  }


  /**
   * credential update
   */
  export type credentialUpdateArgs = {
    /**
     * Select specific fields to fetch from the credential
     */
    select?: credentialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credentialInclude | null
    /**
     * The data needed to update a credential.
     */
    data: XOR<credentialUpdateInput, credentialUncheckedUpdateInput>
    /**
     * Choose, which credential to update.
     */
    where: credentialWhereUniqueInput
  }


  /**
   * credential updateMany
   */
  export type credentialUpdateManyArgs = {
    /**
     * The data used to update credentials.
     */
    data: XOR<credentialUpdateManyMutationInput, credentialUncheckedUpdateManyInput>
    /**
     * Filter which credentials to update
     */
    where?: credentialWhereInput
  }


  /**
   * credential upsert
   */
  export type credentialUpsertArgs = {
    /**
     * Select specific fields to fetch from the credential
     */
    select?: credentialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credentialInclude | null
    /**
     * The filter to search for the credential to update in case it exists.
     */
    where: credentialWhereUniqueInput
    /**
     * In case the credential found by the `where` argument doesn't exist, create a new credential with this data.
     */
    create: XOR<credentialCreateInput, credentialUncheckedCreateInput>
    /**
     * In case the credential was found with the provided `where` argument, update it with this data.
     */
    update: XOR<credentialUpdateInput, credentialUncheckedUpdateInput>
  }


  /**
   * credential delete
   */
  export type credentialDeleteArgs = {
    /**
     * Select specific fields to fetch from the credential
     */
    select?: credentialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credentialInclude | null
    /**
     * Filter which credential to delete.
     */
    where: credentialWhereUniqueInput
  }


  /**
   * credential deleteMany
   */
  export type credentialDeleteManyArgs = {
    /**
     * Filter which credentials to delete
     */
    where?: credentialWhereInput
  }


  /**
   * credential without action
   */
  export type credentialArgs = {
    /**
     * Select specific fields to fetch from the credential
     */
    select?: credentialSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: credentialInclude | null
  }



  /**
   * Model profile
   */


  export type AggregateProfile = {
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  export type ProfileMinAggregateOutputType = {
    id: string | null
    nickname: string | null
    avatar: string | null
    user_id: string | null
  }

  export type ProfileMaxAggregateOutputType = {
    id: string | null
    nickname: string | null
    avatar: string | null
    user_id: string | null
  }

  export type ProfileCountAggregateOutputType = {
    id: number
    nickname: number
    avatar: number
    user_id: number
    _all: number
  }


  export type ProfileMinAggregateInputType = {
    id?: true
    nickname?: true
    avatar?: true
    user_id?: true
  }

  export type ProfileMaxAggregateInputType = {
    id?: true
    nickname?: true
    avatar?: true
    user_id?: true
  }

  export type ProfileCountAggregateInputType = {
    id?: true
    nickname?: true
    avatar?: true
    user_id?: true
    _all?: true
  }

  export type ProfileAggregateArgs = {
    /**
     * Filter which profile to aggregate.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: Enumerable<profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned profiles
    **/
    _count?: true | ProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProfileMaxAggregateInputType
  }

  export type GetProfileAggregateType<T extends ProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProfile[P]>
      : GetScalarType<T[P], AggregateProfile[P]>
  }




  export type ProfileGroupByArgs = {
    where?: profileWhereInput
    orderBy?: Enumerable<profileOrderByWithAggregationInput>
    by: ProfileScalarFieldEnum[]
    having?: profileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProfileCountAggregateInputType | true
    _min?: ProfileMinAggregateInputType
    _max?: ProfileMaxAggregateInputType
  }


  export type ProfileGroupByOutputType = {
    id: string
    nickname: string | null
    avatar: string | null
    user_id: string
    _count: ProfileCountAggregateOutputType | null
    _min: ProfileMinAggregateOutputType | null
    _max: ProfileMaxAggregateOutputType | null
  }

  type GetProfileGroupByPayload<T extends ProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<ProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProfileGroupByOutputType[P]>
            : GetScalarType<T[P], ProfileGroupByOutputType[P]>
        }
      >
    >


  export type profileSelect = {
    id?: boolean
    nickname?: boolean
    avatar?: boolean
    user_id?: boolean
    user?: boolean | userArgs
  }


  export type profileInclude = {
    user?: boolean | userArgs
  }

  export type profileGetPayload<S extends boolean | null | undefined | profileArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? profile :
    S extends undefined ? never :
    S extends { include: any } & (profileArgs | profileFindManyArgs)
    ? profile  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (profileArgs | profileFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof profile ? profile[P] : never
  } 
      : profile


  type profileCountArgs = 
    Omit<profileFindManyArgs, 'select' | 'include'> & {
      select?: ProfileCountAggregateInputType | true
    }

  export interface profileDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Profile that matches the filter.
     * @param {profileFindUniqueArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends profileFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, profileFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'profile'> extends True ? Prisma__profileClient<profileGetPayload<T>> : Prisma__profileClient<profileGetPayload<T> | null, null>

    /**
     * Find one Profile that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {profileFindUniqueOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends profileFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, profileFindUniqueOrThrowArgs>
    ): Prisma__profileClient<profileGetPayload<T>>

    /**
     * Find the first Profile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends profileFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, profileFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'profile'> extends True ? Prisma__profileClient<profileGetPayload<T>> : Prisma__profileClient<profileGetPayload<T> | null, null>

    /**
     * Find the first Profile that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindFirstOrThrowArgs} args - Arguments to find a Profile
     * @example
     * // Get one Profile
     * const profile = await prisma.profile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends profileFindFirstOrThrowArgs>(
      args?: SelectSubset<T, profileFindFirstOrThrowArgs>
    ): Prisma__profileClient<profileGetPayload<T>>

    /**
     * Find zero or more Profiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Profiles
     * const profiles = await prisma.profile.findMany()
     * 
     * // Get first 10 Profiles
     * const profiles = await prisma.profile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const profileWithIdOnly = await prisma.profile.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends profileFindManyArgs>(
      args?: SelectSubset<T, profileFindManyArgs>
    ): Prisma.PrismaPromise<Array<profileGetPayload<T>>>

    /**
     * Create a Profile.
     * @param {profileCreateArgs} args - Arguments to create a Profile.
     * @example
     * // Create one Profile
     * const Profile = await prisma.profile.create({
     *   data: {
     *     // ... data to create a Profile
     *   }
     * })
     * 
    **/
    create<T extends profileCreateArgs>(
      args: SelectSubset<T, profileCreateArgs>
    ): Prisma__profileClient<profileGetPayload<T>>

    /**
     * Delete a Profile.
     * @param {profileDeleteArgs} args - Arguments to delete one Profile.
     * @example
     * // Delete one Profile
     * const Profile = await prisma.profile.delete({
     *   where: {
     *     // ... filter to delete one Profile
     *   }
     * })
     * 
    **/
    delete<T extends profileDeleteArgs>(
      args: SelectSubset<T, profileDeleteArgs>
    ): Prisma__profileClient<profileGetPayload<T>>

    /**
     * Update one Profile.
     * @param {profileUpdateArgs} args - Arguments to update one Profile.
     * @example
     * // Update one Profile
     * const profile = await prisma.profile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends profileUpdateArgs>(
      args: SelectSubset<T, profileUpdateArgs>
    ): Prisma__profileClient<profileGetPayload<T>>

    /**
     * Delete zero or more Profiles.
     * @param {profileDeleteManyArgs} args - Arguments to filter Profiles to delete.
     * @example
     * // Delete a few Profiles
     * const { count } = await prisma.profile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends profileDeleteManyArgs>(
      args?: SelectSubset<T, profileDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Profiles
     * const profile = await prisma.profile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends profileUpdateManyArgs>(
      args: SelectSubset<T, profileUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Profile.
     * @param {profileUpsertArgs} args - Arguments to update or create a Profile.
     * @example
     * // Update or create a Profile
     * const profile = await prisma.profile.upsert({
     *   create: {
     *     // ... data to create a Profile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Profile we want to update
     *   }
     * })
    **/
    upsert<T extends profileUpsertArgs>(
      args: SelectSubset<T, profileUpsertArgs>
    ): Prisma__profileClient<profileGetPayload<T>>

    /**
     * Count the number of Profiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {profileCountArgs} args - Arguments to filter Profiles to count.
     * @example
     * // Count the number of Profiles
     * const count = await prisma.profile.count({
     *   where: {
     *     // ... the filter for the Profiles we want to count
     *   }
     * })
    **/
    count<T extends profileCountArgs>(
      args?: Subset<T, profileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProfileAggregateArgs>(args: Subset<T, ProfileAggregateArgs>): Prisma.PrismaPromise<GetProfileAggregateType<T>>

    /**
     * Group by Profile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProfileGroupByArgs['orderBy'] }
        : { orderBy?: ProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for profile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__profileClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * profile base type for findUnique actions
   */
  export type profileFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }

  /**
   * profile findUnique
   */
  export interface profileFindUniqueArgs extends profileFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * profile findUniqueOrThrow
   */
  export type profileFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude | null
    /**
     * Filter, which profile to fetch.
     */
    where: profileWhereUniqueInput
  }


  /**
   * profile base type for findFirst actions
   */
  export type profileFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: Enumerable<profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }

  /**
   * profile findFirst
   */
  export interface profileFindFirstArgs extends profileFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * profile findFirstOrThrow
   */
  export type profileFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude | null
    /**
     * Filter, which profile to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: Enumerable<profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of profiles.
     */
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * profile findMany
   */
  export type profileFindManyArgs = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude | null
    /**
     * Filter, which profiles to fetch.
     */
    where?: profileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of profiles to fetch.
     */
    orderBy?: Enumerable<profileOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing profiles.
     */
    cursor?: profileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` profiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` profiles.
     */
    skip?: number
    distinct?: Enumerable<ProfileScalarFieldEnum>
  }


  /**
   * profile create
   */
  export type profileCreateArgs = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude | null
    /**
     * The data needed to create a profile.
     */
    data: XOR<profileCreateInput, profileUncheckedCreateInput>
  }


  /**
   * profile update
   */
  export type profileUpdateArgs = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude | null
    /**
     * The data needed to update a profile.
     */
    data: XOR<profileUpdateInput, profileUncheckedUpdateInput>
    /**
     * Choose, which profile to update.
     */
    where: profileWhereUniqueInput
  }


  /**
   * profile updateMany
   */
  export type profileUpdateManyArgs = {
    /**
     * The data used to update profiles.
     */
    data: XOR<profileUpdateManyMutationInput, profileUncheckedUpdateManyInput>
    /**
     * Filter which profiles to update
     */
    where?: profileWhereInput
  }


  /**
   * profile upsert
   */
  export type profileUpsertArgs = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude | null
    /**
     * The filter to search for the profile to update in case it exists.
     */
    where: profileWhereUniqueInput
    /**
     * In case the profile found by the `where` argument doesn't exist, create a new profile with this data.
     */
    create: XOR<profileCreateInput, profileUncheckedCreateInput>
    /**
     * In case the profile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<profileUpdateInput, profileUncheckedUpdateInput>
  }


  /**
   * profile delete
   */
  export type profileDeleteArgs = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude | null
    /**
     * Filter which profile to delete.
     */
    where: profileWhereUniqueInput
  }


  /**
   * profile deleteMany
   */
  export type profileDeleteManyArgs = {
    /**
     * Filter which profiles to delete
     */
    where?: profileWhereInput
  }


  /**
   * profile without action
   */
  export type profileArgs = {
    /**
     * Select specific fields to fetch from the profile
     */
    select?: profileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: profileInclude | null
  }



  /**
   * Model settings
   */


  export type AggregateSettings = {
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  export type SettingsMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    detail: string | null
    user_id: string | null
  }

  export type SettingsMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
    detail: string | null
    user_id: string | null
  }

  export type SettingsCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    detail: number
    user_id: number
    _all: number
  }


  export type SettingsMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    detail?: true
    user_id?: true
  }

  export type SettingsMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    detail?: true
    user_id?: true
  }

  export type SettingsCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    detail?: true
    user_id?: true
    _all?: true
  }

  export type SettingsAggregateArgs = {
    /**
     * Filter which settings to aggregate.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: Enumerable<settingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned settings
    **/
    _count?: true | SettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingsMaxAggregateInputType
  }

  export type GetSettingsAggregateType<T extends SettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSettings[P]>
      : GetScalarType<T[P], AggregateSettings[P]>
  }




  export type SettingsGroupByArgs = {
    where?: settingsWhereInput
    orderBy?: Enumerable<settingsOrderByWithAggregationInput>
    by: SettingsScalarFieldEnum[]
    having?: settingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingsCountAggregateInputType | true
    _min?: SettingsMinAggregateInputType
    _max?: SettingsMaxAggregateInputType
  }


  export type SettingsGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    detail: string | null
    user_id: string
    _count: SettingsCountAggregateOutputType | null
    _min: SettingsMinAggregateOutputType | null
    _max: SettingsMaxAggregateOutputType | null
  }

  type GetSettingsGroupByPayload<T extends SettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<SettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SettingsGroupByOutputType[P]>
        }
      >
    >


  export type settingsSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    detail?: boolean
    user_id?: boolean
    user?: boolean | userArgs
  }


  export type settingsInclude = {
    user?: boolean | userArgs
  }

  export type settingsGetPayload<S extends boolean | null | undefined | settingsArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? settings :
    S extends undefined ? never :
    S extends { include: any } & (settingsArgs | settingsFindManyArgs)
    ? settings  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'user' ? userGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (settingsArgs | settingsFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'user' ? userGetPayload<S['select'][P]> :  P extends keyof settings ? settings[P] : never
  } 
      : settings


  type settingsCountArgs = 
    Omit<settingsFindManyArgs, 'select' | 'include'> & {
      select?: SettingsCountAggregateInputType | true
    }

  export interface settingsDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one Settings that matches the filter.
     * @param {settingsFindUniqueArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends settingsFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, settingsFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'settings'> extends True ? Prisma__settingsClient<settingsGetPayload<T>> : Prisma__settingsClient<settingsGetPayload<T> | null, null>

    /**
     * Find one Settings that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {settingsFindUniqueOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends settingsFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, settingsFindUniqueOrThrowArgs>
    ): Prisma__settingsClient<settingsGetPayload<T>>

    /**
     * Find the first Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends settingsFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, settingsFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'settings'> extends True ? Prisma__settingsClient<settingsGetPayload<T>> : Prisma__settingsClient<settingsGetPayload<T> | null, null>

    /**
     * Find the first Settings that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindFirstOrThrowArgs} args - Arguments to find a Settings
     * @example
     * // Get one Settings
     * const settings = await prisma.settings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends settingsFindFirstOrThrowArgs>(
      args?: SelectSubset<T, settingsFindFirstOrThrowArgs>
    ): Prisma__settingsClient<settingsGetPayload<T>>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.settings.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.settings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingsWithIdOnly = await prisma.settings.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends settingsFindManyArgs>(
      args?: SelectSubset<T, settingsFindManyArgs>
    ): Prisma.PrismaPromise<Array<settingsGetPayload<T>>>

    /**
     * Create a Settings.
     * @param {settingsCreateArgs} args - Arguments to create a Settings.
     * @example
     * // Create one Settings
     * const Settings = await prisma.settings.create({
     *   data: {
     *     // ... data to create a Settings
     *   }
     * })
     * 
    **/
    create<T extends settingsCreateArgs>(
      args: SelectSubset<T, settingsCreateArgs>
    ): Prisma__settingsClient<settingsGetPayload<T>>

    /**
     * Delete a Settings.
     * @param {settingsDeleteArgs} args - Arguments to delete one Settings.
     * @example
     * // Delete one Settings
     * const Settings = await prisma.settings.delete({
     *   where: {
     *     // ... filter to delete one Settings
     *   }
     * })
     * 
    **/
    delete<T extends settingsDeleteArgs>(
      args: SelectSubset<T, settingsDeleteArgs>
    ): Prisma__settingsClient<settingsGetPayload<T>>

    /**
     * Update one Settings.
     * @param {settingsUpdateArgs} args - Arguments to update one Settings.
     * @example
     * // Update one Settings
     * const settings = await prisma.settings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends settingsUpdateArgs>(
      args: SelectSubset<T, settingsUpdateArgs>
    ): Prisma__settingsClient<settingsGetPayload<T>>

    /**
     * Delete zero or more Settings.
     * @param {settingsDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.settings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends settingsDeleteManyArgs>(
      args?: SelectSubset<T, settingsDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const settings = await prisma.settings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends settingsUpdateManyArgs>(
      args: SelectSubset<T, settingsUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Settings.
     * @param {settingsUpsertArgs} args - Arguments to update or create a Settings.
     * @example
     * // Update or create a Settings
     * const settings = await prisma.settings.upsert({
     *   create: {
     *     // ... data to create a Settings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Settings we want to update
     *   }
     * })
    **/
    upsert<T extends settingsUpsertArgs>(
      args: SelectSubset<T, settingsUpsertArgs>
    ): Prisma__settingsClient<settingsGetPayload<T>>

    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {settingsCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.settings.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends settingsCountArgs>(
      args?: Subset<T, settingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingsAggregateArgs>(args: Subset<T, SettingsAggregateArgs>): Prisma.PrismaPromise<GetSettingsAggregateType<T>>

    /**
     * Group by Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingsGroupByArgs['orderBy'] }
        : { orderBy?: SettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for settings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__settingsClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    user<T extends userArgs= {}>(args?: Subset<T, userArgs>): Prisma__userClient<userGetPayload<T> | Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * settings base type for findUnique actions
   */
  export type settingsFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }

  /**
   * settings findUnique
   */
  export interface settingsFindUniqueArgs extends settingsFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * settings findUniqueOrThrow
   */
  export type settingsFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude | null
    /**
     * Filter, which settings to fetch.
     */
    where: settingsWhereUniqueInput
  }


  /**
   * settings base type for findFirst actions
   */
  export type settingsFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: Enumerable<settingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: Enumerable<SettingsScalarFieldEnum>
  }

  /**
   * settings findFirst
   */
  export interface settingsFindFirstArgs extends settingsFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * settings findFirstOrThrow
   */
  export type settingsFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: Enumerable<settingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of settings.
     */
    distinct?: Enumerable<SettingsScalarFieldEnum>
  }


  /**
   * settings findMany
   */
  export type settingsFindManyArgs = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude | null
    /**
     * Filter, which settings to fetch.
     */
    where?: settingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of settings to fetch.
     */
    orderBy?: Enumerable<settingsOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing settings.
     */
    cursor?: settingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` settings.
     */
    skip?: number
    distinct?: Enumerable<SettingsScalarFieldEnum>
  }


  /**
   * settings create
   */
  export type settingsCreateArgs = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude | null
    /**
     * The data needed to create a settings.
     */
    data: XOR<settingsCreateInput, settingsUncheckedCreateInput>
  }


  /**
   * settings update
   */
  export type settingsUpdateArgs = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude | null
    /**
     * The data needed to update a settings.
     */
    data: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
    /**
     * Choose, which settings to update.
     */
    where: settingsWhereUniqueInput
  }


  /**
   * settings updateMany
   */
  export type settingsUpdateManyArgs = {
    /**
     * The data used to update settings.
     */
    data: XOR<settingsUpdateManyMutationInput, settingsUncheckedUpdateManyInput>
    /**
     * Filter which settings to update
     */
    where?: settingsWhereInput
  }


  /**
   * settings upsert
   */
  export type settingsUpsertArgs = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude | null
    /**
     * The filter to search for the settings to update in case it exists.
     */
    where: settingsWhereUniqueInput
    /**
     * In case the settings found by the `where` argument doesn't exist, create a new settings with this data.
     */
    create: XOR<settingsCreateInput, settingsUncheckedCreateInput>
    /**
     * In case the settings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<settingsUpdateInput, settingsUncheckedUpdateInput>
  }


  /**
   * settings delete
   */
  export type settingsDeleteArgs = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude | null
    /**
     * Filter which settings to delete.
     */
    where: settingsWhereUniqueInput
  }


  /**
   * settings deleteMany
   */
  export type settingsDeleteManyArgs = {
    /**
     * Filter which settings to delete
     */
    where?: settingsWhereInput
  }


  /**
   * settings without action
   */
  export type settingsArgs = {
    /**
     * Select specific fields to fetch from the settings
     */
    select?: settingsSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: settingsInclude | null
  }



  /**
   * Model user
   */


  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    created: Date | null
    updated: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    created: number
    updated: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    created?: true
    updated?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    created?: true
    updated?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    created?: true
    updated?: true
    _all?: true
  }

  export type UserAggregateArgs = {
    /**
     * Filter which user to aggregate.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs = {
    where?: userWhereInput
    orderBy?: Enumerable<userOrderByWithAggregationInput>
    by: UserScalarFieldEnum[]
    having?: userScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }


  export type UserGroupByOutputType = {
    id: string
    created: Date
    updated: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickArray<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type userSelect = {
    id?: boolean
    created?: boolean
    updated?: boolean
    credential?: boolean | credentialArgs
    profile?: boolean | profileArgs
    settings?: boolean | settingsArgs
    accounts?: boolean | user$accountsArgs
    drives?: boolean | user$drivesArgs
    tv?: boolean | user$tvArgs
    seasons?: boolean | user$seasonsArgs
    episode?: boolean | user$episodeArgs
    movie?: boolean | user$movieArgs
    parsed_tvs?: boolean | user$parsed_tvsArgs
    parsed_seasons?: boolean | user$parsed_seasonsArgs
    parsed_episodes?: boolean | user$parsed_episodesArgs
    parsed_movies?: boolean | user$parsed_moviesArgs
    tv_need_complete?: boolean | user$tv_need_completeArgs
    async_task?: boolean | user$async_taskArgs
    files?: boolean | user$filesArgs
    members?: boolean | user$membersArgs
    shared_files?: boolean | user$shared_filesArgs
    shared_file_in_progress?: boolean | user$shared_file_in_progressArgs
    tmp_files?: boolean | user$tmp_filesArgs
    sync_tasks?: boolean | user$sync_tasksArgs
    notifications?: boolean | user$notificationsArgs
    outputs?: boolean | user$outputsArgs
    reports?: boolean | user$reportsArgs
    collections?: boolean | user$collectionsArgs
    subtitles?: boolean | user$subtitlesArgs
    permission?: boolean | user$permissionArgs
    _count?: boolean | UserCountOutputTypeArgs
  }


  export type userInclude = {
    credential?: boolean | credentialArgs
    profile?: boolean | profileArgs
    settings?: boolean | settingsArgs
    accounts?: boolean | user$accountsArgs
    drives?: boolean | user$drivesArgs
    tv?: boolean | user$tvArgs
    seasons?: boolean | user$seasonsArgs
    episode?: boolean | user$episodeArgs
    movie?: boolean | user$movieArgs
    parsed_tvs?: boolean | user$parsed_tvsArgs
    parsed_seasons?: boolean | user$parsed_seasonsArgs
    parsed_episodes?: boolean | user$parsed_episodesArgs
    parsed_movies?: boolean | user$parsed_moviesArgs
    tv_need_complete?: boolean | user$tv_need_completeArgs
    async_task?: boolean | user$async_taskArgs
    files?: boolean | user$filesArgs
    members?: boolean | user$membersArgs
    shared_files?: boolean | user$shared_filesArgs
    shared_file_in_progress?: boolean | user$shared_file_in_progressArgs
    tmp_files?: boolean | user$tmp_filesArgs
    sync_tasks?: boolean | user$sync_tasksArgs
    notifications?: boolean | user$notificationsArgs
    outputs?: boolean | user$outputsArgs
    reports?: boolean | user$reportsArgs
    collections?: boolean | user$collectionsArgs
    subtitles?: boolean | user$subtitlesArgs
    permission?: boolean | user$permissionArgs
    _count?: boolean | UserCountOutputTypeArgs
  }

  export type userGetPayload<S extends boolean | null | undefined | userArgs> =
    S extends { select: any, include: any } ? 'Please either choose `select` or `include`' :
    S extends true ? user :
    S extends undefined ? never :
    S extends { include: any } & (userArgs | userFindManyArgs)
    ? user  & {
    [P in TruthyKeys<S['include']>]:
        P extends 'credential' ? credentialGetPayload<S['include'][P]> | null :
        P extends 'profile' ? profileGetPayload<S['include'][P]> | null :
        P extends 'settings' ? settingsGetPayload<S['include'][P]> | null :
        P extends 'accounts' ? Array < accountGetPayload<S['include'][P]>>  :
        P extends 'drives' ? Array < driveGetPayload<S['include'][P]>>  :
        P extends 'tv' ? Array < tvGetPayload<S['include'][P]>>  :
        P extends 'seasons' ? Array < seasonGetPayload<S['include'][P]>>  :
        P extends 'episode' ? Array < episodeGetPayload<S['include'][P]>>  :
        P extends 'movie' ? Array < movieGetPayload<S['include'][P]>>  :
        P extends 'parsed_tvs' ? Array < parsed_tvGetPayload<S['include'][P]>>  :
        P extends 'parsed_seasons' ? Array < parsed_seasonGetPayload<S['include'][P]>>  :
        P extends 'parsed_episodes' ? Array < parsed_episodeGetPayload<S['include'][P]>>  :
        P extends 'parsed_movies' ? Array < parsed_movieGetPayload<S['include'][P]>>  :
        P extends 'tv_need_complete' ? Array < incomplete_tvGetPayload<S['include'][P]>>  :
        P extends 'async_task' ? Array < async_taskGetPayload<S['include'][P]>>  :
        P extends 'files' ? Array < fileGetPayload<S['include'][P]>>  :
        P extends 'members' ? Array < memberGetPayload<S['include'][P]>>  :
        P extends 'shared_files' ? Array < shared_fileGetPayload<S['include'][P]>>  :
        P extends 'shared_file_in_progress' ? Array < shared_file_in_progressGetPayload<S['include'][P]>>  :
        P extends 'tmp_files' ? Array < tmp_fileGetPayload<S['include'][P]>>  :
        P extends 'sync_tasks' ? Array < bind_for_parsed_tvGetPayload<S['include'][P]>>  :
        P extends 'notifications' ? Array < notificationGetPayload<S['include'][P]>>  :
        P extends 'outputs' ? Array < outputGetPayload<S['include'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['include'][P]>>  :
        P extends 'collections' ? Array < collectionGetPayload<S['include'][P]>>  :
        P extends 'subtitles' ? Array < subtitleGetPayload<S['include'][P]>>  :
        P extends 'permission' ? Array < permissionGetPayload<S['include'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['include'][P]> :  never
  } 
    : S extends { select: any } & (userArgs | userFindManyArgs)
      ? {
    [P in TruthyKeys<S['select']>]:
        P extends 'credential' ? credentialGetPayload<S['select'][P]> | null :
        P extends 'profile' ? profileGetPayload<S['select'][P]> | null :
        P extends 'settings' ? settingsGetPayload<S['select'][P]> | null :
        P extends 'accounts' ? Array < accountGetPayload<S['select'][P]>>  :
        P extends 'drives' ? Array < driveGetPayload<S['select'][P]>>  :
        P extends 'tv' ? Array < tvGetPayload<S['select'][P]>>  :
        P extends 'seasons' ? Array < seasonGetPayload<S['select'][P]>>  :
        P extends 'episode' ? Array < episodeGetPayload<S['select'][P]>>  :
        P extends 'movie' ? Array < movieGetPayload<S['select'][P]>>  :
        P extends 'parsed_tvs' ? Array < parsed_tvGetPayload<S['select'][P]>>  :
        P extends 'parsed_seasons' ? Array < parsed_seasonGetPayload<S['select'][P]>>  :
        P extends 'parsed_episodes' ? Array < parsed_episodeGetPayload<S['select'][P]>>  :
        P extends 'parsed_movies' ? Array < parsed_movieGetPayload<S['select'][P]>>  :
        P extends 'tv_need_complete' ? Array < incomplete_tvGetPayload<S['select'][P]>>  :
        P extends 'async_task' ? Array < async_taskGetPayload<S['select'][P]>>  :
        P extends 'files' ? Array < fileGetPayload<S['select'][P]>>  :
        P extends 'members' ? Array < memberGetPayload<S['select'][P]>>  :
        P extends 'shared_files' ? Array < shared_fileGetPayload<S['select'][P]>>  :
        P extends 'shared_file_in_progress' ? Array < shared_file_in_progressGetPayload<S['select'][P]>>  :
        P extends 'tmp_files' ? Array < tmp_fileGetPayload<S['select'][P]>>  :
        P extends 'sync_tasks' ? Array < bind_for_parsed_tvGetPayload<S['select'][P]>>  :
        P extends 'notifications' ? Array < notificationGetPayload<S['select'][P]>>  :
        P extends 'outputs' ? Array < outputGetPayload<S['select'][P]>>  :
        P extends 'reports' ? Array < reportGetPayload<S['select'][P]>>  :
        P extends 'collections' ? Array < collectionGetPayload<S['select'][P]>>  :
        P extends 'subtitles' ? Array < subtitleGetPayload<S['select'][P]>>  :
        P extends 'permission' ? Array < permissionGetPayload<S['select'][P]>>  :
        P extends '_count' ? UserCountOutputTypeGetPayload<S['select'][P]> :  P extends keyof user ? user[P] : never
  } 
      : user


  type userCountArgs = 
    Omit<userFindManyArgs, 'select' | 'include'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface userDelegate<GlobalRejectSettings extends Prisma.RejectOnNotFound | Prisma.RejectPerOperation | false | undefined> {

    /**
     * Find zero or one User that matches the filter.
     * @param {userFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends userFindUniqueArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args: SelectSubset<T, userFindUniqueArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findUnique', 'user'> extends True ? Prisma__userClient<userGetPayload<T>> : Prisma__userClient<userGetPayload<T> | null, null>

    /**
     * Find one User that matches the filter or throw an error  with `error.code='P2025'` 
     *     if no matches were found.
     * @param {userFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends userFindUniqueOrThrowArgs>(
      args?: SelectSubset<T, userFindUniqueOrThrowArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends userFindFirstArgs,  LocalRejectSettings = T["rejectOnNotFound"] extends RejectOnNotFound ? T['rejectOnNotFound'] : undefined>(
      args?: SelectSubset<T, userFindFirstArgs>
    ): HasReject<GlobalRejectSettings, LocalRejectSettings, 'findFirst', 'user'> extends True ? Prisma__userClient<userGetPayload<T>> : Prisma__userClient<userGetPayload<T> | null, null>

    /**
     * Find the first User that matches the filter or
     * throw `NotFoundError` if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends userFindFirstOrThrowArgs>(
      args?: SelectSubset<T, userFindFirstOrThrowArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userFindManyArgs=} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends userFindManyArgs>(
      args?: SelectSubset<T, userFindManyArgs>
    ): Prisma.PrismaPromise<Array<userGetPayload<T>>>

    /**
     * Create a User.
     * @param {userCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends userCreateArgs>(
      args: SelectSubset<T, userCreateArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Delete a User.
     * @param {userDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends userDeleteArgs>(
      args: SelectSubset<T, userDeleteArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Update one User.
     * @param {userUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends userUpdateArgs>(
      args: SelectSubset<T, userUpdateArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Delete zero or more Users.
     * @param {userDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends userDeleteManyArgs>(
      args?: SelectSubset<T, userDeleteManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends userUpdateManyArgs>(
      args: SelectSubset<T, userUpdateManyArgs>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {userUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends userUpsertArgs>(
      args: SelectSubset<T, userUpsertArgs>
    ): Prisma__userClient<userGetPayload<T>>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {userCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends userCountArgs>(
      args?: Subset<T, userCountArgs>,
    ): Prisma.PrismaPromise<
      T extends _Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends TupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>

  }

  /**
   * The delegate class that acts as a "Promise-like" for user.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export class Prisma__userClient<T, Null = never> implements Prisma.PrismaPromise<T> {
    private readonly _dmmf;
    private readonly _queryType;
    private readonly _rootField;
    private readonly _clientMethod;
    private readonly _args;
    private readonly _dataPath;
    private readonly _errorFormat;
    private readonly _measurePerformance?;
    private _isList;
    private _callsite;
    private _requestPromise?;
    readonly [Symbol.toStringTag]: 'PrismaPromise';
    constructor(_dmmf: runtime.DMMFClass, _queryType: 'query' | 'mutation', _rootField: string, _clientMethod: string, _args: any, _dataPath: string[], _errorFormat: ErrorFormat, _measurePerformance?: boolean | undefined, _isList?: boolean);

    credential<T extends credentialArgs= {}>(args?: Subset<T, credentialArgs>): Prisma__credentialClient<credentialGetPayload<T> | Null>;

    profile<T extends profileArgs= {}>(args?: Subset<T, profileArgs>): Prisma__profileClient<profileGetPayload<T> | Null>;

    settings<T extends settingsArgs= {}>(args?: Subset<T, settingsArgs>): Prisma__settingsClient<settingsGetPayload<T> | Null>;

    accounts<T extends user$accountsArgs= {}>(args?: Subset<T, user$accountsArgs>): Prisma.PrismaPromise<Array<accountGetPayload<T>>| Null>;

    drives<T extends user$drivesArgs= {}>(args?: Subset<T, user$drivesArgs>): Prisma.PrismaPromise<Array<driveGetPayload<T>>| Null>;

    tv<T extends user$tvArgs= {}>(args?: Subset<T, user$tvArgs>): Prisma.PrismaPromise<Array<tvGetPayload<T>>| Null>;

    seasons<T extends user$seasonsArgs= {}>(args?: Subset<T, user$seasonsArgs>): Prisma.PrismaPromise<Array<seasonGetPayload<T>>| Null>;

    episode<T extends user$episodeArgs= {}>(args?: Subset<T, user$episodeArgs>): Prisma.PrismaPromise<Array<episodeGetPayload<T>>| Null>;

    movie<T extends user$movieArgs= {}>(args?: Subset<T, user$movieArgs>): Prisma.PrismaPromise<Array<movieGetPayload<T>>| Null>;

    parsed_tvs<T extends user$parsed_tvsArgs= {}>(args?: Subset<T, user$parsed_tvsArgs>): Prisma.PrismaPromise<Array<parsed_tvGetPayload<T>>| Null>;

    parsed_seasons<T extends user$parsed_seasonsArgs= {}>(args?: Subset<T, user$parsed_seasonsArgs>): Prisma.PrismaPromise<Array<parsed_seasonGetPayload<T>>| Null>;

    parsed_episodes<T extends user$parsed_episodesArgs= {}>(args?: Subset<T, user$parsed_episodesArgs>): Prisma.PrismaPromise<Array<parsed_episodeGetPayload<T>>| Null>;

    parsed_movies<T extends user$parsed_moviesArgs= {}>(args?: Subset<T, user$parsed_moviesArgs>): Prisma.PrismaPromise<Array<parsed_movieGetPayload<T>>| Null>;

    tv_need_complete<T extends user$tv_need_completeArgs= {}>(args?: Subset<T, user$tv_need_completeArgs>): Prisma.PrismaPromise<Array<incomplete_tvGetPayload<T>>| Null>;

    async_task<T extends user$async_taskArgs= {}>(args?: Subset<T, user$async_taskArgs>): Prisma.PrismaPromise<Array<async_taskGetPayload<T>>| Null>;

    files<T extends user$filesArgs= {}>(args?: Subset<T, user$filesArgs>): Prisma.PrismaPromise<Array<fileGetPayload<T>>| Null>;

    members<T extends user$membersArgs= {}>(args?: Subset<T, user$membersArgs>): Prisma.PrismaPromise<Array<memberGetPayload<T>>| Null>;

    shared_files<T extends user$shared_filesArgs= {}>(args?: Subset<T, user$shared_filesArgs>): Prisma.PrismaPromise<Array<shared_fileGetPayload<T>>| Null>;

    shared_file_in_progress<T extends user$shared_file_in_progressArgs= {}>(args?: Subset<T, user$shared_file_in_progressArgs>): Prisma.PrismaPromise<Array<shared_file_in_progressGetPayload<T>>| Null>;

    tmp_files<T extends user$tmp_filesArgs= {}>(args?: Subset<T, user$tmp_filesArgs>): Prisma.PrismaPromise<Array<tmp_fileGetPayload<T>>| Null>;

    sync_tasks<T extends user$sync_tasksArgs= {}>(args?: Subset<T, user$sync_tasksArgs>): Prisma.PrismaPromise<Array<bind_for_parsed_tvGetPayload<T>>| Null>;

    notifications<T extends user$notificationsArgs= {}>(args?: Subset<T, user$notificationsArgs>): Prisma.PrismaPromise<Array<notificationGetPayload<T>>| Null>;

    outputs<T extends user$outputsArgs= {}>(args?: Subset<T, user$outputsArgs>): Prisma.PrismaPromise<Array<outputGetPayload<T>>| Null>;

    reports<T extends user$reportsArgs= {}>(args?: Subset<T, user$reportsArgs>): Prisma.PrismaPromise<Array<reportGetPayload<T>>| Null>;

    collections<T extends user$collectionsArgs= {}>(args?: Subset<T, user$collectionsArgs>): Prisma.PrismaPromise<Array<collectionGetPayload<T>>| Null>;

    subtitles<T extends user$subtitlesArgs= {}>(args?: Subset<T, user$subtitlesArgs>): Prisma.PrismaPromise<Array<subtitleGetPayload<T>>| Null>;

    permission<T extends user$permissionArgs= {}>(args?: Subset<T, user$permissionArgs>): Prisma.PrismaPromise<Array<permissionGetPayload<T>>| Null>;

    private get _document();
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): Promise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): Promise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): Promise<T>;
  }



  // Custom InputTypes

  /**
   * user base type for findUnique actions
   */
  export type userFindUniqueArgsBase = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }

  /**
   * user findUnique
   */
  export interface userFindUniqueArgs extends userFindUniqueArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findUniqueOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user findUniqueOrThrow
   */
  export type userFindUniqueOrThrowArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter, which user to fetch.
     */
    where: userWhereUniqueInput
  }


  /**
   * user base type for findFirst actions
   */
  export type userFindFirstArgsBase = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }

  /**
   * user findFirst
   */
  export interface userFindFirstArgs extends userFindFirstArgsBase {
   /**
    * Throw an Error if query returns no results
    * @deprecated since 4.0.0: use `findFirstOrThrow` method instead
    */
    rejectOnNotFound?: RejectOnNotFound
  }
      

  /**
   * user findFirstOrThrow
   */
  export type userFindFirstOrThrowArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter, which user to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user findMany
   */
  export type userFindManyArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter, which users to fetch.
     */
    where?: userWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: Enumerable<userOrderByWithRelationInput>
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: userWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: Enumerable<UserScalarFieldEnum>
  }


  /**
   * user create
   */
  export type userCreateArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * The data needed to create a user.
     */
    data: XOR<userCreateInput, userUncheckedCreateInput>
  }


  /**
   * user update
   */
  export type userUpdateArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * The data needed to update a user.
     */
    data: XOR<userUpdateInput, userUncheckedUpdateInput>
    /**
     * Choose, which user to update.
     */
    where: userWhereUniqueInput
  }


  /**
   * user updateMany
   */
  export type userUpdateManyArgs = {
    /**
     * The data used to update users.
     */
    data: XOR<userUpdateManyMutationInput, userUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: userWhereInput
  }


  /**
   * user upsert
   */
  export type userUpsertArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * The filter to search for the user to update in case it exists.
     */
    where: userWhereUniqueInput
    /**
     * In case the user found by the `where` argument doesn't exist, create a new user with this data.
     */
    create: XOR<userCreateInput, userUncheckedCreateInput>
    /**
     * In case the user was found with the provided `where` argument, update it with this data.
     */
    update: XOR<userUpdateInput, userUncheckedUpdateInput>
  }


  /**
   * user delete
   */
  export type userDeleteArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
    /**
     * Filter which user to delete.
     */
    where: userWhereUniqueInput
  }


  /**
   * user deleteMany
   */
  export type userDeleteManyArgs = {
    /**
     * Filter which users to delete
     */
    where?: userWhereInput
  }


  /**
   * user.accounts
   */
  export type user$accountsArgs = {
    /**
     * Select specific fields to fetch from the account
     */
    select?: accountSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: accountInclude | null
    where?: accountWhereInput
    orderBy?: Enumerable<accountOrderByWithRelationInput>
    cursor?: accountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<AccountScalarFieldEnum>
  }


  /**
   * user.drives
   */
  export type user$drivesArgs = {
    /**
     * Select specific fields to fetch from the drive
     */
    select?: driveSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: driveInclude | null
    where?: driveWhereInput
    orderBy?: Enumerable<driveOrderByWithRelationInput>
    cursor?: driveWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<DriveScalarFieldEnum>
  }


  /**
   * user.tv
   */
  export type user$tvArgs = {
    /**
     * Select specific fields to fetch from the tv
     */
    select?: tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tvInclude | null
    where?: tvWhereInput
    orderBy?: Enumerable<tvOrderByWithRelationInput>
    cursor?: tvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<TvScalarFieldEnum>
  }


  /**
   * user.seasons
   */
  export type user$seasonsArgs = {
    /**
     * Select specific fields to fetch from the season
     */
    select?: seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: seasonInclude | null
    where?: seasonWhereInput
    orderBy?: Enumerable<seasonOrderByWithRelationInput>
    cursor?: seasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SeasonScalarFieldEnum>
  }


  /**
   * user.episode
   */
  export type user$episodeArgs = {
    /**
     * Select specific fields to fetch from the episode
     */
    select?: episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: episodeInclude | null
    where?: episodeWhereInput
    orderBy?: Enumerable<episodeOrderByWithRelationInput>
    cursor?: episodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<EpisodeScalarFieldEnum>
  }


  /**
   * user.movie
   */
  export type user$movieArgs = {
    /**
     * Select specific fields to fetch from the movie
     */
    select?: movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: movieInclude | null
    where?: movieWhereInput
    orderBy?: Enumerable<movieOrderByWithRelationInput>
    cursor?: movieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MovieScalarFieldEnum>
  }


  /**
   * user.parsed_tvs
   */
  export type user$parsed_tvsArgs = {
    /**
     * Select specific fields to fetch from the parsed_tv
     */
    select?: parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_tvInclude | null
    where?: parsed_tvWhereInput
    orderBy?: Enumerable<parsed_tvOrderByWithRelationInput>
    cursor?: parsed_tvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_tvScalarFieldEnum>
  }


  /**
   * user.parsed_seasons
   */
  export type user$parsed_seasonsArgs = {
    /**
     * Select specific fields to fetch from the parsed_season
     */
    select?: parsed_seasonSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_seasonInclude | null
    where?: parsed_seasonWhereInput
    orderBy?: Enumerable<parsed_seasonOrderByWithRelationInput>
    cursor?: parsed_seasonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_seasonScalarFieldEnum>
  }


  /**
   * user.parsed_episodes
   */
  export type user$parsed_episodesArgs = {
    /**
     * Select specific fields to fetch from the parsed_episode
     */
    select?: parsed_episodeSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_episodeInclude | null
    where?: parsed_episodeWhereInput
    orderBy?: Enumerable<parsed_episodeOrderByWithRelationInput>
    cursor?: parsed_episodeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_episodeScalarFieldEnum>
  }


  /**
   * user.parsed_movies
   */
  export type user$parsed_moviesArgs = {
    /**
     * Select specific fields to fetch from the parsed_movie
     */
    select?: parsed_movieSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: parsed_movieInclude | null
    where?: parsed_movieWhereInput
    orderBy?: Enumerable<parsed_movieOrderByWithRelationInput>
    cursor?: parsed_movieWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Parsed_movieScalarFieldEnum>
  }


  /**
   * user.tv_need_complete
   */
  export type user$tv_need_completeArgs = {
    /**
     * Select specific fields to fetch from the incomplete_tv
     */
    select?: incomplete_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: incomplete_tvInclude | null
    where?: incomplete_tvWhereInput
    orderBy?: Enumerable<incomplete_tvOrderByWithRelationInput>
    cursor?: incomplete_tvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Incomplete_tvScalarFieldEnum>
  }


  /**
   * user.async_task
   */
  export type user$async_taskArgs = {
    /**
     * Select specific fields to fetch from the async_task
     */
    select?: async_taskSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: async_taskInclude | null
    where?: async_taskWhereInput
    orderBy?: Enumerable<async_taskOrderByWithRelationInput>
    cursor?: async_taskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Async_taskScalarFieldEnum>
  }


  /**
   * user.files
   */
  export type user$filesArgs = {
    /**
     * Select specific fields to fetch from the file
     */
    select?: fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: fileInclude | null
    where?: fileWhereInput
    orderBy?: Enumerable<fileOrderByWithRelationInput>
    cursor?: fileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<FileScalarFieldEnum>
  }


  /**
   * user.members
   */
  export type user$membersArgs = {
    /**
     * Select specific fields to fetch from the member
     */
    select?: memberSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: memberInclude | null
    where?: memberWhereInput
    orderBy?: Enumerable<memberOrderByWithRelationInput>
    cursor?: memberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<MemberScalarFieldEnum>
  }


  /**
   * user.shared_files
   */
  export type user$shared_filesArgs = {
    /**
     * Select specific fields to fetch from the shared_file
     */
    select?: shared_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_fileInclude | null
    where?: shared_fileWhereInput
    orderBy?: Enumerable<shared_fileOrderByWithRelationInput>
    cursor?: shared_fileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Shared_fileScalarFieldEnum>
  }


  /**
   * user.shared_file_in_progress
   */
  export type user$shared_file_in_progressArgs = {
    /**
     * Select specific fields to fetch from the shared_file_in_progress
     */
    select?: shared_file_in_progressSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: shared_file_in_progressInclude | null
    where?: shared_file_in_progressWhereInput
    orderBy?: Enumerable<shared_file_in_progressOrderByWithRelationInput>
    cursor?: shared_file_in_progressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Shared_file_in_progressScalarFieldEnum>
  }


  /**
   * user.tmp_files
   */
  export type user$tmp_filesArgs = {
    /**
     * Select specific fields to fetch from the tmp_file
     */
    select?: tmp_fileSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: tmp_fileInclude | null
    where?: tmp_fileWhereInput
    orderBy?: Enumerable<tmp_fileOrderByWithRelationInput>
    cursor?: tmp_fileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Tmp_fileScalarFieldEnum>
  }


  /**
   * user.sync_tasks
   */
  export type user$sync_tasksArgs = {
    /**
     * Select specific fields to fetch from the bind_for_parsed_tv
     */
    select?: bind_for_parsed_tvSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: bind_for_parsed_tvInclude | null
    where?: bind_for_parsed_tvWhereInput
    orderBy?: Enumerable<bind_for_parsed_tvOrderByWithRelationInput>
    cursor?: bind_for_parsed_tvWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<Bind_for_parsed_tvScalarFieldEnum>
  }


  /**
   * user.notifications
   */
  export type user$notificationsArgs = {
    /**
     * Select specific fields to fetch from the notification
     */
    select?: notificationSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: notificationInclude | null
    where?: notificationWhereInput
    orderBy?: Enumerable<notificationOrderByWithRelationInput>
    cursor?: notificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<NotificationScalarFieldEnum>
  }


  /**
   * user.outputs
   */
  export type user$outputsArgs = {
    /**
     * Select specific fields to fetch from the output
     */
    select?: outputSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: outputInclude | null
    where?: outputWhereInput
    orderBy?: Enumerable<outputOrderByWithRelationInput>
    cursor?: outputWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<OutputScalarFieldEnum>
  }


  /**
   * user.reports
   */
  export type user$reportsArgs = {
    /**
     * Select specific fields to fetch from the report
     */
    select?: reportSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: reportInclude | null
    where?: reportWhereInput
    orderBy?: Enumerable<reportOrderByWithRelationInput>
    cursor?: reportWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<ReportScalarFieldEnum>
  }


  /**
   * user.collections
   */
  export type user$collectionsArgs = {
    /**
     * Select specific fields to fetch from the collection
     */
    select?: collectionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: collectionInclude | null
    where?: collectionWhereInput
    orderBy?: Enumerable<collectionOrderByWithRelationInput>
    cursor?: collectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<CollectionScalarFieldEnum>
  }


  /**
   * user.subtitles
   */
  export type user$subtitlesArgs = {
    /**
     * Select specific fields to fetch from the subtitle
     */
    select?: subtitleSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: subtitleInclude | null
    where?: subtitleWhereInput
    orderBy?: Enumerable<subtitleOrderByWithRelationInput>
    cursor?: subtitleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<SubtitleScalarFieldEnum>
  }


  /**
   * user.permission
   */
  export type user$permissionArgs = {
    /**
     * Select specific fields to fetch from the permission
     */
    select?: permissionSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: permissionInclude | null
    where?: permissionWhereInput
    orderBy?: Enumerable<permissionOrderByWithRelationInput>
    cursor?: permissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Enumerable<PermissionScalarFieldEnum>
  }


  /**
   * user without action
   */
  export type userArgs = {
    /**
     * Select specific fields to fetch from the user
     */
    select?: userSelect | null
    /**
     * Choose, which related nodes to fetch as well.
     */
    include?: userInclude | null
  }



  /**
   * Enums
   */

  // Based on
  // https://github.com/microsoft/TypeScript/issues/3192#issuecomment-261720275

  export const AccountScalarFieldEnum: {
    id: 'id',
    type: 'type',
    provider: 'provider',
    provider_account_id: 'provider_account_id',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state',
    user_id: 'user_id'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const Async_taskScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    unique_id: 'unique_id',
    type: 'type',
    desc: 'desc',
    status: 'status',
    need_stop: 'need_stop',
    error: 'error',
    output_id: 'output_id',
    user_id: 'user_id'
  };

  export type Async_taskScalarFieldEnum = (typeof Async_taskScalarFieldEnum)[keyof typeof Async_taskScalarFieldEnum]


  export const Bind_for_parsed_tvScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    url: 'url',
    file_id: 'file_id',
    name: 'name',
    file_id_link_resource: 'file_id_link_resource',
    file_name_link_resource: 'file_name_link_resource',
    in_production: 'in_production',
    invalid: 'invalid',
    season_id: 'season_id',
    drive_id: 'drive_id',
    user_id: 'user_id'
  };

  export type Bind_for_parsed_tvScalarFieldEnum = (typeof Bind_for_parsed_tvScalarFieldEnum)[keyof typeof Bind_for_parsed_tvScalarFieldEnum]


  export const CollectionScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    title: 'title',
    desc: 'desc',
    type: 'type',
    rules: 'rules',
    sort: 'sort',
    styles: 'styles',
    user_id: 'user_id'
  };

  export type CollectionScalarFieldEnum = (typeof CollectionScalarFieldEnum)[keyof typeof CollectionScalarFieldEnum]


  export const CredentialScalarFieldEnum: {
    id: 'id',
    password: 'password',
    salt: 'salt',
    verified: 'verified',
    email: 'email',
    user_id: 'user_id'
  };

  export type CredentialScalarFieldEnum = (typeof CredentialScalarFieldEnum)[keyof typeof CredentialScalarFieldEnum]


  export const DriveScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    unique_id: 'unique_id',
    type: 'type',
    name: 'name',
    remark: 'remark',
    avatar: 'avatar',
    profile: 'profile',
    total_size: 'total_size',
    used_size: 'used_size',
    invalid: 'invalid',
    latest_analysis: 'latest_analysis',
    root_folder_name: 'root_folder_name',
    root_folder_id: 'root_folder_id',
    drive_token_id: 'drive_token_id',
    user_id: 'user_id'
  };

  export type DriveScalarFieldEnum = (typeof DriveScalarFieldEnum)[keyof typeof DriveScalarFieldEnum]


  export const Drive_check_inScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    checked_at: 'checked_at',
    drive_id: 'drive_id'
  };

  export type Drive_check_inScalarFieldEnum = (typeof Drive_check_inScalarFieldEnum)[keyof typeof Drive_check_inScalarFieldEnum]


  export const Drive_tokenScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    data: 'data',
    expired_at: 'expired_at'
  };

  export type Drive_tokenScalarFieldEnum = (typeof Drive_tokenScalarFieldEnum)[keyof typeof Drive_tokenScalarFieldEnum]


  export const EpisodeScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    episode_text: 'episode_text',
    season_text: 'season_text',
    episode_number: 'episode_number',
    profile_id: 'profile_id',
    tv_id: 'tv_id',
    season_id: 'season_id',
    user_id: 'user_id'
  };

  export type EpisodeScalarFieldEnum = (typeof EpisodeScalarFieldEnum)[keyof typeof EpisodeScalarFieldEnum]


  export const Episode_profileScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    unique_id: 'unique_id',
    source: 'source',
    sources: 'sources',
    name: 'name',
    overview: 'overview',
    air_date: 'air_date',
    runtime: 'runtime',
    episode_number: 'episode_number',
    season_number: 'season_number'
  };

  export type Episode_profileScalarFieldEnum = (typeof Episode_profileScalarFieldEnum)[keyof typeof Episode_profileScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    file_id: 'file_id',
    name: 'name',
    parent_file_id: 'parent_file_id',
    parent_paths: 'parent_paths',
    type: 'type',
    size: 'size',
    drive_id: 'drive_id',
    user_id: 'user_id'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const Incomplete_tvScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    episode_count: 'episode_count',
    cur_count: 'cur_count',
    user_id: 'user_id'
  };

  export type Incomplete_tvScalarFieldEnum = (typeof Incomplete_tvScalarFieldEnum)[keyof typeof Incomplete_tvScalarFieldEnum]


  export const LogScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    title: 'title'
  };

  export type LogScalarFieldEnum = (typeof LogScalarFieldEnum)[keyof typeof LogScalarFieldEnum]


  export const MemberScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    email: 'email',
    name: 'name',
    avatar: 'avatar',
    remark: 'remark',
    permission: 'permission',
    disabled: 'disabled',
    delete: 'delete',
    inviter_id: 'inviter_id',
    user_id: 'user_id'
  };

  export type MemberScalarFieldEnum = (typeof MemberScalarFieldEnum)[keyof typeof MemberScalarFieldEnum]


  export const Member_notificationScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    unique_id: 'unique_id',
    content: 'content',
    type: 'type',
    status: 'status',
    is_delete: 'is_delete',
    member_id: 'member_id'
  };

  export type Member_notificationScalarFieldEnum = (typeof Member_notificationScalarFieldEnum)[keyof typeof Member_notificationScalarFieldEnum]


  export const Member_settingScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    data: 'data',
    member_id: 'member_id'
  };

  export type Member_settingScalarFieldEnum = (typeof Member_settingScalarFieldEnum)[keyof typeof Member_settingScalarFieldEnum]


  export const Member_tokenScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    token: 'token',
    used: 'used',
    expired_at: 'expired_at',
    member_id: 'member_id'
  };

  export type Member_tokenScalarFieldEnum = (typeof Member_tokenScalarFieldEnum)[keyof typeof Member_tokenScalarFieldEnum]


  export const MovieScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    profile_id: 'profile_id',
    user_id: 'user_id',
    collection_id: 'collection_id'
  };

  export type MovieScalarFieldEnum = (typeof MovieScalarFieldEnum)[keyof typeof MovieScalarFieldEnum]


  export const Movie_profileScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    unique_id: 'unique_id',
    source: 'source',
    sources: 'sources',
    name: 'name',
    original_name: 'original_name',
    overview: 'overview',
    poster_path: 'poster_path',
    backdrop_path: 'backdrop_path',
    air_date: 'air_date',
    original_language: 'original_language',
    popularity: 'popularity',
    vote_average: 'vote_average',
    vote_count: 'vote_count',
    origin_country: 'origin_country',
    genres: 'genres',
    runtime: 'runtime'
  };

  export type Movie_profileScalarFieldEnum = (typeof Movie_profileScalarFieldEnum)[keyof typeof Movie_profileScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    unique_id: 'unique_id',
    content: 'content',
    type: 'type',
    status: 'status',
    is_delete: 'is_delete',
    user_id: 'user_id'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const OutputScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    user_id: 'user_id'
  };

  export type OutputScalarFieldEnum = (typeof OutputScalarFieldEnum)[keyof typeof OutputScalarFieldEnum]


  export const Output_lineScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    content: 'content',
    output_id: 'output_id'
  };

  export type Output_lineScalarFieldEnum = (typeof Output_lineScalarFieldEnum)[keyof typeof Output_lineScalarFieldEnum]


  export const Parsed_episodeScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    episode_number: 'episode_number',
    season_number: 'season_number',
    name: 'name',
    file_id: 'file_id',
    file_name: 'file_name',
    parent_file_id: 'parent_file_id',
    parent_paths: 'parent_paths',
    type: 'type',
    size: 'size',
    can_search: 'can_search',
    episode_id: 'episode_id',
    parsed_tv_id: 'parsed_tv_id',
    parsed_season_id: 'parsed_season_id',
    drive_id: 'drive_id',
    user_id: 'user_id'
  };

  export type Parsed_episodeScalarFieldEnum = (typeof Parsed_episodeScalarFieldEnum)[keyof typeof Parsed_episodeScalarFieldEnum]


  export const Parsed_movieScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    name: 'name',
    original_name: 'original_name',
    correct_name: 'correct_name',
    file_id: 'file_id',
    file_name: 'file_name',
    parent_file_id: 'parent_file_id',
    parent_paths: 'parent_paths',
    type: 'type',
    size: 'size',
    can_search: 'can_search',
    movie_id: 'movie_id',
    drive_id: 'drive_id',
    user_id: 'user_id'
  };

  export type Parsed_movieScalarFieldEnum = (typeof Parsed_movieScalarFieldEnum)[keyof typeof Parsed_movieScalarFieldEnum]


  export const Parsed_seasonScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    season_number: 'season_number',
    file_id: 'file_id',
    file_name: 'file_name',
    can_search: 'can_search',
    correct_season_number: 'correct_season_number',
    season_id: 'season_id',
    parsed_tv_id: 'parsed_tv_id',
    drive_id: 'drive_id',
    user_id: 'user_id'
  };

  export type Parsed_seasonScalarFieldEnum = (typeof Parsed_seasonScalarFieldEnum)[keyof typeof Parsed_seasonScalarFieldEnum]


  export const Parsed_tvScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    name: 'name',
    original_name: 'original_name',
    file_id: 'file_id',
    file_name: 'file_name',
    can_search: 'can_search',
    correct_name: 'correct_name',
    tmdb_id: 'tmdb_id',
    tv_id: 'tv_id',
    drive_id: 'drive_id',
    user_id: 'user_id'
  };

  export type Parsed_tvScalarFieldEnum = (typeof Parsed_tvScalarFieldEnum)[keyof typeof Parsed_tvScalarFieldEnum]


  export const PermissionScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    desc: 'desc',
    code: 'code',
    user_id: 'user_id'
  };

  export type PermissionScalarFieldEnum = (typeof PermissionScalarFieldEnum)[keyof typeof PermissionScalarFieldEnum]


  export const Play_historyScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    duration: 'duration',
    current_time: 'current_time',
    thumbnail: 'thumbnail',
    file_id: 'file_id',
    tv_id: 'tv_id',
    season_id: 'season_id',
    episode_id: 'episode_id',
    movie_id: 'movie_id',
    member_id: 'member_id'
  };

  export type Play_historyScalarFieldEnum = (typeof Play_historyScalarFieldEnum)[keyof typeof Play_historyScalarFieldEnum]


  export const ProfileScalarFieldEnum: {
    id: 'id',
    nickname: 'nickname',
    avatar: 'avatar',
    user_id: 'user_id'
  };

  export type ProfileScalarFieldEnum = (typeof ProfileScalarFieldEnum)[keyof typeof ProfileScalarFieldEnum]


  export const ReportScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    type: 'type',
    data: 'data',
    answer: 'answer',
    tv_id: 'tv_id',
    season_id: 'season_id',
    episode_id: 'episode_id',
    movie_id: 'movie_id',
    member_id: 'member_id',
    user_id: 'user_id'
  };

  export type ReportScalarFieldEnum = (typeof ReportScalarFieldEnum)[keyof typeof ReportScalarFieldEnum]


  export const SeasonScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    season_text: 'season_text',
    season_number: 'season_number',
    profile_id: 'profile_id',
    collection_id: 'collection_id',
    tv_id: 'tv_id',
    user_id: 'user_id'
  };

  export type SeasonScalarFieldEnum = (typeof SeasonScalarFieldEnum)[keyof typeof SeasonScalarFieldEnum]


  export const Season_profileScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    unique_id: 'unique_id',
    source: 'source',
    sources: 'sources',
    name: 'name',
    overview: 'overview',
    poster_path: 'poster_path',
    season_number: 'season_number',
    air_date: 'air_date',
    episode_count: 'episode_count',
    vote_average: 'vote_average'
  };

  export type Season_profileScalarFieldEnum = (typeof Season_profileScalarFieldEnum)[keyof typeof Season_profileScalarFieldEnum]


  export const SettingsScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    detail: 'detail',
    user_id: 'user_id'
  };

  export type SettingsScalarFieldEnum = (typeof SettingsScalarFieldEnum)[keyof typeof SettingsScalarFieldEnum]


  export const Shared_fileScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    title: 'title',
    url: 'url',
    user_id: 'user_id'
  };

  export type Shared_fileScalarFieldEnum = (typeof Shared_fileScalarFieldEnum)[keyof typeof Shared_fileScalarFieldEnum]


  export const Shared_file_in_progressScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    url: 'url',
    file_id: 'file_id',
    name: 'name',
    drive_id: 'drive_id',
    user_id: 'user_id'
  };

  export type Shared_file_in_progressScalarFieldEnum = (typeof Shared_file_in_progressScalarFieldEnum)[keyof typeof Shared_file_in_progressScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const SubtitleScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    file_id: 'file_id',
    name: 'name',
    language: 'language',
    movie_id: 'movie_id',
    episode_id: 'episode_id',
    drive_id: 'drive_id',
    user_id: 'user_id'
  };

  export type SubtitleScalarFieldEnum = (typeof SubtitleScalarFieldEnum)[keyof typeof SubtitleScalarFieldEnum]


  export const Tmp_fileScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    name: 'name',
    type: 'type',
    parent_paths: 'parent_paths',
    drive_id: 'drive_id',
    user_id: 'user_id'
  };

  export type Tmp_fileScalarFieldEnum = (typeof Tmp_fileScalarFieldEnum)[keyof typeof Tmp_fileScalarFieldEnum]


  export const TransactionIsolationLevel: {
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const TvScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    hidden: 'hidden',
    profile_id: 'profile_id',
    collection_id: 'collection_id',
    user_id: 'user_id'
  };

  export type TvScalarFieldEnum = (typeof TvScalarFieldEnum)[keyof typeof TvScalarFieldEnum]


  export const Tv_profileScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    unique_id: 'unique_id',
    source: 'source',
    sources: 'sources',
    name: 'name',
    original_name: 'original_name',
    overview: 'overview',
    poster_path: 'poster_path',
    backdrop_path: 'backdrop_path',
    first_air_date: 'first_air_date',
    original_language: 'original_language',
    origin_country: 'origin_country',
    genres: 'genres',
    popularity: 'popularity',
    vote_average: 'vote_average',
    vote_count: 'vote_count',
    episode_count: 'episode_count',
    season_count: 'season_count',
    status: 'status',
    in_production: 'in_production'
  };

  export type Tv_profileScalarFieldEnum = (typeof Tv_profileScalarFieldEnum)[keyof typeof Tv_profileScalarFieldEnum]


  export const Tv_profile_quickScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated',
    name: 'name',
    tv_profile_id: 'tv_profile_id'
  };

  export type Tv_profile_quickScalarFieldEnum = (typeof Tv_profile_quickScalarFieldEnum)[keyof typeof Tv_profile_quickScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id: 'id',
    created: 'created',
    updated: 'updated'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  /**
   * Deep Input Types
   */


  export type driveWhereInput = {
    AND?: Enumerable<driveWhereInput>
    OR?: Enumerable<driveWhereInput>
    NOT?: Enumerable<driveWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    type?: IntNullableFilter | number | null
    name?: StringFilter | string
    remark?: StringNullableFilter | string | null
    avatar?: StringFilter | string
    profile?: StringFilter | string
    total_size?: FloatNullableFilter | number | null
    used_size?: FloatNullableFilter | number | null
    invalid?: IntNullableFilter | number | null
    latest_analysis?: DateTimeNullableFilter | Date | string | null
    root_folder_name?: StringNullableFilter | string | null
    root_folder_id?: StringNullableFilter | string | null
    drive_token_id?: StringFilter | string
    user_id?: StringFilter | string
    drive_token?: XOR<Drive_tokenRelationFilter, drive_tokenWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
    parsed_tvs?: Parsed_tvListRelationFilter
    parsed_seasons?: Parsed_seasonListRelationFilter
    parsed_episodes?: Parsed_episodeListRelationFilter
    drive_check_in?: Drive_check_inListRelationFilter
    files?: FileListRelationFilter
    tmp_files?: Tmp_fileListRelationFilter
    parsed_movies?: Parsed_movieListRelationFilter
    shared_file_in_progress?: Shared_file_in_progressListRelationFilter
    subtitles?: SubtitleListRelationFilter
    sync_tasks?: Bind_for_parsed_tvListRelationFilter
  }

  export type driveOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    remark?: SortOrder
    avatar?: SortOrder
    profile?: SortOrder
    total_size?: SortOrder
    used_size?: SortOrder
    invalid?: SortOrder
    latest_analysis?: SortOrder
    root_folder_name?: SortOrder
    root_folder_id?: SortOrder
    drive_token_id?: SortOrder
    user_id?: SortOrder
    drive_token?: drive_tokenOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    parsed_tvs?: parsed_tvOrderByRelationAggregateInput
    parsed_seasons?: parsed_seasonOrderByRelationAggregateInput
    parsed_episodes?: parsed_episodeOrderByRelationAggregateInput
    drive_check_in?: drive_check_inOrderByRelationAggregateInput
    files?: fileOrderByRelationAggregateInput
    tmp_files?: tmp_fileOrderByRelationAggregateInput
    parsed_movies?: parsed_movieOrderByRelationAggregateInput
    shared_file_in_progress?: shared_file_in_progressOrderByRelationAggregateInput
    subtitles?: subtitleOrderByRelationAggregateInput
    sync_tasks?: bind_for_parsed_tvOrderByRelationAggregateInput
  }

  export type driveWhereUniqueInput = {
    id?: string
    user_id_unique_id?: driveUser_idUnique_idCompoundUniqueInput
  }

  export type driveOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    remark?: SortOrder
    avatar?: SortOrder
    profile?: SortOrder
    total_size?: SortOrder
    used_size?: SortOrder
    invalid?: SortOrder
    latest_analysis?: SortOrder
    root_folder_name?: SortOrder
    root_folder_id?: SortOrder
    drive_token_id?: SortOrder
    user_id?: SortOrder
    _count?: driveCountOrderByAggregateInput
    _avg?: driveAvgOrderByAggregateInput
    _max?: driveMaxOrderByAggregateInput
    _min?: driveMinOrderByAggregateInput
    _sum?: driveSumOrderByAggregateInput
  }

  export type driveScalarWhereWithAggregatesInput = {
    AND?: Enumerable<driveScalarWhereWithAggregatesInput>
    OR?: Enumerable<driveScalarWhereWithAggregatesInput>
    NOT?: Enumerable<driveScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    unique_id?: StringWithAggregatesFilter | string
    type?: IntNullableWithAggregatesFilter | number | null
    name?: StringWithAggregatesFilter | string
    remark?: StringNullableWithAggregatesFilter | string | null
    avatar?: StringWithAggregatesFilter | string
    profile?: StringWithAggregatesFilter | string
    total_size?: FloatNullableWithAggregatesFilter | number | null
    used_size?: FloatNullableWithAggregatesFilter | number | null
    invalid?: IntNullableWithAggregatesFilter | number | null
    latest_analysis?: DateTimeNullableWithAggregatesFilter | Date | string | null
    root_folder_name?: StringNullableWithAggregatesFilter | string | null
    root_folder_id?: StringNullableWithAggregatesFilter | string | null
    drive_token_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type drive_tokenWhereInput = {
    AND?: Enumerable<drive_tokenWhereInput>
    OR?: Enumerable<drive_tokenWhereInput>
    NOT?: Enumerable<drive_tokenWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    data?: StringFilter | string
    expired_at?: FloatFilter | number
    drives?: DriveListRelationFilter
  }

  export type drive_tokenOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    expired_at?: SortOrder
    drives?: driveOrderByRelationAggregateInput
  }

  export type drive_tokenWhereUniqueInput = {
    id?: string
  }

  export type drive_tokenOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    expired_at?: SortOrder
    _count?: drive_tokenCountOrderByAggregateInput
    _avg?: drive_tokenAvgOrderByAggregateInput
    _max?: drive_tokenMaxOrderByAggregateInput
    _min?: drive_tokenMinOrderByAggregateInput
    _sum?: drive_tokenSumOrderByAggregateInput
  }

  export type drive_tokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<drive_tokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<drive_tokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<drive_tokenScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    data?: StringWithAggregatesFilter | string
    expired_at?: FloatWithAggregatesFilter | number
  }

  export type tv_profileWhereInput = {
    AND?: Enumerable<tv_profileWhereInput>
    OR?: Enumerable<tv_profileWhereInput>
    NOT?: Enumerable<tv_profileWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    source?: IntNullableFilter | number | null
    sources?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    original_name?: StringNullableFilter | string | null
    overview?: StringNullableFilter | string | null
    poster_path?: StringNullableFilter | string | null
    backdrop_path?: StringNullableFilter | string | null
    first_air_date?: StringNullableFilter | string | null
    original_language?: StringNullableFilter | string | null
    origin_country?: StringNullableFilter | string | null
    genres?: StringNullableFilter | string | null
    popularity?: FloatNullableFilter | number | null
    vote_average?: FloatNullableFilter | number | null
    vote_count?: FloatNullableFilter | number | null
    episode_count?: IntNullableFilter | number | null
    season_count?: IntNullableFilter | number | null
    status?: StringNullableFilter | string | null
    in_production?: IntNullableFilter | number | null
    tvs?: TvListRelationFilter
    snapshots?: Tv_profile_quickListRelationFilter
  }

  export type tv_profileOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    backdrop_path?: SortOrder
    first_air_date?: SortOrder
    original_language?: SortOrder
    origin_country?: SortOrder
    genres?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    episode_count?: SortOrder
    season_count?: SortOrder
    status?: SortOrder
    in_production?: SortOrder
    tvs?: tvOrderByRelationAggregateInput
    snapshots?: tv_profile_quickOrderByRelationAggregateInput
  }

  export type tv_profileWhereUniqueInput = {
    id?: string
  }

  export type tv_profileOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    backdrop_path?: SortOrder
    first_air_date?: SortOrder
    original_language?: SortOrder
    origin_country?: SortOrder
    genres?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    episode_count?: SortOrder
    season_count?: SortOrder
    status?: SortOrder
    in_production?: SortOrder
    _count?: tv_profileCountOrderByAggregateInput
    _avg?: tv_profileAvgOrderByAggregateInput
    _max?: tv_profileMaxOrderByAggregateInput
    _min?: tv_profileMinOrderByAggregateInput
    _sum?: tv_profileSumOrderByAggregateInput
  }

  export type tv_profileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tv_profileScalarWhereWithAggregatesInput>
    OR?: Enumerable<tv_profileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tv_profileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    unique_id?: StringWithAggregatesFilter | string
    source?: IntNullableWithAggregatesFilter | number | null
    sources?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    original_name?: StringNullableWithAggregatesFilter | string | null
    overview?: StringNullableWithAggregatesFilter | string | null
    poster_path?: StringNullableWithAggregatesFilter | string | null
    backdrop_path?: StringNullableWithAggregatesFilter | string | null
    first_air_date?: StringNullableWithAggregatesFilter | string | null
    original_language?: StringNullableWithAggregatesFilter | string | null
    origin_country?: StringNullableWithAggregatesFilter | string | null
    genres?: StringNullableWithAggregatesFilter | string | null
    popularity?: FloatNullableWithAggregatesFilter | number | null
    vote_average?: FloatNullableWithAggregatesFilter | number | null
    vote_count?: FloatNullableWithAggregatesFilter | number | null
    episode_count?: IntNullableWithAggregatesFilter | number | null
    season_count?: IntNullableWithAggregatesFilter | number | null
    status?: StringNullableWithAggregatesFilter | string | null
    in_production?: IntNullableWithAggregatesFilter | number | null
  }

  export type season_profileWhereInput = {
    AND?: Enumerable<season_profileWhereInput>
    OR?: Enumerable<season_profileWhereInput>
    NOT?: Enumerable<season_profileWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    source?: IntNullableFilter | number | null
    sources?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    overview?: StringNullableFilter | string | null
    poster_path?: StringNullableFilter | string | null
    season_number?: IntNullableFilter | number | null
    air_date?: StringNullableFilter | string | null
    episode_count?: IntNullableFilter | number | null
    vote_average?: FloatNullableFilter | number | null
    seasons?: SeasonListRelationFilter
  }

  export type season_profileOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    season_number?: SortOrder
    air_date?: SortOrder
    episode_count?: SortOrder
    vote_average?: SortOrder
    seasons?: seasonOrderByRelationAggregateInput
  }

  export type season_profileWhereUniqueInput = {
    id?: string
  }

  export type season_profileOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    season_number?: SortOrder
    air_date?: SortOrder
    episode_count?: SortOrder
    vote_average?: SortOrder
    _count?: season_profileCountOrderByAggregateInput
    _avg?: season_profileAvgOrderByAggregateInput
    _max?: season_profileMaxOrderByAggregateInput
    _min?: season_profileMinOrderByAggregateInput
    _sum?: season_profileSumOrderByAggregateInput
  }

  export type season_profileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<season_profileScalarWhereWithAggregatesInput>
    OR?: Enumerable<season_profileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<season_profileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    unique_id?: StringWithAggregatesFilter | string
    source?: IntNullableWithAggregatesFilter | number | null
    sources?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    overview?: StringNullableWithAggregatesFilter | string | null
    poster_path?: StringNullableWithAggregatesFilter | string | null
    season_number?: IntNullableWithAggregatesFilter | number | null
    air_date?: StringNullableWithAggregatesFilter | string | null
    episode_count?: IntNullableWithAggregatesFilter | number | null
    vote_average?: FloatNullableWithAggregatesFilter | number | null
  }

  export type episode_profileWhereInput = {
    AND?: Enumerable<episode_profileWhereInput>
    OR?: Enumerable<episode_profileWhereInput>
    NOT?: Enumerable<episode_profileWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    source?: IntNullableFilter | number | null
    sources?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    overview?: StringNullableFilter | string | null
    air_date?: StringNullableFilter | string | null
    runtime?: IntNullableFilter | number | null
    episode_number?: IntNullableFilter | number | null
    season_number?: IntNullableFilter | number | null
    episodes?: EpisodeListRelationFilter
  }

  export type episode_profileOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    air_date?: SortOrder
    runtime?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
    episodes?: episodeOrderByRelationAggregateInput
  }

  export type episode_profileWhereUniqueInput = {
    id?: string
  }

  export type episode_profileOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    air_date?: SortOrder
    runtime?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
    _count?: episode_profileCountOrderByAggregateInput
    _avg?: episode_profileAvgOrderByAggregateInput
    _max?: episode_profileMaxOrderByAggregateInput
    _min?: episode_profileMinOrderByAggregateInput
    _sum?: episode_profileSumOrderByAggregateInput
  }

  export type episode_profileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<episode_profileScalarWhereWithAggregatesInput>
    OR?: Enumerable<episode_profileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<episode_profileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    unique_id?: StringWithAggregatesFilter | string
    source?: IntNullableWithAggregatesFilter | number | null
    sources?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    overview?: StringNullableWithAggregatesFilter | string | null
    air_date?: StringNullableWithAggregatesFilter | string | null
    runtime?: IntNullableWithAggregatesFilter | number | null
    episode_number?: IntNullableWithAggregatesFilter | number | null
    season_number?: IntNullableWithAggregatesFilter | number | null
  }

  export type movie_profileWhereInput = {
    AND?: Enumerable<movie_profileWhereInput>
    OR?: Enumerable<movie_profileWhereInput>
    NOT?: Enumerable<movie_profileWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    source?: IntNullableFilter | number | null
    sources?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    original_name?: StringNullableFilter | string | null
    overview?: StringNullableFilter | string | null
    poster_path?: StringNullableFilter | string | null
    backdrop_path?: StringNullableFilter | string | null
    air_date?: StringNullableFilter | string | null
    original_language?: StringNullableFilter | string | null
    popularity?: FloatNullableFilter | number | null
    vote_average?: FloatNullableFilter | number | null
    vote_count?: FloatNullableFilter | number | null
    origin_country?: StringNullableFilter | string | null
    genres?: StringNullableFilter | string | null
    runtime?: IntNullableFilter | number | null
    movies?: MovieListRelationFilter
  }

  export type movie_profileOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    backdrop_path?: SortOrder
    air_date?: SortOrder
    original_language?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    origin_country?: SortOrder
    genres?: SortOrder
    runtime?: SortOrder
    movies?: movieOrderByRelationAggregateInput
  }

  export type movie_profileWhereUniqueInput = {
    id?: string
  }

  export type movie_profileOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    backdrop_path?: SortOrder
    air_date?: SortOrder
    original_language?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    origin_country?: SortOrder
    genres?: SortOrder
    runtime?: SortOrder
    _count?: movie_profileCountOrderByAggregateInput
    _avg?: movie_profileAvgOrderByAggregateInput
    _max?: movie_profileMaxOrderByAggregateInput
    _min?: movie_profileMinOrderByAggregateInput
    _sum?: movie_profileSumOrderByAggregateInput
  }

  export type movie_profileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<movie_profileScalarWhereWithAggregatesInput>
    OR?: Enumerable<movie_profileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<movie_profileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    unique_id?: StringWithAggregatesFilter | string
    source?: IntNullableWithAggregatesFilter | number | null
    sources?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    original_name?: StringNullableWithAggregatesFilter | string | null
    overview?: StringNullableWithAggregatesFilter | string | null
    poster_path?: StringNullableWithAggregatesFilter | string | null
    backdrop_path?: StringNullableWithAggregatesFilter | string | null
    air_date?: StringNullableWithAggregatesFilter | string | null
    original_language?: StringNullableWithAggregatesFilter | string | null
    popularity?: FloatNullableWithAggregatesFilter | number | null
    vote_average?: FloatNullableWithAggregatesFilter | number | null
    vote_count?: FloatNullableWithAggregatesFilter | number | null
    origin_country?: StringNullableWithAggregatesFilter | string | null
    genres?: StringNullableWithAggregatesFilter | string | null
    runtime?: IntNullableWithAggregatesFilter | number | null
  }

  export type subtitleWhereInput = {
    AND?: Enumerable<subtitleWhereInput>
    OR?: Enumerable<subtitleWhereInput>
    NOT?: Enumerable<subtitleWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    file_id?: StringFilter | string
    name?: StringFilter | string
    language?: StringFilter | string
    movie_id?: StringNullableFilter | string | null
    episode_id?: StringNullableFilter | string | null
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
    movie?: XOR<MovieRelationFilter, movieWhereInput> | null
    episode?: XOR<EpisodeRelationFilter, episodeWhereInput> | null
    drive?: XOR<DriveRelationFilter, driveWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type subtitleOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    language?: SortOrder
    movie_id?: SortOrder
    episode_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    movie?: movieOrderByWithRelationInput
    episode?: episodeOrderByWithRelationInput
    drive?: driveOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type subtitleWhereUniqueInput = {
    id?: string
  }

  export type subtitleOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    language?: SortOrder
    movie_id?: SortOrder
    episode_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    _count?: subtitleCountOrderByAggregateInput
    _max?: subtitleMaxOrderByAggregateInput
    _min?: subtitleMinOrderByAggregateInput
  }

  export type subtitleScalarWhereWithAggregatesInput = {
    AND?: Enumerable<subtitleScalarWhereWithAggregatesInput>
    OR?: Enumerable<subtitleScalarWhereWithAggregatesInput>
    NOT?: Enumerable<subtitleScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    file_id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    language?: StringWithAggregatesFilter | string
    movie_id?: StringNullableWithAggregatesFilter | string | null
    episode_id?: StringNullableWithAggregatesFilter | string | null
    drive_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type parsed_tvWhereInput = {
    AND?: Enumerable<parsed_tvWhereInput>
    OR?: Enumerable<parsed_tvWhereInput>
    NOT?: Enumerable<parsed_tvWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    name?: StringNullableFilter | string | null
    original_name?: StringNullableFilter | string | null
    file_id?: StringNullableFilter | string | null
    file_name?: StringNullableFilter | string | null
    can_search?: IntNullableFilter | number | null
    correct_name?: StringNullableFilter | string | null
    tmdb_id?: IntNullableFilter | number | null
    tv_id?: StringNullableFilter | string | null
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
    tv?: XOR<TvRelationFilter, tvWhereInput> | null
    drive?: XOR<DriveRelationFilter, driveWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
    parsed_episodes?: Parsed_episodeListRelationFilter
    parsed_seasons?: Parsed_seasonListRelationFilter
  }

  export type parsed_tvOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    can_search?: SortOrder
    correct_name?: SortOrder
    tmdb_id?: SortOrder
    tv_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    tv?: tvOrderByWithRelationInput
    drive?: driveOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    parsed_episodes?: parsed_episodeOrderByRelationAggregateInput
    parsed_seasons?: parsed_seasonOrderByRelationAggregateInput
  }

  export type parsed_tvWhereUniqueInput = {
    id?: string
  }

  export type parsed_tvOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    can_search?: SortOrder
    correct_name?: SortOrder
    tmdb_id?: SortOrder
    tv_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    _count?: parsed_tvCountOrderByAggregateInput
    _avg?: parsed_tvAvgOrderByAggregateInput
    _max?: parsed_tvMaxOrderByAggregateInput
    _min?: parsed_tvMinOrderByAggregateInput
    _sum?: parsed_tvSumOrderByAggregateInput
  }

  export type parsed_tvScalarWhereWithAggregatesInput = {
    AND?: Enumerable<parsed_tvScalarWhereWithAggregatesInput>
    OR?: Enumerable<parsed_tvScalarWhereWithAggregatesInput>
    NOT?: Enumerable<parsed_tvScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    name?: StringNullableWithAggregatesFilter | string | null
    original_name?: StringNullableWithAggregatesFilter | string | null
    file_id?: StringNullableWithAggregatesFilter | string | null
    file_name?: StringNullableWithAggregatesFilter | string | null
    can_search?: IntNullableWithAggregatesFilter | number | null
    correct_name?: StringNullableWithAggregatesFilter | string | null
    tmdb_id?: IntNullableWithAggregatesFilter | number | null
    tv_id?: StringNullableWithAggregatesFilter | string | null
    drive_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type parsed_seasonWhereInput = {
    AND?: Enumerable<parsed_seasonWhereInput>
    OR?: Enumerable<parsed_seasonWhereInput>
    NOT?: Enumerable<parsed_seasonWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    season_number?: StringFilter | string
    file_id?: StringNullableFilter | string | null
    file_name?: StringNullableFilter | string | null
    can_search?: IntNullableFilter | number | null
    correct_season_number?: StringNullableFilter | string | null
    season_id?: StringNullableFilter | string | null
    parsed_tv_id?: StringFilter | string
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
    season?: XOR<SeasonRelationFilter, seasonWhereInput> | null
    parsed_tv?: XOR<Parsed_tvRelationFilter, parsed_tvWhereInput>
    drive?: XOR<DriveRelationFilter, driveWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
    parsed_episodes?: Parsed_episodeListRelationFilter
  }

  export type parsed_seasonOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    season_number?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    can_search?: SortOrder
    correct_season_number?: SortOrder
    season_id?: SortOrder
    parsed_tv_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    season?: seasonOrderByWithRelationInput
    parsed_tv?: parsed_tvOrderByWithRelationInput
    drive?: driveOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    parsed_episodes?: parsed_episodeOrderByRelationAggregateInput
  }

  export type parsed_seasonWhereUniqueInput = {
    id?: string
  }

  export type parsed_seasonOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    season_number?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    can_search?: SortOrder
    correct_season_number?: SortOrder
    season_id?: SortOrder
    parsed_tv_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    _count?: parsed_seasonCountOrderByAggregateInput
    _avg?: parsed_seasonAvgOrderByAggregateInput
    _max?: parsed_seasonMaxOrderByAggregateInput
    _min?: parsed_seasonMinOrderByAggregateInput
    _sum?: parsed_seasonSumOrderByAggregateInput
  }

  export type parsed_seasonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<parsed_seasonScalarWhereWithAggregatesInput>
    OR?: Enumerable<parsed_seasonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<parsed_seasonScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    season_number?: StringWithAggregatesFilter | string
    file_id?: StringNullableWithAggregatesFilter | string | null
    file_name?: StringNullableWithAggregatesFilter | string | null
    can_search?: IntNullableWithAggregatesFilter | number | null
    correct_season_number?: StringNullableWithAggregatesFilter | string | null
    season_id?: StringNullableWithAggregatesFilter | string | null
    parsed_tv_id?: StringWithAggregatesFilter | string
    drive_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type parsed_episodeWhereInput = {
    AND?: Enumerable<parsed_episodeWhereInput>
    OR?: Enumerable<parsed_episodeWhereInput>
    NOT?: Enumerable<parsed_episodeWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    episode_number?: StringFilter | string
    season_number?: StringFilter | string
    name?: StringFilter | string
    file_id?: StringFilter | string
    file_name?: StringFilter | string
    parent_file_id?: StringFilter | string
    parent_paths?: StringFilter | string
    type?: IntFilter | number
    size?: FloatNullableFilter | number | null
    can_search?: IntNullableFilter | number | null
    episode_id?: StringNullableFilter | string | null
    parsed_tv_id?: StringFilter | string
    parsed_season_id?: StringFilter | string
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
    episode?: XOR<EpisodeRelationFilter, episodeWhereInput> | null
    parsed_tv?: XOR<Parsed_tvRelationFilter, parsed_tvWhereInput>
    parsed_season?: XOR<Parsed_seasonRelationFilter, parsed_seasonWhereInput>
    drive?: XOR<DriveRelationFilter, driveWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type parsed_episodeOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
    name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
    episode_id?: SortOrder
    parsed_tv_id?: SortOrder
    parsed_season_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    episode?: episodeOrderByWithRelationInput
    parsed_tv?: parsed_tvOrderByWithRelationInput
    parsed_season?: parsed_seasonOrderByWithRelationInput
    drive?: driveOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type parsed_episodeWhereUniqueInput = {
    id?: string
  }

  export type parsed_episodeOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
    name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
    episode_id?: SortOrder
    parsed_tv_id?: SortOrder
    parsed_season_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    _count?: parsed_episodeCountOrderByAggregateInput
    _avg?: parsed_episodeAvgOrderByAggregateInput
    _max?: parsed_episodeMaxOrderByAggregateInput
    _min?: parsed_episodeMinOrderByAggregateInput
    _sum?: parsed_episodeSumOrderByAggregateInput
  }

  export type parsed_episodeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<parsed_episodeScalarWhereWithAggregatesInput>
    OR?: Enumerable<parsed_episodeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<parsed_episodeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    episode_number?: StringWithAggregatesFilter | string
    season_number?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    file_id?: StringWithAggregatesFilter | string
    file_name?: StringWithAggregatesFilter | string
    parent_file_id?: StringWithAggregatesFilter | string
    parent_paths?: StringWithAggregatesFilter | string
    type?: IntWithAggregatesFilter | number
    size?: FloatNullableWithAggregatesFilter | number | null
    can_search?: IntNullableWithAggregatesFilter | number | null
    episode_id?: StringNullableWithAggregatesFilter | string | null
    parsed_tv_id?: StringWithAggregatesFilter | string
    parsed_season_id?: StringWithAggregatesFilter | string
    drive_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type parsed_movieWhereInput = {
    AND?: Enumerable<parsed_movieWhereInput>
    OR?: Enumerable<parsed_movieWhereInput>
    NOT?: Enumerable<parsed_movieWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    name?: StringFilter | string
    original_name?: StringNullableFilter | string | null
    correct_name?: StringNullableFilter | string | null
    file_id?: StringFilter | string
    file_name?: StringFilter | string
    parent_file_id?: StringFilter | string
    parent_paths?: StringFilter | string
    type?: IntFilter | number
    size?: FloatNullableFilter | number | null
    can_search?: IntNullableFilter | number | null
    movie_id?: StringNullableFilter | string | null
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
    movie?: XOR<MovieRelationFilter, movieWhereInput> | null
    drive?: XOR<DriveRelationFilter, driveWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type parsed_movieOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    correct_name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
    movie_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    movie?: movieOrderByWithRelationInput
    drive?: driveOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type parsed_movieWhereUniqueInput = {
    id?: string
  }

  export type parsed_movieOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    correct_name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
    movie_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    _count?: parsed_movieCountOrderByAggregateInput
    _avg?: parsed_movieAvgOrderByAggregateInput
    _max?: parsed_movieMaxOrderByAggregateInput
    _min?: parsed_movieMinOrderByAggregateInput
    _sum?: parsed_movieSumOrderByAggregateInput
  }

  export type parsed_movieScalarWhereWithAggregatesInput = {
    AND?: Enumerable<parsed_movieScalarWhereWithAggregatesInput>
    OR?: Enumerable<parsed_movieScalarWhereWithAggregatesInput>
    NOT?: Enumerable<parsed_movieScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    original_name?: StringNullableWithAggregatesFilter | string | null
    correct_name?: StringNullableWithAggregatesFilter | string | null
    file_id?: StringWithAggregatesFilter | string
    file_name?: StringWithAggregatesFilter | string
    parent_file_id?: StringWithAggregatesFilter | string
    parent_paths?: StringWithAggregatesFilter | string
    type?: IntWithAggregatesFilter | number
    size?: FloatNullableWithAggregatesFilter | number | null
    can_search?: IntNullableWithAggregatesFilter | number | null
    movie_id?: StringNullableWithAggregatesFilter | string | null
    drive_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type tvWhereInput = {
    AND?: Enumerable<tvWhereInput>
    OR?: Enumerable<tvWhereInput>
    NOT?: Enumerable<tvWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    hidden?: IntNullableFilter | number | null
    profile_id?: StringFilter | string
    collection_id?: StringNullableFilter | string | null
    user_id?: StringFilter | string
    profile?: XOR<Tv_profileRelationFilter, tv_profileWhereInput>
    collection?: XOR<CollectionRelationFilter, collectionWhereInput> | null
    user?: XOR<UserRelationFilter, userWhereInput>
    seasons?: SeasonListRelationFilter
    episodes?: EpisodeListRelationFilter
    play_histories?: Play_historyListRelationFilter
    parsed_tvs?: Parsed_tvListRelationFilter
    reports?: ReportListRelationFilter
  }

  export type tvOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    hidden?: SortOrder
    profile_id?: SortOrder
    collection_id?: SortOrder
    user_id?: SortOrder
    profile?: tv_profileOrderByWithRelationInput
    collection?: collectionOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    seasons?: seasonOrderByRelationAggregateInput
    episodes?: episodeOrderByRelationAggregateInput
    play_histories?: play_historyOrderByRelationAggregateInput
    parsed_tvs?: parsed_tvOrderByRelationAggregateInput
    reports?: reportOrderByRelationAggregateInput
  }

  export type tvWhereUniqueInput = {
    id?: string
    user_id_profile_id?: tvUser_idProfile_idCompoundUniqueInput
  }

  export type tvOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    hidden?: SortOrder
    profile_id?: SortOrder
    collection_id?: SortOrder
    user_id?: SortOrder
    _count?: tvCountOrderByAggregateInput
    _avg?: tvAvgOrderByAggregateInput
    _max?: tvMaxOrderByAggregateInput
    _min?: tvMinOrderByAggregateInput
    _sum?: tvSumOrderByAggregateInput
  }

  export type tvScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tvScalarWhereWithAggregatesInput>
    OR?: Enumerable<tvScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tvScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    hidden?: IntNullableWithAggregatesFilter | number | null
    profile_id?: StringWithAggregatesFilter | string
    collection_id?: StringNullableWithAggregatesFilter | string | null
    user_id?: StringWithAggregatesFilter | string
  }

  export type seasonWhereInput = {
    AND?: Enumerable<seasonWhereInput>
    OR?: Enumerable<seasonWhereInput>
    NOT?: Enumerable<seasonWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    season_text?: StringFilter | string
    season_number?: IntFilter | number
    profile_id?: StringFilter | string
    collection_id?: StringNullableFilter | string | null
    tv_id?: StringFilter | string
    user_id?: StringFilter | string
    profile?: XOR<Season_profileRelationFilter, season_profileWhereInput>
    collection?: XOR<CollectionRelationFilter, collectionWhereInput> | null
    tv?: XOR<TvRelationFilter, tvWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
    parsed_season?: Parsed_seasonListRelationFilter
    play_histories?: Play_historyListRelationFilter
    episodes?: EpisodeListRelationFilter
    reports?: ReportListRelationFilter
    sync_tasks?: Bind_for_parsed_tvListRelationFilter
  }

  export type seasonOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    season_text?: SortOrder
    season_number?: SortOrder
    profile_id?: SortOrder
    collection_id?: SortOrder
    tv_id?: SortOrder
    user_id?: SortOrder
    profile?: season_profileOrderByWithRelationInput
    collection?: collectionOrderByWithRelationInput
    tv?: tvOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    parsed_season?: parsed_seasonOrderByRelationAggregateInput
    play_histories?: play_historyOrderByRelationAggregateInput
    episodes?: episodeOrderByRelationAggregateInput
    reports?: reportOrderByRelationAggregateInput
    sync_tasks?: bind_for_parsed_tvOrderByRelationAggregateInput
  }

  export type seasonWhereUniqueInput = {
    id?: string
    user_id_profile_id?: seasonUser_idProfile_idCompoundUniqueInput
  }

  export type seasonOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    season_text?: SortOrder
    season_number?: SortOrder
    profile_id?: SortOrder
    collection_id?: SortOrder
    tv_id?: SortOrder
    user_id?: SortOrder
    _count?: seasonCountOrderByAggregateInput
    _avg?: seasonAvgOrderByAggregateInput
    _max?: seasonMaxOrderByAggregateInput
    _min?: seasonMinOrderByAggregateInput
    _sum?: seasonSumOrderByAggregateInput
  }

  export type seasonScalarWhereWithAggregatesInput = {
    AND?: Enumerable<seasonScalarWhereWithAggregatesInput>
    OR?: Enumerable<seasonScalarWhereWithAggregatesInput>
    NOT?: Enumerable<seasonScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    season_text?: StringWithAggregatesFilter | string
    season_number?: IntWithAggregatesFilter | number
    profile_id?: StringWithAggregatesFilter | string
    collection_id?: StringNullableWithAggregatesFilter | string | null
    tv_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type episodeWhereInput = {
    AND?: Enumerable<episodeWhereInput>
    OR?: Enumerable<episodeWhereInput>
    NOT?: Enumerable<episodeWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    episode_text?: StringFilter | string
    season_text?: StringFilter | string
    episode_number?: IntFilter | number
    profile_id?: StringFilter | string
    tv_id?: StringFilter | string
    season_id?: StringFilter | string
    user_id?: StringFilter | string
    profile?: XOR<Episode_profileRelationFilter, episode_profileWhereInput>
    tv?: XOR<TvRelationFilter, tvWhereInput>
    season?: XOR<SeasonRelationFilter, seasonWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
    parsed_episodes?: Parsed_episodeListRelationFilter
    play_histories?: Play_historyListRelationFilter
    reports?: ReportListRelationFilter
    subtitles?: SubtitleListRelationFilter
  }

  export type episodeOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_text?: SortOrder
    season_text?: SortOrder
    episode_number?: SortOrder
    profile_id?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    user_id?: SortOrder
    profile?: episode_profileOrderByWithRelationInput
    tv?: tvOrderByWithRelationInput
    season?: seasonOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    parsed_episodes?: parsed_episodeOrderByRelationAggregateInput
    play_histories?: play_historyOrderByRelationAggregateInput
    reports?: reportOrderByRelationAggregateInput
    subtitles?: subtitleOrderByRelationAggregateInput
  }

  export type episodeWhereUniqueInput = {
    id?: string
    user_id_profile_id?: episodeUser_idProfile_idCompoundUniqueInput
  }

  export type episodeOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_text?: SortOrder
    season_text?: SortOrder
    episode_number?: SortOrder
    profile_id?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    user_id?: SortOrder
    _count?: episodeCountOrderByAggregateInput
    _avg?: episodeAvgOrderByAggregateInput
    _max?: episodeMaxOrderByAggregateInput
    _min?: episodeMinOrderByAggregateInput
    _sum?: episodeSumOrderByAggregateInput
  }

  export type episodeScalarWhereWithAggregatesInput = {
    AND?: Enumerable<episodeScalarWhereWithAggregatesInput>
    OR?: Enumerable<episodeScalarWhereWithAggregatesInput>
    NOT?: Enumerable<episodeScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    episode_text?: StringWithAggregatesFilter | string
    season_text?: StringWithAggregatesFilter | string
    episode_number?: IntWithAggregatesFilter | number
    profile_id?: StringWithAggregatesFilter | string
    tv_id?: StringWithAggregatesFilter | string
    season_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type movieWhereInput = {
    AND?: Enumerable<movieWhereInput>
    OR?: Enumerable<movieWhereInput>
    NOT?: Enumerable<movieWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    profile_id?: StringFilter | string
    user_id?: StringFilter | string
    collection_id?: StringNullableFilter | string | null
    profile?: XOR<Movie_profileRelationFilter, movie_profileWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
    collection?: XOR<CollectionRelationFilter, collectionWhereInput> | null
    play_histories?: Play_historyListRelationFilter
    parsed_movies?: Parsed_movieListRelationFilter
    reports?: ReportListRelationFilter
    subtitles?: SubtitleListRelationFilter
  }

  export type movieOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    profile_id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    profile?: movie_profileOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    collection?: collectionOrderByWithRelationInput
    play_histories?: play_historyOrderByRelationAggregateInput
    parsed_movies?: parsed_movieOrderByRelationAggregateInput
    reports?: reportOrderByRelationAggregateInput
    subtitles?: subtitleOrderByRelationAggregateInput
  }

  export type movieWhereUniqueInput = {
    id?: string
    user_id_profile_id?: movieUser_idProfile_idCompoundUniqueInput
  }

  export type movieOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    profile_id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
    _count?: movieCountOrderByAggregateInput
    _max?: movieMaxOrderByAggregateInput
    _min?: movieMinOrderByAggregateInput
  }

  export type movieScalarWhereWithAggregatesInput = {
    AND?: Enumerable<movieScalarWhereWithAggregatesInput>
    OR?: Enumerable<movieScalarWhereWithAggregatesInput>
    NOT?: Enumerable<movieScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    profile_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
    collection_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type collectionWhereInput = {
    AND?: Enumerable<collectionWhereInput>
    OR?: Enumerable<collectionWhereInput>
    NOT?: Enumerable<collectionWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    title?: StringFilter | string
    desc?: StringNullableFilter | string | null
    type?: IntFilter | number
    rules?: StringNullableFilter | string | null
    sort?: IntFilter | number
    styles?: StringNullableFilter | string | null
    user_id?: StringFilter | string
    tvs?: TvListRelationFilter
    seasons?: SeasonListRelationFilter
    movies?: MovieListRelationFilter
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type collectionOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    type?: SortOrder
    rules?: SortOrder
    sort?: SortOrder
    styles?: SortOrder
    user_id?: SortOrder
    tvs?: tvOrderByRelationAggregateInput
    seasons?: seasonOrderByRelationAggregateInput
    movies?: movieOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
  }

  export type collectionWhereUniqueInput = {
    id?: string
  }

  export type collectionOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    type?: SortOrder
    rules?: SortOrder
    sort?: SortOrder
    styles?: SortOrder
    user_id?: SortOrder
    _count?: collectionCountOrderByAggregateInput
    _avg?: collectionAvgOrderByAggregateInput
    _max?: collectionMaxOrderByAggregateInput
    _min?: collectionMinOrderByAggregateInput
    _sum?: collectionSumOrderByAggregateInput
  }

  export type collectionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<collectionScalarWhereWithAggregatesInput>
    OR?: Enumerable<collectionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<collectionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    title?: StringWithAggregatesFilter | string
    desc?: StringNullableWithAggregatesFilter | string | null
    type?: IntWithAggregatesFilter | number
    rules?: StringNullableWithAggregatesFilter | string | null
    sort?: IntWithAggregatesFilter | number
    styles?: StringNullableWithAggregatesFilter | string | null
    user_id?: StringWithAggregatesFilter | string
  }

  export type async_taskWhereInput = {
    AND?: Enumerable<async_taskWhereInput>
    OR?: Enumerable<async_taskWhereInput>
    NOT?: Enumerable<async_taskWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    type?: IntNullableFilter | number | null
    desc?: StringNullableFilter | string | null
    status?: IntNullableFilter | number | null
    need_stop?: IntNullableFilter | number | null
    error?: StringNullableFilter | string | null
    output_id?: StringFilter | string
    user_id?: StringFilter | string
    output?: XOR<OutputRelationFilter, outputWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type async_taskOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    type?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    need_stop?: SortOrder
    error?: SortOrder
    output_id?: SortOrder
    user_id?: SortOrder
    output?: outputOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type async_taskWhereUniqueInput = {
    id?: string
    output_id?: string
  }

  export type async_taskOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    type?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    need_stop?: SortOrder
    error?: SortOrder
    output_id?: SortOrder
    user_id?: SortOrder
    _count?: async_taskCountOrderByAggregateInput
    _avg?: async_taskAvgOrderByAggregateInput
    _max?: async_taskMaxOrderByAggregateInput
    _min?: async_taskMinOrderByAggregateInput
    _sum?: async_taskSumOrderByAggregateInput
  }

  export type async_taskScalarWhereWithAggregatesInput = {
    AND?: Enumerable<async_taskScalarWhereWithAggregatesInput>
    OR?: Enumerable<async_taskScalarWhereWithAggregatesInput>
    NOT?: Enumerable<async_taskScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    unique_id?: StringWithAggregatesFilter | string
    type?: IntNullableWithAggregatesFilter | number | null
    desc?: StringNullableWithAggregatesFilter | string | null
    status?: IntNullableWithAggregatesFilter | number | null
    need_stop?: IntNullableWithAggregatesFilter | number | null
    error?: StringNullableWithAggregatesFilter | string | null
    output_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type outputWhereInput = {
    AND?: Enumerable<outputWhereInput>
    OR?: Enumerable<outputWhereInput>
    NOT?: Enumerable<outputWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    user_id?: StringFilter | string
    lines?: Output_lineListRelationFilter
    user?: XOR<UserRelationFilter, userWhereInput>
    async_task?: XOR<Async_taskRelationFilter, async_taskWhereInput> | null
  }

  export type outputOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    user_id?: SortOrder
    lines?: output_lineOrderByRelationAggregateInput
    user?: userOrderByWithRelationInput
    async_task?: async_taskOrderByWithRelationInput
  }

  export type outputWhereUniqueInput = {
    id?: string
  }

  export type outputOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    user_id?: SortOrder
    _count?: outputCountOrderByAggregateInput
    _max?: outputMaxOrderByAggregateInput
    _min?: outputMinOrderByAggregateInput
  }

  export type outputScalarWhereWithAggregatesInput = {
    AND?: Enumerable<outputScalarWhereWithAggregatesInput>
    OR?: Enumerable<outputScalarWhereWithAggregatesInput>
    NOT?: Enumerable<outputScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type output_lineWhereInput = {
    AND?: Enumerable<output_lineWhereInput>
    OR?: Enumerable<output_lineWhereInput>
    NOT?: Enumerable<output_lineWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    content?: StringFilter | string
    output_id?: StringNullableFilter | string | null
    output?: XOR<OutputRelationFilter, outputWhereInput> | null
  }

  export type output_lineOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    content?: SortOrder
    output_id?: SortOrder
    output?: outputOrderByWithRelationInput
  }

  export type output_lineWhereUniqueInput = {
    id?: string
  }

  export type output_lineOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    content?: SortOrder
    output_id?: SortOrder
    _count?: output_lineCountOrderByAggregateInput
    _max?: output_lineMaxOrderByAggregateInput
    _min?: output_lineMinOrderByAggregateInput
  }

  export type output_lineScalarWhereWithAggregatesInput = {
    AND?: Enumerable<output_lineScalarWhereWithAggregatesInput>
    OR?: Enumerable<output_lineScalarWhereWithAggregatesInput>
    NOT?: Enumerable<output_lineScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    content?: StringWithAggregatesFilter | string
    output_id?: StringNullableWithAggregatesFilter | string | null
  }

  export type play_historyWhereInput = {
    AND?: Enumerable<play_historyWhereInput>
    OR?: Enumerable<play_historyWhereInput>
    NOT?: Enumerable<play_historyWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    duration?: FloatNullableFilter | number | null
    current_time?: FloatNullableFilter | number | null
    thumbnail?: StringNullableFilter | string | null
    file_id?: StringNullableFilter | string | null
    tv_id?: StringNullableFilter | string | null
    season_id?: StringNullableFilter | string | null
    episode_id?: StringNullableFilter | string | null
    movie_id?: StringNullableFilter | string | null
    member_id?: StringFilter | string
    tv?: XOR<TvRelationFilter, tvWhereInput> | null
    season?: XOR<SeasonRelationFilter, seasonWhereInput> | null
    episode?: XOR<EpisodeRelationFilter, episodeWhereInput> | null
    movie?: XOR<MovieRelationFilter, movieWhereInput> | null
    member?: XOR<MemberRelationFilter, memberWhereInput>
  }

  export type play_historyOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    duration?: SortOrder
    current_time?: SortOrder
    thumbnail?: SortOrder
    file_id?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    episode_id?: SortOrder
    movie_id?: SortOrder
    member_id?: SortOrder
    tv?: tvOrderByWithRelationInput
    season?: seasonOrderByWithRelationInput
    episode?: episodeOrderByWithRelationInput
    movie?: movieOrderByWithRelationInput
    member?: memberOrderByWithRelationInput
  }

  export type play_historyWhereUniqueInput = {
    id?: string
  }

  export type play_historyOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    duration?: SortOrder
    current_time?: SortOrder
    thumbnail?: SortOrder
    file_id?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    episode_id?: SortOrder
    movie_id?: SortOrder
    member_id?: SortOrder
    _count?: play_historyCountOrderByAggregateInput
    _avg?: play_historyAvgOrderByAggregateInput
    _max?: play_historyMaxOrderByAggregateInput
    _min?: play_historyMinOrderByAggregateInput
    _sum?: play_historySumOrderByAggregateInput
  }

  export type play_historyScalarWhereWithAggregatesInput = {
    AND?: Enumerable<play_historyScalarWhereWithAggregatesInput>
    OR?: Enumerable<play_historyScalarWhereWithAggregatesInput>
    NOT?: Enumerable<play_historyScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    duration?: FloatNullableWithAggregatesFilter | number | null
    current_time?: FloatNullableWithAggregatesFilter | number | null
    thumbnail?: StringNullableWithAggregatesFilter | string | null
    file_id?: StringNullableWithAggregatesFilter | string | null
    tv_id?: StringNullableWithAggregatesFilter | string | null
    season_id?: StringNullableWithAggregatesFilter | string | null
    episode_id?: StringNullableWithAggregatesFilter | string | null
    movie_id?: StringNullableWithAggregatesFilter | string | null
    member_id?: StringWithAggregatesFilter | string
  }

  export type tv_profile_quickWhereInput = {
    AND?: Enumerable<tv_profile_quickWhereInput>
    OR?: Enumerable<tv_profile_quickWhereInput>
    NOT?: Enumerable<tv_profile_quickWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    name?: StringFilter | string
    tv_profile_id?: StringFilter | string
    tv_profile?: XOR<Tv_profileRelationFilter, tv_profileWhereInput>
  }

  export type tv_profile_quickOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    tv_profile_id?: SortOrder
    tv_profile?: tv_profileOrderByWithRelationInput
  }

  export type tv_profile_quickWhereUniqueInput = {
    id?: string
    name?: string
  }

  export type tv_profile_quickOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    tv_profile_id?: SortOrder
    _count?: tv_profile_quickCountOrderByAggregateInput
    _max?: tv_profile_quickMaxOrderByAggregateInput
    _min?: tv_profile_quickMinOrderByAggregateInput
  }

  export type tv_profile_quickScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tv_profile_quickScalarWhereWithAggregatesInput>
    OR?: Enumerable<tv_profile_quickScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tv_profile_quickScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    tv_profile_id?: StringWithAggregatesFilter | string
  }

  export type shared_fileWhereInput = {
    AND?: Enumerable<shared_fileWhereInput>
    OR?: Enumerable<shared_fileWhereInput>
    NOT?: Enumerable<shared_fileWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    title?: StringNullableFilter | string | null
    url?: StringFilter | string
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type shared_fileOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
    url?: SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type shared_fileWhereUniqueInput = {
    id?: string
  }

  export type shared_fileOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
    url?: SortOrder
    user_id?: SortOrder
    _count?: shared_fileCountOrderByAggregateInput
    _max?: shared_fileMaxOrderByAggregateInput
    _min?: shared_fileMinOrderByAggregateInput
  }

  export type shared_fileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<shared_fileScalarWhereWithAggregatesInput>
    OR?: Enumerable<shared_fileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<shared_fileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    title?: StringNullableWithAggregatesFilter | string | null
    url?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type shared_file_in_progressWhereInput = {
    AND?: Enumerable<shared_file_in_progressWhereInput>
    OR?: Enumerable<shared_file_in_progressWhereInput>
    NOT?: Enumerable<shared_file_in_progressWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    url?: StringFilter | string
    file_id?: StringFilter | string
    name?: StringFilter | string
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
    drive?: XOR<DriveRelationFilter, driveWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type shared_file_in_progressOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    url?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    drive?: driveOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type shared_file_in_progressWhereUniqueInput = {
    id?: string
  }

  export type shared_file_in_progressOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    url?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    _count?: shared_file_in_progressCountOrderByAggregateInput
    _max?: shared_file_in_progressMaxOrderByAggregateInput
    _min?: shared_file_in_progressMinOrderByAggregateInput
  }

  export type shared_file_in_progressScalarWhereWithAggregatesInput = {
    AND?: Enumerable<shared_file_in_progressScalarWhereWithAggregatesInput>
    OR?: Enumerable<shared_file_in_progressScalarWhereWithAggregatesInput>
    NOT?: Enumerable<shared_file_in_progressScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    url?: StringWithAggregatesFilter | string
    file_id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    drive_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type bind_for_parsed_tvWhereInput = {
    AND?: Enumerable<bind_for_parsed_tvWhereInput>
    OR?: Enumerable<bind_for_parsed_tvWhereInput>
    NOT?: Enumerable<bind_for_parsed_tvWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    url?: StringFilter | string
    file_id?: StringFilter | string
    name?: StringFilter | string
    file_id_link_resource?: StringFilter | string
    file_name_link_resource?: StringFilter | string
    in_production?: IntNullableFilter | number | null
    invalid?: IntNullableFilter | number | null
    season_id?: StringNullableFilter | string | null
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
    season?: XOR<SeasonRelationFilter, seasonWhereInput> | null
    drive?: XOR<DriveRelationFilter, driveWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type bind_for_parsed_tvOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    url?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    file_id_link_resource?: SortOrder
    file_name_link_resource?: SortOrder
    in_production?: SortOrder
    invalid?: SortOrder
    season_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    season?: seasonOrderByWithRelationInput
    drive?: driveOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type bind_for_parsed_tvWhereUniqueInput = {
    id?: string
  }

  export type bind_for_parsed_tvOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    url?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    file_id_link_resource?: SortOrder
    file_name_link_resource?: SortOrder
    in_production?: SortOrder
    invalid?: SortOrder
    season_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    _count?: bind_for_parsed_tvCountOrderByAggregateInput
    _avg?: bind_for_parsed_tvAvgOrderByAggregateInput
    _max?: bind_for_parsed_tvMaxOrderByAggregateInput
    _min?: bind_for_parsed_tvMinOrderByAggregateInput
    _sum?: bind_for_parsed_tvSumOrderByAggregateInput
  }

  export type bind_for_parsed_tvScalarWhereWithAggregatesInput = {
    AND?: Enumerable<bind_for_parsed_tvScalarWhereWithAggregatesInput>
    OR?: Enumerable<bind_for_parsed_tvScalarWhereWithAggregatesInput>
    NOT?: Enumerable<bind_for_parsed_tvScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    url?: StringWithAggregatesFilter | string
    file_id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    file_id_link_resource?: StringWithAggregatesFilter | string
    file_name_link_resource?: StringWithAggregatesFilter | string
    in_production?: IntNullableWithAggregatesFilter | number | null
    invalid?: IntNullableWithAggregatesFilter | number | null
    season_id?: StringNullableWithAggregatesFilter | string | null
    drive_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type drive_check_inWhereInput = {
    AND?: Enumerable<drive_check_inWhereInput>
    OR?: Enumerable<drive_check_inWhereInput>
    NOT?: Enumerable<drive_check_inWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    checked_at?: DateTimeNullableFilter | Date | string | null
    drive_id?: StringFilter | string
    drive?: XOR<DriveRelationFilter, driveWhereInput>
  }

  export type drive_check_inOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    checked_at?: SortOrder
    drive_id?: SortOrder
    drive?: driveOrderByWithRelationInput
  }

  export type drive_check_inWhereUniqueInput = {
    id?: string
  }

  export type drive_check_inOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    checked_at?: SortOrder
    drive_id?: SortOrder
    _count?: drive_check_inCountOrderByAggregateInput
    _max?: drive_check_inMaxOrderByAggregateInput
    _min?: drive_check_inMinOrderByAggregateInput
  }

  export type drive_check_inScalarWhereWithAggregatesInput = {
    AND?: Enumerable<drive_check_inScalarWhereWithAggregatesInput>
    OR?: Enumerable<drive_check_inScalarWhereWithAggregatesInput>
    NOT?: Enumerable<drive_check_inScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    checked_at?: DateTimeNullableWithAggregatesFilter | Date | string | null
    drive_id?: StringWithAggregatesFilter | string
  }

  export type tmp_fileWhereInput = {
    AND?: Enumerable<tmp_fileWhereInput>
    OR?: Enumerable<tmp_fileWhereInput>
    NOT?: Enumerable<tmp_fileWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    name?: StringFilter | string
    type?: FloatNullableFilter | number | null
    parent_paths?: StringFilter | string
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
    drive?: XOR<DriveRelationFilter, driveWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type tmp_fileOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parent_paths?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    drive?: driveOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type tmp_fileWhereUniqueInput = {
    id?: string
  }

  export type tmp_fileOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parent_paths?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    _count?: tmp_fileCountOrderByAggregateInput
    _avg?: tmp_fileAvgOrderByAggregateInput
    _max?: tmp_fileMaxOrderByAggregateInput
    _min?: tmp_fileMinOrderByAggregateInput
    _sum?: tmp_fileSumOrderByAggregateInput
  }

  export type tmp_fileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<tmp_fileScalarWhereWithAggregatesInput>
    OR?: Enumerable<tmp_fileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<tmp_fileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    name?: StringWithAggregatesFilter | string
    type?: FloatNullableWithAggregatesFilter | number | null
    parent_paths?: StringWithAggregatesFilter | string
    drive_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type incomplete_tvWhereInput = {
    AND?: Enumerable<incomplete_tvWhereInput>
    OR?: Enumerable<incomplete_tvWhereInput>
    NOT?: Enumerable<incomplete_tvWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    episode_count?: FloatNullableFilter | number | null
    cur_count?: FloatNullableFilter | number | null
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type incomplete_tvOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_count?: SortOrder
    cur_count?: SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type incomplete_tvWhereUniqueInput = {
    id?: string
  }

  export type incomplete_tvOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_count?: SortOrder
    cur_count?: SortOrder
    user_id?: SortOrder
    _count?: incomplete_tvCountOrderByAggregateInput
    _avg?: incomplete_tvAvgOrderByAggregateInput
    _max?: incomplete_tvMaxOrderByAggregateInput
    _min?: incomplete_tvMinOrderByAggregateInput
    _sum?: incomplete_tvSumOrderByAggregateInput
  }

  export type incomplete_tvScalarWhereWithAggregatesInput = {
    AND?: Enumerable<incomplete_tvScalarWhereWithAggregatesInput>
    OR?: Enumerable<incomplete_tvScalarWhereWithAggregatesInput>
    NOT?: Enumerable<incomplete_tvScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    episode_count?: FloatNullableWithAggregatesFilter | number | null
    cur_count?: FloatNullableWithAggregatesFilter | number | null
    user_id?: StringWithAggregatesFilter | string
  }

  export type fileWhereInput = {
    AND?: Enumerable<fileWhereInput>
    OR?: Enumerable<fileWhereInput>
    NOT?: Enumerable<fileWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    file_id?: StringFilter | string
    name?: StringFilter | string
    parent_file_id?: StringFilter | string
    parent_paths?: StringFilter | string
    type?: IntFilter | number
    size?: FloatNullableFilter | number | null
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
    drive?: XOR<DriveRelationFilter, driveWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type fileOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    drive?: driveOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type fileWhereUniqueInput = {
    id?: string
  }

  export type fileOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
    _count?: fileCountOrderByAggregateInput
    _avg?: fileAvgOrderByAggregateInput
    _max?: fileMaxOrderByAggregateInput
    _min?: fileMinOrderByAggregateInput
    _sum?: fileSumOrderByAggregateInput
  }

  export type fileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<fileScalarWhereWithAggregatesInput>
    OR?: Enumerable<fileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<fileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    file_id?: StringWithAggregatesFilter | string
    name?: StringWithAggregatesFilter | string
    parent_file_id?: StringWithAggregatesFilter | string
    parent_paths?: StringWithAggregatesFilter | string
    type?: IntWithAggregatesFilter | number
    size?: FloatNullableWithAggregatesFilter | number | null
    drive_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type logWhereInput = {
    AND?: Enumerable<logWhereInput>
    OR?: Enumerable<logWhereInput>
    NOT?: Enumerable<logWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    title?: StringFilter | string
  }

  export type logOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
  }

  export type logWhereUniqueInput = {
    id?: string
  }

  export type logOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
    _count?: logCountOrderByAggregateInput
    _max?: logMaxOrderByAggregateInput
    _min?: logMinOrderByAggregateInput
  }

  export type logScalarWhereWithAggregatesInput = {
    AND?: Enumerable<logScalarWhereWithAggregatesInput>
    OR?: Enumerable<logScalarWhereWithAggregatesInput>
    NOT?: Enumerable<logScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    title?: StringWithAggregatesFilter | string
  }

  export type memberWhereInput = {
    AND?: Enumerable<memberWhereInput>
    OR?: Enumerable<memberWhereInput>
    NOT?: Enumerable<memberWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    email?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    avatar?: StringNullableFilter | string | null
    remark?: StringFilter | string
    permission?: StringNullableFilter | string | null
    disabled?: IntNullableFilter | number | null
    delete?: IntNullableFilter | number | null
    inviter_id?: StringNullableFilter | string | null
    user_id?: StringFilter | string
    inviter?: XOR<MemberRelationFilter, memberWhereInput> | null
    user?: XOR<UserRelationFilter, userWhereInput>
    member_setting?: XOR<Member_settingRelationFilter, member_settingWhereInput> | null
    member_tokens?: Member_tokenListRelationFilter
    play_histories?: Play_historyListRelationFilter
    reports?: ReportListRelationFilter
    invitees?: MemberListRelationFilter
    notifications?: Member_notificationListRelationFilter
  }

  export type memberOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    remark?: SortOrder
    permission?: SortOrder
    disabled?: SortOrder
    delete?: SortOrder
    inviter_id?: SortOrder
    user_id?: SortOrder
    inviter?: memberOrderByWithRelationInput
    user?: userOrderByWithRelationInput
    member_setting?: member_settingOrderByWithRelationInput
    member_tokens?: member_tokenOrderByRelationAggregateInput
    play_histories?: play_historyOrderByRelationAggregateInput
    reports?: reportOrderByRelationAggregateInput
    invitees?: memberOrderByRelationAggregateInput
    notifications?: member_notificationOrderByRelationAggregateInput
  }

  export type memberWhereUniqueInput = {
    id?: string
    user_id_inviter_id_remark?: memberUser_idInviter_idRemarkCompoundUniqueInput
  }

  export type memberOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    remark?: SortOrder
    permission?: SortOrder
    disabled?: SortOrder
    delete?: SortOrder
    inviter_id?: SortOrder
    user_id?: SortOrder
    _count?: memberCountOrderByAggregateInput
    _avg?: memberAvgOrderByAggregateInput
    _max?: memberMaxOrderByAggregateInput
    _min?: memberMinOrderByAggregateInput
    _sum?: memberSumOrderByAggregateInput
  }

  export type memberScalarWhereWithAggregatesInput = {
    AND?: Enumerable<memberScalarWhereWithAggregatesInput>
    OR?: Enumerable<memberScalarWhereWithAggregatesInput>
    NOT?: Enumerable<memberScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    email?: StringNullableWithAggregatesFilter | string | null
    name?: StringNullableWithAggregatesFilter | string | null
    avatar?: StringNullableWithAggregatesFilter | string | null
    remark?: StringWithAggregatesFilter | string
    permission?: StringNullableWithAggregatesFilter | string | null
    disabled?: IntNullableWithAggregatesFilter | number | null
    delete?: IntNullableWithAggregatesFilter | number | null
    inviter_id?: StringNullableWithAggregatesFilter | string | null
    user_id?: StringWithAggregatesFilter | string
  }

  export type member_tokenWhereInput = {
    AND?: Enumerable<member_tokenWhereInput>
    OR?: Enumerable<member_tokenWhereInput>
    NOT?: Enumerable<member_tokenWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    token?: StringFilter | string
    used?: FloatNullableFilter | number | null
    expired_at?: StringNullableFilter | string | null
    member_id?: StringFilter | string
    member?: XOR<MemberRelationFilter, memberWhereInput>
  }

  export type member_tokenOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    token?: SortOrder
    used?: SortOrder
    expired_at?: SortOrder
    member_id?: SortOrder
    member?: memberOrderByWithRelationInput
  }

  export type member_tokenWhereUniqueInput = {
    id?: string
  }

  export type member_tokenOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    token?: SortOrder
    used?: SortOrder
    expired_at?: SortOrder
    member_id?: SortOrder
    _count?: member_tokenCountOrderByAggregateInput
    _avg?: member_tokenAvgOrderByAggregateInput
    _max?: member_tokenMaxOrderByAggregateInput
    _min?: member_tokenMinOrderByAggregateInput
    _sum?: member_tokenSumOrderByAggregateInput
  }

  export type member_tokenScalarWhereWithAggregatesInput = {
    AND?: Enumerable<member_tokenScalarWhereWithAggregatesInput>
    OR?: Enumerable<member_tokenScalarWhereWithAggregatesInput>
    NOT?: Enumerable<member_tokenScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    token?: StringWithAggregatesFilter | string
    used?: FloatNullableWithAggregatesFilter | number | null
    expired_at?: StringNullableWithAggregatesFilter | string | null
    member_id?: StringWithAggregatesFilter | string
  }

  export type member_settingWhereInput = {
    AND?: Enumerable<member_settingWhereInput>
    OR?: Enumerable<member_settingWhereInput>
    NOT?: Enumerable<member_settingWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    data?: StringFilter | string
    member_id?: StringFilter | string
    member?: XOR<MemberRelationFilter, memberWhereInput>
  }

  export type member_settingOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    member_id?: SortOrder
    member?: memberOrderByWithRelationInput
  }

  export type member_settingWhereUniqueInput = {
    id?: string
    member_id?: string
  }

  export type member_settingOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    member_id?: SortOrder
    _count?: member_settingCountOrderByAggregateInput
    _max?: member_settingMaxOrderByAggregateInput
    _min?: member_settingMinOrderByAggregateInput
  }

  export type member_settingScalarWhereWithAggregatesInput = {
    AND?: Enumerable<member_settingScalarWhereWithAggregatesInput>
    OR?: Enumerable<member_settingScalarWhereWithAggregatesInput>
    NOT?: Enumerable<member_settingScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    data?: StringWithAggregatesFilter | string
    member_id?: StringWithAggregatesFilter | string
  }

  export type permissionWhereInput = {
    AND?: Enumerable<permissionWhereInput>
    OR?: Enumerable<permissionWhereInput>
    NOT?: Enumerable<permissionWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    desc?: StringFilter | string
    code?: StringFilter | string
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type permissionOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    desc?: SortOrder
    code?: SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type permissionWhereUniqueInput = {
    id?: string
  }

  export type permissionOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    desc?: SortOrder
    code?: SortOrder
    user_id?: SortOrder
    _count?: permissionCountOrderByAggregateInput
    _max?: permissionMaxOrderByAggregateInput
    _min?: permissionMinOrderByAggregateInput
  }

  export type permissionScalarWhereWithAggregatesInput = {
    AND?: Enumerable<permissionScalarWhereWithAggregatesInput>
    OR?: Enumerable<permissionScalarWhereWithAggregatesInput>
    NOT?: Enumerable<permissionScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    desc?: StringWithAggregatesFilter | string
    code?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type member_notificationWhereInput = {
    AND?: Enumerable<member_notificationWhereInput>
    OR?: Enumerable<member_notificationWhereInput>
    NOT?: Enumerable<member_notificationWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    content?: StringNullableFilter | string | null
    type?: IntNullableFilter | number | null
    status?: IntNullableFilter | number | null
    is_delete?: IntNullableFilter | number | null
    member_id?: StringFilter | string
    member?: XOR<MemberRelationFilter, memberWhereInput>
  }

  export type member_notificationOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
    member_id?: SortOrder
    member?: memberOrderByWithRelationInput
  }

  export type member_notificationWhereUniqueInput = {
    id?: string
  }

  export type member_notificationOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
    member_id?: SortOrder
    _count?: member_notificationCountOrderByAggregateInput
    _avg?: member_notificationAvgOrderByAggregateInput
    _max?: member_notificationMaxOrderByAggregateInput
    _min?: member_notificationMinOrderByAggregateInput
    _sum?: member_notificationSumOrderByAggregateInput
  }

  export type member_notificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<member_notificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<member_notificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<member_notificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    unique_id?: StringWithAggregatesFilter | string
    content?: StringNullableWithAggregatesFilter | string | null
    type?: IntNullableWithAggregatesFilter | number | null
    status?: IntNullableWithAggregatesFilter | number | null
    is_delete?: IntNullableWithAggregatesFilter | number | null
    member_id?: StringWithAggregatesFilter | string
  }

  export type notificationWhereInput = {
    AND?: Enumerable<notificationWhereInput>
    OR?: Enumerable<notificationWhereInput>
    NOT?: Enumerable<notificationWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    content?: StringNullableFilter | string | null
    type?: IntNullableFilter | number | null
    status?: IntNullableFilter | number | null
    is_delete?: IntNullableFilter | number | null
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type notificationOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type notificationWhereUniqueInput = {
    id?: string
  }

  export type notificationOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
    user_id?: SortOrder
    _count?: notificationCountOrderByAggregateInput
    _avg?: notificationAvgOrderByAggregateInput
    _max?: notificationMaxOrderByAggregateInput
    _min?: notificationMinOrderByAggregateInput
    _sum?: notificationSumOrderByAggregateInput
  }

  export type notificationScalarWhereWithAggregatesInput = {
    AND?: Enumerable<notificationScalarWhereWithAggregatesInput>
    OR?: Enumerable<notificationScalarWhereWithAggregatesInput>
    NOT?: Enumerable<notificationScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    unique_id?: StringWithAggregatesFilter | string
    content?: StringNullableWithAggregatesFilter | string | null
    type?: IntNullableWithAggregatesFilter | number | null
    status?: IntNullableWithAggregatesFilter | number | null
    is_delete?: IntNullableWithAggregatesFilter | number | null
    user_id?: StringWithAggregatesFilter | string
  }

  export type reportWhereInput = {
    AND?: Enumerable<reportWhereInput>
    OR?: Enumerable<reportWhereInput>
    NOT?: Enumerable<reportWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    type?: IntFilter | number
    data?: StringFilter | string
    answer?: StringFilter | string
    tv_id?: StringNullableFilter | string | null
    season_id?: StringNullableFilter | string | null
    episode_id?: StringNullableFilter | string | null
    movie_id?: StringNullableFilter | string | null
    member_id?: StringFilter | string
    user_id?: StringFilter | string
    tv?: XOR<TvRelationFilter, tvWhereInput> | null
    season?: XOR<SeasonRelationFilter, seasonWhereInput> | null
    episode?: XOR<EpisodeRelationFilter, episodeWhereInput> | null
    movie?: XOR<MovieRelationFilter, movieWhereInput> | null
    member?: XOR<MemberRelationFilter, memberWhereInput>
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type reportOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    type?: SortOrder
    data?: SortOrder
    answer?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    episode_id?: SortOrder
    movie_id?: SortOrder
    member_id?: SortOrder
    user_id?: SortOrder
    tv?: tvOrderByWithRelationInput
    season?: seasonOrderByWithRelationInput
    episode?: episodeOrderByWithRelationInput
    movie?: movieOrderByWithRelationInput
    member?: memberOrderByWithRelationInput
    user?: userOrderByWithRelationInput
  }

  export type reportWhereUniqueInput = {
    id?: string
  }

  export type reportOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    type?: SortOrder
    data?: SortOrder
    answer?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    episode_id?: SortOrder
    movie_id?: SortOrder
    member_id?: SortOrder
    user_id?: SortOrder
    _count?: reportCountOrderByAggregateInput
    _avg?: reportAvgOrderByAggregateInput
    _max?: reportMaxOrderByAggregateInput
    _min?: reportMinOrderByAggregateInput
    _sum?: reportSumOrderByAggregateInput
  }

  export type reportScalarWhereWithAggregatesInput = {
    AND?: Enumerable<reportScalarWhereWithAggregatesInput>
    OR?: Enumerable<reportScalarWhereWithAggregatesInput>
    NOT?: Enumerable<reportScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    type?: IntWithAggregatesFilter | number
    data?: StringWithAggregatesFilter | string
    answer?: StringWithAggregatesFilter | string
    tv_id?: StringNullableWithAggregatesFilter | string | null
    season_id?: StringNullableWithAggregatesFilter | string | null
    episode_id?: StringNullableWithAggregatesFilter | string | null
    movie_id?: StringNullableWithAggregatesFilter | string | null
    member_id?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type accountWhereInput = {
    AND?: Enumerable<accountWhereInput>
    OR?: Enumerable<accountWhereInput>
    NOT?: Enumerable<accountWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    provider_account_id?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type accountOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type accountWhereUniqueInput = {
    id?: string
    provider_provider_account_id?: accountProviderProvider_account_idCompoundUniqueInput
  }

  export type accountOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    user_id?: SortOrder
    _count?: accountCountOrderByAggregateInput
    _avg?: accountAvgOrderByAggregateInput
    _max?: accountMaxOrderByAggregateInput
    _min?: accountMinOrderByAggregateInput
    _sum?: accountSumOrderByAggregateInput
  }

  export type accountScalarWhereWithAggregatesInput = {
    AND?: Enumerable<accountScalarWhereWithAggregatesInput>
    OR?: Enumerable<accountScalarWhereWithAggregatesInput>
    NOT?: Enumerable<accountScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    type?: StringWithAggregatesFilter | string
    provider?: StringWithAggregatesFilter | string
    provider_account_id?: StringWithAggregatesFilter | string
    refresh_token?: StringNullableWithAggregatesFilter | string | null
    access_token?: StringNullableWithAggregatesFilter | string | null
    expires_at?: IntNullableWithAggregatesFilter | number | null
    token_type?: StringNullableWithAggregatesFilter | string | null
    scope?: StringNullableWithAggregatesFilter | string | null
    id_token?: StringNullableWithAggregatesFilter | string | null
    session_state?: StringNullableWithAggregatesFilter | string | null
    user_id?: StringWithAggregatesFilter | string
  }

  export type credentialWhereInput = {
    AND?: Enumerable<credentialWhereInput>
    OR?: Enumerable<credentialWhereInput>
    NOT?: Enumerable<credentialWhereInput>
    id?: StringFilter | string
    password?: StringFilter | string
    salt?: StringFilter | string
    verified?: BoolFilter | boolean
    email?: StringFilter | string
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type credentialOrderByWithRelationInput = {
    id?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    verified?: SortOrder
    email?: SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type credentialWhereUniqueInput = {
    id?: string
    email?: string
    user_id?: string
  }

  export type credentialOrderByWithAggregationInput = {
    id?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    verified?: SortOrder
    email?: SortOrder
    user_id?: SortOrder
    _count?: credentialCountOrderByAggregateInput
    _max?: credentialMaxOrderByAggregateInput
    _min?: credentialMinOrderByAggregateInput
  }

  export type credentialScalarWhereWithAggregatesInput = {
    AND?: Enumerable<credentialScalarWhereWithAggregatesInput>
    OR?: Enumerable<credentialScalarWhereWithAggregatesInput>
    NOT?: Enumerable<credentialScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    password?: StringWithAggregatesFilter | string
    salt?: StringWithAggregatesFilter | string
    verified?: BoolWithAggregatesFilter | boolean
    email?: StringWithAggregatesFilter | string
    user_id?: StringWithAggregatesFilter | string
  }

  export type profileWhereInput = {
    AND?: Enumerable<profileWhereInput>
    OR?: Enumerable<profileWhereInput>
    NOT?: Enumerable<profileWhereInput>
    id?: StringFilter | string
    nickname?: StringNullableFilter | string | null
    avatar?: StringNullableFilter | string | null
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type profileOrderByWithRelationInput = {
    id?: SortOrder
    nickname?: SortOrder
    avatar?: SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type profileWhereUniqueInput = {
    id?: string
    user_id?: string
  }

  export type profileOrderByWithAggregationInput = {
    id?: SortOrder
    nickname?: SortOrder
    avatar?: SortOrder
    user_id?: SortOrder
    _count?: profileCountOrderByAggregateInput
    _max?: profileMaxOrderByAggregateInput
    _min?: profileMinOrderByAggregateInput
  }

  export type profileScalarWhereWithAggregatesInput = {
    AND?: Enumerable<profileScalarWhereWithAggregatesInput>
    OR?: Enumerable<profileScalarWhereWithAggregatesInput>
    NOT?: Enumerable<profileScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    nickname?: StringNullableWithAggregatesFilter | string | null
    avatar?: StringNullableWithAggregatesFilter | string | null
    user_id?: StringWithAggregatesFilter | string
  }

  export type settingsWhereInput = {
    AND?: Enumerable<settingsWhereInput>
    OR?: Enumerable<settingsWhereInput>
    NOT?: Enumerable<settingsWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    detail?: StringNullableFilter | string | null
    user_id?: StringFilter | string
    user?: XOR<UserRelationFilter, userWhereInput>
  }

  export type settingsOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    detail?: SortOrder
    user_id?: SortOrder
    user?: userOrderByWithRelationInput
  }

  export type settingsWhereUniqueInput = {
    id?: string
    user_id?: string
  }

  export type settingsOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    detail?: SortOrder
    user_id?: SortOrder
    _count?: settingsCountOrderByAggregateInput
    _max?: settingsMaxOrderByAggregateInput
    _min?: settingsMinOrderByAggregateInput
  }

  export type settingsScalarWhereWithAggregatesInput = {
    AND?: Enumerable<settingsScalarWhereWithAggregatesInput>
    OR?: Enumerable<settingsScalarWhereWithAggregatesInput>
    NOT?: Enumerable<settingsScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
    detail?: StringNullableWithAggregatesFilter | string | null
    user_id?: StringWithAggregatesFilter | string
  }

  export type userWhereInput = {
    AND?: Enumerable<userWhereInput>
    OR?: Enumerable<userWhereInput>
    NOT?: Enumerable<userWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    credential?: XOR<CredentialRelationFilter, credentialWhereInput> | null
    profile?: XOR<ProfileRelationFilter, profileWhereInput> | null
    settings?: XOR<SettingsRelationFilter, settingsWhereInput> | null
    accounts?: AccountListRelationFilter
    drives?: DriveListRelationFilter
    tv?: TvListRelationFilter
    seasons?: SeasonListRelationFilter
    episode?: EpisodeListRelationFilter
    movie?: MovieListRelationFilter
    parsed_tvs?: Parsed_tvListRelationFilter
    parsed_seasons?: Parsed_seasonListRelationFilter
    parsed_episodes?: Parsed_episodeListRelationFilter
    parsed_movies?: Parsed_movieListRelationFilter
    tv_need_complete?: Incomplete_tvListRelationFilter
    async_task?: Async_taskListRelationFilter
    files?: FileListRelationFilter
    members?: MemberListRelationFilter
    shared_files?: Shared_fileListRelationFilter
    shared_file_in_progress?: Shared_file_in_progressListRelationFilter
    tmp_files?: Tmp_fileListRelationFilter
    sync_tasks?: Bind_for_parsed_tvListRelationFilter
    notifications?: NotificationListRelationFilter
    outputs?: OutputListRelationFilter
    reports?: ReportListRelationFilter
    collections?: CollectionListRelationFilter
    subtitles?: SubtitleListRelationFilter
    permission?: PermissionListRelationFilter
  }

  export type userOrderByWithRelationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    credential?: credentialOrderByWithRelationInput
    profile?: profileOrderByWithRelationInput
    settings?: settingsOrderByWithRelationInput
    accounts?: accountOrderByRelationAggregateInput
    drives?: driveOrderByRelationAggregateInput
    tv?: tvOrderByRelationAggregateInput
    seasons?: seasonOrderByRelationAggregateInput
    episode?: episodeOrderByRelationAggregateInput
    movie?: movieOrderByRelationAggregateInput
    parsed_tvs?: parsed_tvOrderByRelationAggregateInput
    parsed_seasons?: parsed_seasonOrderByRelationAggregateInput
    parsed_episodes?: parsed_episodeOrderByRelationAggregateInput
    parsed_movies?: parsed_movieOrderByRelationAggregateInput
    tv_need_complete?: incomplete_tvOrderByRelationAggregateInput
    async_task?: async_taskOrderByRelationAggregateInput
    files?: fileOrderByRelationAggregateInput
    members?: memberOrderByRelationAggregateInput
    shared_files?: shared_fileOrderByRelationAggregateInput
    shared_file_in_progress?: shared_file_in_progressOrderByRelationAggregateInput
    tmp_files?: tmp_fileOrderByRelationAggregateInput
    sync_tasks?: bind_for_parsed_tvOrderByRelationAggregateInput
    notifications?: notificationOrderByRelationAggregateInput
    outputs?: outputOrderByRelationAggregateInput
    reports?: reportOrderByRelationAggregateInput
    collections?: collectionOrderByRelationAggregateInput
    subtitles?: subtitleOrderByRelationAggregateInput
    permission?: permissionOrderByRelationAggregateInput
  }

  export type userWhereUniqueInput = {
    id?: string
  }

  export type userOrderByWithAggregationInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    _count?: userCountOrderByAggregateInput
    _max?: userMaxOrderByAggregateInput
    _min?: userMinOrderByAggregateInput
  }

  export type userScalarWhereWithAggregatesInput = {
    AND?: Enumerable<userScalarWhereWithAggregatesInput>
    OR?: Enumerable<userScalarWhereWithAggregatesInput>
    NOT?: Enumerable<userScalarWhereWithAggregatesInput>
    id?: StringWithAggregatesFilter | string
    created?: DateTimeWithAggregatesFilter | Date | string
    updated?: DateTimeWithAggregatesFilter | Date | string
  }

  export type driveCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    user: userCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    user_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type driveUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type driveUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type drive_tokenCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    data: string
    expired_at: number
    drives?: driveCreateNestedManyWithoutDrive_tokenInput
  }

  export type drive_tokenUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    data: string
    expired_at: number
    drives?: driveUncheckedCreateNestedManyWithoutDrive_tokenInput
  }

  export type drive_tokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    expired_at?: FloatFieldUpdateOperationsInput | number
    drives?: driveUpdateManyWithoutDrive_tokenNestedInput
  }

  export type drive_tokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    expired_at?: FloatFieldUpdateOperationsInput | number
    drives?: driveUncheckedUpdateManyWithoutDrive_tokenNestedInput
  }

  export type drive_tokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    expired_at?: FloatFieldUpdateOperationsInput | number
  }

  export type drive_tokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    expired_at?: FloatFieldUpdateOperationsInput | number
  }

  export type tv_profileCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    original_name?: string | null
    overview?: string | null
    poster_path?: string | null
    backdrop_path?: string | null
    first_air_date?: string | null
    original_language?: string | null
    origin_country?: string | null
    genres?: string | null
    popularity?: number | null
    vote_average?: number | null
    vote_count?: number | null
    episode_count?: number | null
    season_count?: number | null
    status?: string | null
    in_production?: number | null
    tvs?: tvCreateNestedManyWithoutProfileInput
    snapshots?: tv_profile_quickCreateNestedManyWithoutTv_profileInput
  }

  export type tv_profileUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    original_name?: string | null
    overview?: string | null
    poster_path?: string | null
    backdrop_path?: string | null
    first_air_date?: string | null
    original_language?: string | null
    origin_country?: string | null
    genres?: string | null
    popularity?: number | null
    vote_average?: number | null
    vote_count?: number | null
    episode_count?: number | null
    season_count?: number | null
    status?: string | null
    in_production?: number | null
    tvs?: tvUncheckedCreateNestedManyWithoutProfileInput
    snapshots?: tv_profile_quickUncheckedCreateNestedManyWithoutTv_profileInput
  }

  export type tv_profileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    first_air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    season_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    tvs?: tvUpdateManyWithoutProfileNestedInput
    snapshots?: tv_profile_quickUpdateManyWithoutTv_profileNestedInput
  }

  export type tv_profileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    first_air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    season_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    tvs?: tvUncheckedUpdateManyWithoutProfileNestedInput
    snapshots?: tv_profile_quickUncheckedUpdateManyWithoutTv_profileNestedInput
  }

  export type tv_profileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    first_air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    season_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tv_profileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    first_air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    season_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type season_profileCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    overview?: string | null
    poster_path?: string | null
    season_number?: number | null
    air_date?: string | null
    episode_count?: number | null
    vote_average?: number | null
    seasons?: seasonCreateNestedManyWithoutProfileInput
  }

  export type season_profileUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    overview?: string | null
    poster_path?: string | null
    season_number?: number | null
    air_date?: string | null
    episode_count?: number | null
    vote_average?: number | null
    seasons?: seasonUncheckedCreateNestedManyWithoutProfileInput
  }

  export type season_profileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    seasons?: seasonUpdateManyWithoutProfileNestedInput
  }

  export type season_profileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    seasons?: seasonUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type season_profileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type season_profileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type episode_profileCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    overview?: string | null
    air_date?: string | null
    runtime?: number | null
    episode_number?: number | null
    season_number?: number | null
    episodes?: episodeCreateNestedManyWithoutProfileInput
  }

  export type episode_profileUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    overview?: string | null
    air_date?: string | null
    runtime?: number | null
    episode_number?: number | null
    season_number?: number | null
    episodes?: episodeUncheckedCreateNestedManyWithoutProfileInput
  }

  export type episode_profileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    episode_number?: NullableIntFieldUpdateOperationsInput | number | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
    episodes?: episodeUpdateManyWithoutProfileNestedInput
  }

  export type episode_profileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    episode_number?: NullableIntFieldUpdateOperationsInput | number | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
    episodes?: episodeUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type episode_profileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    episode_number?: NullableIntFieldUpdateOperationsInput | number | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type episode_profileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    episode_number?: NullableIntFieldUpdateOperationsInput | number | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type movie_profileCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    original_name?: string | null
    overview?: string | null
    poster_path?: string | null
    backdrop_path?: string | null
    air_date?: string | null
    original_language?: string | null
    popularity?: number | null
    vote_average?: number | null
    vote_count?: number | null
    origin_country?: string | null
    genres?: string | null
    runtime?: number | null
    movies?: movieCreateNestedManyWithoutProfileInput
  }

  export type movie_profileUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    original_name?: string | null
    overview?: string | null
    poster_path?: string | null
    backdrop_path?: string | null
    air_date?: string | null
    original_language?: string | null
    popularity?: number | null
    vote_average?: number | null
    vote_count?: number | null
    origin_country?: string | null
    genres?: string | null
    runtime?: number | null
    movies?: movieUncheckedCreateNestedManyWithoutProfileInput
  }

  export type movie_profileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    movies?: movieUpdateManyWithoutProfileNestedInput
  }

  export type movie_profileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    movies?: movieUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type movie_profileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type movie_profileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type subtitleCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    language: string
    movie?: movieCreateNestedOneWithoutSubtitlesInput
    episode?: episodeCreateNestedOneWithoutSubtitlesInput
    drive: driveCreateNestedOneWithoutSubtitlesInput
    user: userCreateNestedOneWithoutSubtitlesInput
  }

  export type subtitleUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    language: string
    movie_id?: string | null
    episode_id?: string | null
    drive_id: string
    user_id: string
  }

  export type subtitleUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    movie?: movieUpdateOneWithoutSubtitlesNestedInput
    episode?: episodeUpdateOneWithoutSubtitlesNestedInput
    drive?: driveUpdateOneRequiredWithoutSubtitlesNestedInput
    user?: userUpdateOneRequiredWithoutSubtitlesNestedInput
  }

  export type subtitleUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type subtitleUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
  }

  export type subtitleUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_tvCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    tv?: tvCreateNestedOneWithoutParsed_tvsInput
    drive: driveCreateNestedOneWithoutParsed_tvsInput
    user: userCreateNestedOneWithoutParsed_tvsInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutParsed_tvInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    tv_id?: string | null
    drive_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutParsed_tvInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv?: tvUpdateOneWithoutParsed_tvsNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_tvsNestedInput
    user?: userUpdateOneRequiredWithoutParsed_tvsNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutParsed_tvNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutParsed_tvNestedInput
  }

  export type parsed_tvUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutParsed_tvNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutParsed_tvNestedInput
  }

  export type parsed_tvUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parsed_tvUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_seasonCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    season?: seasonCreateNestedOneWithoutParsed_seasonInput
    parsed_tv: parsed_tvCreateNestedOneWithoutParsed_seasonsInput
    drive: driveCreateNestedOneWithoutParsed_seasonsInput
    user: userCreateNestedOneWithoutParsed_seasonsInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutParsed_seasonInput
  }

  export type parsed_seasonUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    season_id?: string | null
    parsed_tv_id: string
    drive_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutParsed_seasonInput
  }

  export type parsed_seasonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season?: seasonUpdateOneWithoutParsed_seasonNestedInput
    parsed_tv?: parsed_tvUpdateOneRequiredWithoutParsed_seasonsNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_seasonsNestedInput
    user?: userUpdateOneRequiredWithoutParsed_seasonsNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutParsed_seasonNestedInput
  }

  export type parsed_seasonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutParsed_seasonNestedInput
  }

  export type parsed_seasonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parsed_seasonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_episodeCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    episode?: episodeCreateNestedOneWithoutParsed_episodesInput
    parsed_tv: parsed_tvCreateNestedOneWithoutParsed_episodesInput
    parsed_season: parsed_seasonCreateNestedOneWithoutParsed_episodesInput
    drive: driveCreateNestedOneWithoutParsed_episodesInput
    user: userCreateNestedOneWithoutParsed_episodesInput
  }

  export type parsed_episodeUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    episode_id?: string | null
    parsed_tv_id: string
    parsed_season_id: string
    drive_id: string
    user_id: string
  }

  export type parsed_episodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode?: episodeUpdateOneWithoutParsed_episodesNestedInput
    parsed_tv?: parsed_tvUpdateOneRequiredWithoutParsed_episodesNestedInput
    parsed_season?: parsed_seasonUpdateOneRequiredWithoutParsed_episodesNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_episodesNestedInput
    user?: userUpdateOneRequiredWithoutParsed_episodesNestedInput
  }

  export type parsed_episodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    parsed_season_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_episodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parsed_episodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    parsed_season_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_movieCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    original_name?: string | null
    correct_name?: string | null
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    movie?: movieCreateNestedOneWithoutParsed_moviesInput
    drive: driveCreateNestedOneWithoutParsed_moviesInput
    user: userCreateNestedOneWithoutParsed_moviesInput
  }

  export type parsed_movieUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    original_name?: string | null
    correct_name?: string | null
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    movie_id?: string | null
    drive_id: string
    user_id: string
  }

  export type parsed_movieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: movieUpdateOneWithoutParsed_moviesNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_moviesNestedInput
    user?: userUpdateOneRequiredWithoutParsed_moviesNestedInput
  }

  export type parsed_movieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_movieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type parsed_movieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type tvCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile: tv_profileCreateNestedOneWithoutTvsInput
    collection?: collectionCreateNestedOneWithoutTvsInput
    user: userCreateNestedOneWithoutTvInput
    seasons?: seasonCreateNestedManyWithoutTvInput
    episodes?: episodeCreateNestedManyWithoutTvInput
    play_histories?: play_historyCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutTvInput
    reports?: reportCreateNestedManyWithoutTvInput
  }

  export type tvUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile_id: string
    collection_id?: string | null
    user_id: string
    seasons?: seasonUncheckedCreateNestedManyWithoutTvInput
    episodes?: episodeUncheckedCreateNestedManyWithoutTvInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutTvInput
    reports?: reportUncheckedCreateNestedManyWithoutTvInput
  }

  export type tvUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: tv_profileUpdateOneRequiredWithoutTvsNestedInput
    collection?: collectionUpdateOneWithoutTvsNestedInput
    user?: userUpdateOneRequiredWithoutTvNestedInput
    seasons?: seasonUpdateManyWithoutTvNestedInput
    episodes?: episodeUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutTvNestedInput
    reports?: reportUpdateManyWithoutTvNestedInput
  }

  export type tvUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    seasons?: seasonUncheckedUpdateManyWithoutTvNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutTvNestedInput
    reports?: reportUncheckedUpdateManyWithoutTvNestedInput
  }

  export type tvUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tvUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type seasonCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile: season_profileCreateNestedOneWithoutSeasonsInput
    collection?: collectionCreateNestedOneWithoutSeasonsInput
    tv: tvCreateNestedOneWithoutSeasonsInput
    user: userCreateNestedOneWithoutSeasonsInput
    parsed_season?: parsed_seasonCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyCreateNestedManyWithoutSeasonInput
    episodes?: episodeCreateNestedManyWithoutSeasonInput
    reports?: reportCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutSeasonInput
  }

  export type seasonUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile_id: string
    collection_id?: string | null
    tv_id: string
    user_id: string
    parsed_season?: parsed_seasonUncheckedCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutSeasonInput
    episodes?: episodeUncheckedCreateNestedManyWithoutSeasonInput
    reports?: reportUncheckedCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile?: season_profileUpdateOneRequiredWithoutSeasonsNestedInput
    collection?: collectionUpdateOneWithoutSeasonsNestedInput
    tv?: tvUpdateOneRequiredWithoutSeasonsNestedInput
    user?: userUpdateOneRequiredWithoutSeasonsNestedInput
    parsed_season?: parsed_seasonUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUpdateManyWithoutSeasonNestedInput
    reports?: reportUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_season?: parsed_seasonUncheckedUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutSeasonNestedInput
    reports?: reportUncheckedUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
  }

  export type seasonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type episodeCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile: episode_profileCreateNestedOneWithoutEpisodesInput
    tv: tvCreateNestedOneWithoutEpisodesInput
    season: seasonCreateNestedOneWithoutEpisodesInput
    user: userCreateNestedOneWithoutEpisodeInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyCreateNestedManyWithoutEpisodeInput
    reports?: reportCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleCreateNestedManyWithoutEpisodeInput
  }

  export type episodeUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile_id: string
    tv_id: string
    season_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutEpisodeInput
    reports?: reportUncheckedCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type episodeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile?: episode_profileUpdateOneRequiredWithoutEpisodesNestedInput
    tv?: tvUpdateOneRequiredWithoutEpisodesNestedInput
    season?: seasonUpdateOneRequiredWithoutEpisodesNestedInput
    user?: userUpdateOneRequiredWithoutEpisodeNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUpdateManyWithoutEpisodeNestedInput
    reports?: reportUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    tv_id?: StringFieldUpdateOperationsInput | string
    season_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutEpisodeNestedInput
    reports?: reportUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
  }

  export type episodeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    tv_id?: StringFieldUpdateOperationsInput | string
    season_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type movieCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile: movie_profileCreateNestedOneWithoutMoviesInput
    user: userCreateNestedOneWithoutMovieInput
    collection?: collectionCreateNestedOneWithoutMoviesInput
    play_histories?: play_historyCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutMovieInput
    reports?: reportCreateNestedManyWithoutMovieInput
    subtitles?: subtitleCreateNestedManyWithoutMovieInput
  }

  export type movieUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile_id: string
    user_id: string
    collection_id?: string | null
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutMovieInput
    reports?: reportUncheckedCreateNestedManyWithoutMovieInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutMovieInput
  }

  export type movieUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: movie_profileUpdateOneRequiredWithoutMoviesNestedInput
    user?: userUpdateOneRequiredWithoutMovieNestedInput
    collection?: collectionUpdateOneWithoutMoviesNestedInput
    play_histories?: play_historyUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutMovieNestedInput
    reports?: reportUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUpdateManyWithoutMovieNestedInput
  }

  export type movieUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    play_histories?: play_historyUncheckedUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutMovieNestedInput
    reports?: reportUncheckedUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type movieUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type movieUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collectionCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
    desc?: string | null
    type?: number
    rules?: string | null
    sort?: number
    styles?: string | null
    tvs?: tvCreateNestedManyWithoutCollectionInput
    seasons?: seasonCreateNestedManyWithoutCollectionInput
    movies?: movieCreateNestedManyWithoutCollectionInput
    user: userCreateNestedOneWithoutCollectionsInput
  }

  export type collectionUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
    desc?: string | null
    type?: number
    rules?: string | null
    sort?: number
    styles?: string | null
    user_id: string
    tvs?: tvUncheckedCreateNestedManyWithoutCollectionInput
    seasons?: seasonUncheckedCreateNestedManyWithoutCollectionInput
    movies?: movieUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
    tvs?: tvUpdateManyWithoutCollectionNestedInput
    seasons?: seasonUpdateManyWithoutCollectionNestedInput
    movies?: movieUpdateManyWithoutCollectionNestedInput
    user?: userUpdateOneRequiredWithoutCollectionsNestedInput
  }

  export type collectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    tvs?: tvUncheckedUpdateManyWithoutCollectionNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutCollectionNestedInput
    movies?: movieUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type collectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type async_taskCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    desc?: string | null
    status?: number | null
    need_stop?: number | null
    error?: string | null
    output: outputCreateNestedOneWithoutAsync_taskInput
    user: userCreateNestedOneWithoutAsync_taskInput
  }

  export type async_taskUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    desc?: string | null
    status?: number | null
    need_stop?: number | null
    error?: string | null
    output_id: string
    user_id: string
  }

  export type async_taskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    need_stop?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    output?: outputUpdateOneRequiredWithoutAsync_taskNestedInput
    user?: userUpdateOneRequiredWithoutAsync_taskNestedInput
  }

  export type async_taskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    need_stop?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    output_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type async_taskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    need_stop?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type async_taskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    need_stop?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    output_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type outputCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    lines?: output_lineCreateNestedManyWithoutOutputInput
    user: userCreateNestedOneWithoutOutputsInput
    async_task?: async_taskCreateNestedOneWithoutOutputInput
  }

  export type outputUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    user_id: string
    lines?: output_lineUncheckedCreateNestedManyWithoutOutputInput
    async_task?: async_taskUncheckedCreateNestedOneWithoutOutputInput
  }

  export type outputUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: output_lineUpdateManyWithoutOutputNestedInput
    user?: userUpdateOneRequiredWithoutOutputsNestedInput
    async_task?: async_taskUpdateOneWithoutOutputNestedInput
  }

  export type outputUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    lines?: output_lineUncheckedUpdateManyWithoutOutputNestedInput
    async_task?: async_taskUncheckedUpdateOneWithoutOutputNestedInput
  }

  export type outputUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type outputUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type output_lineCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    content: string
    output?: outputCreateNestedOneWithoutLinesInput
  }

  export type output_lineUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    content: string
    output_id?: string | null
  }

  export type output_lineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    output?: outputUpdateOneWithoutLinesNestedInput
  }

  export type output_lineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    output_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type output_lineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type output_lineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
    output_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type play_historyCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    tv?: tvCreateNestedOneWithoutPlay_historiesInput
    season?: seasonCreateNestedOneWithoutPlay_historiesInput
    episode?: episodeCreateNestedOneWithoutPlay_historiesInput
    movie?: movieCreateNestedOneWithoutPlay_historiesInput
    member: memberCreateNestedOneWithoutPlay_historiesInput
  }

  export type play_historyUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    tv_id?: string | null
    season_id?: string | null
    episode_id?: string | null
    movie_id?: string | null
    member_id: string
  }

  export type play_historyUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv?: tvUpdateOneWithoutPlay_historiesNestedInput
    season?: seasonUpdateOneWithoutPlay_historiesNestedInput
    episode?: episodeUpdateOneWithoutPlay_historiesNestedInput
    movie?: movieUpdateOneWithoutPlay_historiesNestedInput
    member?: memberUpdateOneRequiredWithoutPlay_historiesNestedInput
  }

  export type play_historyUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type play_historyUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type play_historyUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type tv_profile_quickCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    tv_profile: tv_profileCreateNestedOneWithoutSnapshotsInput
  }

  export type tv_profile_quickUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    tv_profile_id: string
  }

  export type tv_profile_quickUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    tv_profile?: tv_profileUpdateOneRequiredWithoutSnapshotsNestedInput
  }

  export type tv_profile_quickUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    tv_profile_id?: StringFieldUpdateOperationsInput | string
  }

  export type tv_profile_quickUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type tv_profile_quickUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    tv_profile_id?: StringFieldUpdateOperationsInput | string
  }

  export type shared_fileCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title?: string | null
    url: string
    user: userCreateNestedOneWithoutShared_filesInput
  }

  export type shared_fileUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title?: string | null
    url: string
    user_id: string
  }

  export type shared_fileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutShared_filesNestedInput
  }

  export type shared_fileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type shared_fileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type shared_fileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type shared_file_in_progressCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    drive: driveCreateNestedOneWithoutShared_file_in_progressInput
    user: userCreateNestedOneWithoutShared_file_in_progressInput
  }

  export type shared_file_in_progressUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    drive_id: string
    user_id: string
  }

  export type shared_file_in_progressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    drive?: driveUpdateOneRequiredWithoutShared_file_in_progressNestedInput
    user?: userUpdateOneRequiredWithoutShared_file_in_progressNestedInput
  }

  export type shared_file_in_progressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type shared_file_in_progressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type shared_file_in_progressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type bind_for_parsed_tvCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    file_id_link_resource: string
    file_name_link_resource: string
    in_production?: number | null
    invalid?: number | null
    season?: seasonCreateNestedOneWithoutSync_tasksInput
    drive: driveCreateNestedOneWithoutSync_tasksInput
    user: userCreateNestedOneWithoutSync_tasksInput
  }

  export type bind_for_parsed_tvUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    file_id_link_resource: string
    file_name_link_resource: string
    in_production?: number | null
    invalid?: number | null
    season_id?: string | null
    drive_id: string
    user_id: string
  }

  export type bind_for_parsed_tvUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id_link_resource?: StringFieldUpdateOperationsInput | string
    file_name_link_resource?: StringFieldUpdateOperationsInput | string
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    season?: seasonUpdateOneWithoutSync_tasksNestedInput
    drive?: driveUpdateOneRequiredWithoutSync_tasksNestedInput
    user?: userUpdateOneRequiredWithoutSync_tasksNestedInput
  }

  export type bind_for_parsed_tvUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id_link_resource?: StringFieldUpdateOperationsInput | string
    file_name_link_resource?: StringFieldUpdateOperationsInput | string
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type bind_for_parsed_tvUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id_link_resource?: StringFieldUpdateOperationsInput | string
    file_name_link_resource?: StringFieldUpdateOperationsInput | string
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type bind_for_parsed_tvUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id_link_resource?: StringFieldUpdateOperationsInput | string
    file_name_link_resource?: StringFieldUpdateOperationsInput | string
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type drive_check_inCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    checked_at?: Date | string | null
    drive: driveCreateNestedOneWithoutDrive_check_inInput
  }

  export type drive_check_inUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    checked_at?: Date | string | null
    drive_id: string
  }

  export type drive_check_inUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    checked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    drive?: driveUpdateOneRequiredWithoutDrive_check_inNestedInput
  }

  export type drive_check_inUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    checked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
  }

  export type drive_check_inUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    checked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type drive_check_inUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    checked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
  }

  export type tmp_fileCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    type?: number | null
    parent_paths: string
    drive: driveCreateNestedOneWithoutTmp_filesInput
    user: userCreateNestedOneWithoutTmp_filesInput
  }

  export type tmp_fileUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    type?: number | null
    parent_paths: string
    drive_id: string
    user_id: string
  }

  export type tmp_fileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableFloatFieldUpdateOperationsInput | number | null
    parent_paths?: StringFieldUpdateOperationsInput | string
    drive?: driveUpdateOneRequiredWithoutTmp_filesNestedInput
    user?: userUpdateOneRequiredWithoutTmp_filesNestedInput
  }

  export type tmp_fileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableFloatFieldUpdateOperationsInput | number | null
    parent_paths?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type tmp_fileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableFloatFieldUpdateOperationsInput | number | null
    parent_paths?: StringFieldUpdateOperationsInput | string
  }

  export type tmp_fileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableFloatFieldUpdateOperationsInput | number | null
    parent_paths?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type incomplete_tvCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_count?: number | null
    cur_count?: number | null
    user: userCreateNestedOneWithoutTv_need_completeInput
  }

  export type incomplete_tvUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_count?: number | null
    cur_count?: number | null
    user_id: string
  }

  export type incomplete_tvUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_count?: NullableFloatFieldUpdateOperationsInput | number | null
    cur_count?: NullableFloatFieldUpdateOperationsInput | number | null
    user?: userUpdateOneRequiredWithoutTv_need_completeNestedInput
  }

  export type incomplete_tvUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_count?: NullableFloatFieldUpdateOperationsInput | number | null
    cur_count?: NullableFloatFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type incomplete_tvUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_count?: NullableFloatFieldUpdateOperationsInput | number | null
    cur_count?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type incomplete_tvUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_count?: NullableFloatFieldUpdateOperationsInput | number | null
    cur_count?: NullableFloatFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type fileCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    drive: driveCreateNestedOneWithoutFilesInput
    user: userCreateNestedOneWithoutFilesInput
  }

  export type fileUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    drive_id: string
    user_id: string
  }

  export type fileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    drive?: driveUpdateOneRequiredWithoutFilesNestedInput
    user?: userUpdateOneRequiredWithoutFilesNestedInput
  }

  export type fileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type fileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type fileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type logCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
  }

  export type logUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
  }

  export type logUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type logUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type logUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type logUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
  }

  export type memberCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter?: memberCreateNestedOneWithoutInviteesInput
    user: userCreateNestedOneWithoutMembersInput
    member_setting?: member_settingCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenCreateNestedManyWithoutMemberInput
    play_histories?: play_historyCreateNestedManyWithoutMemberInput
    reports?: reportCreateNestedManyWithoutMemberInput
    invitees?: memberCreateNestedManyWithoutInviterInput
    notifications?: member_notificationCreateNestedManyWithoutMemberInput
  }

  export type memberUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter_id?: string | null
    user_id: string
    member_setting?: member_settingUncheckedCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenUncheckedCreateNestedManyWithoutMemberInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMemberInput
    reports?: reportUncheckedCreateNestedManyWithoutMemberInput
    invitees?: memberUncheckedCreateNestedManyWithoutInviterInput
    notifications?: member_notificationUncheckedCreateNestedManyWithoutMemberInput
  }

  export type memberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter?: memberUpdateOneWithoutInviteesNestedInput
    user?: userUpdateOneRequiredWithoutMembersNestedInput
    member_setting?: member_settingUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUpdateManyWithoutMemberNestedInput
    reports?: reportUpdateManyWithoutMemberNestedInput
    invitees?: memberUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUpdateManyWithoutMemberNestedInput
  }

  export type memberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    member_setting?: member_settingUncheckedUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUncheckedUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutMemberNestedInput
    reports?: reportUncheckedUpdateManyWithoutMemberNestedInput
    invitees?: memberUncheckedUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type memberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type memberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type member_tokenCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    token: string
    used?: number | null
    expired_at?: string | null
    member: memberCreateNestedOneWithoutMember_tokensInput
  }

  export type member_tokenUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    token: string
    used?: number | null
    expired_at?: string | null
    member_id: string
  }

  export type member_tokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    used?: NullableFloatFieldUpdateOperationsInput | number | null
    expired_at?: NullableStringFieldUpdateOperationsInput | string | null
    member?: memberUpdateOneRequiredWithoutMember_tokensNestedInput
  }

  export type member_tokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    used?: NullableFloatFieldUpdateOperationsInput | number | null
    expired_at?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type member_tokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    used?: NullableFloatFieldUpdateOperationsInput | number | null
    expired_at?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type member_tokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    used?: NullableFloatFieldUpdateOperationsInput | number | null
    expired_at?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type member_settingCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    data: string
    member: memberCreateNestedOneWithoutMember_settingInput
  }

  export type member_settingUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    data: string
    member_id: string
  }

  export type member_settingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    member?: memberUpdateOneRequiredWithoutMember_settingNestedInput
  }

  export type member_settingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type member_settingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
  }

  export type member_settingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type permissionCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    desc: string
    code: string
    user: userCreateNestedOneWithoutPermissionInput
  }

  export type permissionUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    desc: string
    code: string
    user_id: string
  }

  export type permissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutPermissionNestedInput
  }

  export type permissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type permissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type permissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type member_notificationCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    content?: string | null
    type?: number | null
    status?: number | null
    is_delete?: number | null
    member: memberCreateNestedOneWithoutNotificationsInput
  }

  export type member_notificationUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    content?: string | null
    type?: number | null
    status?: number | null
    is_delete?: number | null
    member_id: string
  }

  export type member_notificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
    member?: memberUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type member_notificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type member_notificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type member_notificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type notificationCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    content?: string | null
    type?: number | null
    status?: number | null
    is_delete?: number | null
    user: userCreateNestedOneWithoutNotificationsInput
  }

  export type notificationUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    content?: string | null
    type?: number | null
    status?: number | null
    is_delete?: number | null
    user_id: string
  }

  export type notificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
    user?: userUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type notificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type notificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type notificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type reportCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv?: tvCreateNestedOneWithoutReportsInput
    season?: seasonCreateNestedOneWithoutReportsInput
    episode?: episodeCreateNestedOneWithoutReportsInput
    movie?: movieCreateNestedOneWithoutReportsInput
    member: memberCreateNestedOneWithoutReportsInput
    user: userCreateNestedOneWithoutReportsInput
  }

  export type reportUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv_id?: string | null
    season_id?: string | null
    episode_id?: string | null
    movie_id?: string | null
    member_id: string
    user_id: string
  }

  export type reportUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv?: tvUpdateOneWithoutReportsNestedInput
    season?: seasonUpdateOneWithoutReportsNestedInput
    episode?: episodeUpdateOneWithoutReportsNestedInput
    movie?: movieUpdateOneWithoutReportsNestedInput
    member?: memberUpdateOneRequiredWithoutReportsNestedInput
    user?: userUpdateOneRequiredWithoutReportsNestedInput
  }

  export type reportUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type reportUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
  }

  export type reportUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type accountCreateInput = {
    id: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: userCreateNestedOneWithoutAccountsInput
  }

  export type accountUncheckedCreateInput = {
    id: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user_id: string
  }

  export type accountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type accountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type accountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type credentialCreateInput = {
    id: string
    password: string
    salt: string
    verified?: boolean
    email: string
    user: userCreateNestedOneWithoutCredentialInput
  }

  export type credentialUncheckedCreateInput = {
    id: string
    password: string
    salt: string
    verified?: boolean
    email: string
    user_id: string
  }

  export type credentialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutCredentialNestedInput
  }

  export type credentialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type credentialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
  }

  export type credentialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type profileCreateInput = {
    id: string
    nickname?: string | null
    avatar?: string | null
    user: userCreateNestedOneWithoutProfileInput
  }

  export type profileUncheckedCreateInput = {
    id: string
    nickname?: string | null
    avatar?: string | null
    user_id: string
  }

  export type profileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutProfileNestedInput
  }

  export type profileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type profileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type settingsCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    detail?: string | null
    user: userCreateNestedOneWithoutSettingsInput
  }

  export type settingsUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    detail?: string | null
    user_id: string
  }

  export type settingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type settingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type settingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type settingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type userCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type userUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type DateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type IntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type StringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type FloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type DateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type Drive_tokenRelationFilter = {
    is?: drive_tokenWhereInput
    isNot?: drive_tokenWhereInput
  }

  export type UserRelationFilter = {
    is?: userWhereInput
    isNot?: userWhereInput
  }

  export type Parsed_tvListRelationFilter = {
    every?: parsed_tvWhereInput
    some?: parsed_tvWhereInput
    none?: parsed_tvWhereInput
  }

  export type Parsed_seasonListRelationFilter = {
    every?: parsed_seasonWhereInput
    some?: parsed_seasonWhereInput
    none?: parsed_seasonWhereInput
  }

  export type Parsed_episodeListRelationFilter = {
    every?: parsed_episodeWhereInput
    some?: parsed_episodeWhereInput
    none?: parsed_episodeWhereInput
  }

  export type Drive_check_inListRelationFilter = {
    every?: drive_check_inWhereInput
    some?: drive_check_inWhereInput
    none?: drive_check_inWhereInput
  }

  export type FileListRelationFilter = {
    every?: fileWhereInput
    some?: fileWhereInput
    none?: fileWhereInput
  }

  export type Tmp_fileListRelationFilter = {
    every?: tmp_fileWhereInput
    some?: tmp_fileWhereInput
    none?: tmp_fileWhereInput
  }

  export type Parsed_movieListRelationFilter = {
    every?: parsed_movieWhereInput
    some?: parsed_movieWhereInput
    none?: parsed_movieWhereInput
  }

  export type Shared_file_in_progressListRelationFilter = {
    every?: shared_file_in_progressWhereInput
    some?: shared_file_in_progressWhereInput
    none?: shared_file_in_progressWhereInput
  }

  export type SubtitleListRelationFilter = {
    every?: subtitleWhereInput
    some?: subtitleWhereInput
    none?: subtitleWhereInput
  }

  export type Bind_for_parsed_tvListRelationFilter = {
    every?: bind_for_parsed_tvWhereInput
    some?: bind_for_parsed_tvWhereInput
    none?: bind_for_parsed_tvWhereInput
  }

  export type parsed_tvOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type parsed_seasonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type parsed_episodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type drive_check_inOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type fileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tmp_fileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type parsed_movieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type shared_file_in_progressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type subtitleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type bind_for_parsed_tvOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type driveUser_idUnique_idCompoundUniqueInput = {
    user_id: string
    unique_id: string
  }

  export type driveCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    remark?: SortOrder
    avatar?: SortOrder
    profile?: SortOrder
    total_size?: SortOrder
    used_size?: SortOrder
    invalid?: SortOrder
    latest_analysis?: SortOrder
    root_folder_name?: SortOrder
    root_folder_id?: SortOrder
    drive_token_id?: SortOrder
    user_id?: SortOrder
  }

  export type driveAvgOrderByAggregateInput = {
    type?: SortOrder
    total_size?: SortOrder
    used_size?: SortOrder
    invalid?: SortOrder
  }

  export type driveMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    remark?: SortOrder
    avatar?: SortOrder
    profile?: SortOrder
    total_size?: SortOrder
    used_size?: SortOrder
    invalid?: SortOrder
    latest_analysis?: SortOrder
    root_folder_name?: SortOrder
    root_folder_id?: SortOrder
    drive_token_id?: SortOrder
    user_id?: SortOrder
  }

  export type driveMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    type?: SortOrder
    name?: SortOrder
    remark?: SortOrder
    avatar?: SortOrder
    profile?: SortOrder
    total_size?: SortOrder
    used_size?: SortOrder
    invalid?: SortOrder
    latest_analysis?: SortOrder
    root_folder_name?: SortOrder
    root_folder_id?: SortOrder
    drive_token_id?: SortOrder
    user_id?: SortOrder
  }

  export type driveSumOrderByAggregateInput = {
    type?: SortOrder
    total_size?: SortOrder
    used_size?: SortOrder
    invalid?: SortOrder
  }

  export type StringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type DateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type IntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type StringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type FloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type DateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type FloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type DriveListRelationFilter = {
    every?: driveWhereInput
    some?: driveWhereInput
    none?: driveWhereInput
  }

  export type driveOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type drive_tokenCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    expired_at?: SortOrder
  }

  export type drive_tokenAvgOrderByAggregateInput = {
    expired_at?: SortOrder
  }

  export type drive_tokenMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    expired_at?: SortOrder
  }

  export type drive_tokenMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    expired_at?: SortOrder
  }

  export type drive_tokenSumOrderByAggregateInput = {
    expired_at?: SortOrder
  }

  export type FloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type TvListRelationFilter = {
    every?: tvWhereInput
    some?: tvWhereInput
    none?: tvWhereInput
  }

  export type Tv_profile_quickListRelationFilter = {
    every?: tv_profile_quickWhereInput
    some?: tv_profile_quickWhereInput
    none?: tv_profile_quickWhereInput
  }

  export type tvOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tv_profile_quickOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tv_profileCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    backdrop_path?: SortOrder
    first_air_date?: SortOrder
    original_language?: SortOrder
    origin_country?: SortOrder
    genres?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    episode_count?: SortOrder
    season_count?: SortOrder
    status?: SortOrder
    in_production?: SortOrder
  }

  export type tv_profileAvgOrderByAggregateInput = {
    source?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    episode_count?: SortOrder
    season_count?: SortOrder
    in_production?: SortOrder
  }

  export type tv_profileMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    backdrop_path?: SortOrder
    first_air_date?: SortOrder
    original_language?: SortOrder
    origin_country?: SortOrder
    genres?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    episode_count?: SortOrder
    season_count?: SortOrder
    status?: SortOrder
    in_production?: SortOrder
  }

  export type tv_profileMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    backdrop_path?: SortOrder
    first_air_date?: SortOrder
    original_language?: SortOrder
    origin_country?: SortOrder
    genres?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    episode_count?: SortOrder
    season_count?: SortOrder
    status?: SortOrder
    in_production?: SortOrder
  }

  export type tv_profileSumOrderByAggregateInput = {
    source?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    episode_count?: SortOrder
    season_count?: SortOrder
    in_production?: SortOrder
  }

  export type SeasonListRelationFilter = {
    every?: seasonWhereInput
    some?: seasonWhereInput
    none?: seasonWhereInput
  }

  export type seasonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type season_profileCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    season_number?: SortOrder
    air_date?: SortOrder
    episode_count?: SortOrder
    vote_average?: SortOrder
  }

  export type season_profileAvgOrderByAggregateInput = {
    source?: SortOrder
    season_number?: SortOrder
    episode_count?: SortOrder
    vote_average?: SortOrder
  }

  export type season_profileMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    season_number?: SortOrder
    air_date?: SortOrder
    episode_count?: SortOrder
    vote_average?: SortOrder
  }

  export type season_profileMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    season_number?: SortOrder
    air_date?: SortOrder
    episode_count?: SortOrder
    vote_average?: SortOrder
  }

  export type season_profileSumOrderByAggregateInput = {
    source?: SortOrder
    season_number?: SortOrder
    episode_count?: SortOrder
    vote_average?: SortOrder
  }

  export type EpisodeListRelationFilter = {
    every?: episodeWhereInput
    some?: episodeWhereInput
    none?: episodeWhereInput
  }

  export type episodeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type episode_profileCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    air_date?: SortOrder
    runtime?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
  }

  export type episode_profileAvgOrderByAggregateInput = {
    source?: SortOrder
    runtime?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
  }

  export type episode_profileMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    air_date?: SortOrder
    runtime?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
  }

  export type episode_profileMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    overview?: SortOrder
    air_date?: SortOrder
    runtime?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
  }

  export type episode_profileSumOrderByAggregateInput = {
    source?: SortOrder
    runtime?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
  }

  export type MovieListRelationFilter = {
    every?: movieWhereInput
    some?: movieWhereInput
    none?: movieWhereInput
  }

  export type movieOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type movie_profileCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    backdrop_path?: SortOrder
    air_date?: SortOrder
    original_language?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    origin_country?: SortOrder
    genres?: SortOrder
    runtime?: SortOrder
  }

  export type movie_profileAvgOrderByAggregateInput = {
    source?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    runtime?: SortOrder
  }

  export type movie_profileMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    backdrop_path?: SortOrder
    air_date?: SortOrder
    original_language?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    origin_country?: SortOrder
    genres?: SortOrder
    runtime?: SortOrder
  }

  export type movie_profileMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    source?: SortOrder
    sources?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    overview?: SortOrder
    poster_path?: SortOrder
    backdrop_path?: SortOrder
    air_date?: SortOrder
    original_language?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    origin_country?: SortOrder
    genres?: SortOrder
    runtime?: SortOrder
  }

  export type movie_profileSumOrderByAggregateInput = {
    source?: SortOrder
    popularity?: SortOrder
    vote_average?: SortOrder
    vote_count?: SortOrder
    runtime?: SortOrder
  }

  export type MovieRelationFilter = {
    is?: movieWhereInput | null
    isNot?: movieWhereInput | null
  }

  export type EpisodeRelationFilter = {
    is?: episodeWhereInput | null
    isNot?: episodeWhereInput | null
  }

  export type DriveRelationFilter = {
    is?: driveWhereInput
    isNot?: driveWhereInput
  }

  export type subtitleCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    language?: SortOrder
    movie_id?: SortOrder
    episode_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type subtitleMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    language?: SortOrder
    movie_id?: SortOrder
    episode_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type subtitleMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    language?: SortOrder
    movie_id?: SortOrder
    episode_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type TvRelationFilter = {
    is?: tvWhereInput
    isNot?: tvWhereInput
  }

  export type parsed_tvCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    can_search?: SortOrder
    correct_name?: SortOrder
    tmdb_id?: SortOrder
    tv_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_tvAvgOrderByAggregateInput = {
    can_search?: SortOrder
    tmdb_id?: SortOrder
  }

  export type parsed_tvMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    can_search?: SortOrder
    correct_name?: SortOrder
    tmdb_id?: SortOrder
    tv_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_tvMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    can_search?: SortOrder
    correct_name?: SortOrder
    tmdb_id?: SortOrder
    tv_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_tvSumOrderByAggregateInput = {
    can_search?: SortOrder
    tmdb_id?: SortOrder
  }

  export type SeasonRelationFilter = {
    is?: seasonWhereInput | null
    isNot?: seasonWhereInput | null
  }

  export type Parsed_tvRelationFilter = {
    is?: parsed_tvWhereInput
    isNot?: parsed_tvWhereInput
  }

  export type parsed_seasonCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    season_number?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    can_search?: SortOrder
    correct_season_number?: SortOrder
    season_id?: SortOrder
    parsed_tv_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_seasonAvgOrderByAggregateInput = {
    can_search?: SortOrder
  }

  export type parsed_seasonMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    season_number?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    can_search?: SortOrder
    correct_season_number?: SortOrder
    season_id?: SortOrder
    parsed_tv_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_seasonMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    season_number?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    can_search?: SortOrder
    correct_season_number?: SortOrder
    season_id?: SortOrder
    parsed_tv_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_seasonSumOrderByAggregateInput = {
    can_search?: SortOrder
  }

  export type IntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type Parsed_seasonRelationFilter = {
    is?: parsed_seasonWhereInput
    isNot?: parsed_seasonWhereInput
  }

  export type parsed_episodeCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
    name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
    episode_id?: SortOrder
    parsed_tv_id?: SortOrder
    parsed_season_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_episodeAvgOrderByAggregateInput = {
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
  }

  export type parsed_episodeMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
    name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
    episode_id?: SortOrder
    parsed_tv_id?: SortOrder
    parsed_season_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_episodeMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_number?: SortOrder
    season_number?: SortOrder
    name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
    episode_id?: SortOrder
    parsed_tv_id?: SortOrder
    parsed_season_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_episodeSumOrderByAggregateInput = {
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
  }

  export type IntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type parsed_movieCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    correct_name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
    movie_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_movieAvgOrderByAggregateInput = {
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
  }

  export type parsed_movieMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    correct_name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
    movie_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_movieMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    original_name?: SortOrder
    correct_name?: SortOrder
    file_id?: SortOrder
    file_name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
    movie_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type parsed_movieSumOrderByAggregateInput = {
    type?: SortOrder
    size?: SortOrder
    can_search?: SortOrder
  }

  export type Tv_profileRelationFilter = {
    is?: tv_profileWhereInput
    isNot?: tv_profileWhereInput
  }

  export type CollectionRelationFilter = {
    is?: collectionWhereInput | null
    isNot?: collectionWhereInput | null
  }

  export type Play_historyListRelationFilter = {
    every?: play_historyWhereInput
    some?: play_historyWhereInput
    none?: play_historyWhereInput
  }

  export type ReportListRelationFilter = {
    every?: reportWhereInput
    some?: reportWhereInput
    none?: reportWhereInput
  }

  export type play_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type reportOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type tvUser_idProfile_idCompoundUniqueInput = {
    user_id: string
    profile_id: string
  }

  export type tvCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    hidden?: SortOrder
    profile_id?: SortOrder
    collection_id?: SortOrder
    user_id?: SortOrder
  }

  export type tvAvgOrderByAggregateInput = {
    hidden?: SortOrder
  }

  export type tvMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    hidden?: SortOrder
    profile_id?: SortOrder
    collection_id?: SortOrder
    user_id?: SortOrder
  }

  export type tvMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    hidden?: SortOrder
    profile_id?: SortOrder
    collection_id?: SortOrder
    user_id?: SortOrder
  }

  export type tvSumOrderByAggregateInput = {
    hidden?: SortOrder
  }

  export type Season_profileRelationFilter = {
    is?: season_profileWhereInput
    isNot?: season_profileWhereInput
  }

  export type seasonUser_idProfile_idCompoundUniqueInput = {
    user_id: string
    profile_id: string
  }

  export type seasonCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    season_text?: SortOrder
    season_number?: SortOrder
    profile_id?: SortOrder
    collection_id?: SortOrder
    tv_id?: SortOrder
    user_id?: SortOrder
  }

  export type seasonAvgOrderByAggregateInput = {
    season_number?: SortOrder
  }

  export type seasonMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    season_text?: SortOrder
    season_number?: SortOrder
    profile_id?: SortOrder
    collection_id?: SortOrder
    tv_id?: SortOrder
    user_id?: SortOrder
  }

  export type seasonMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    season_text?: SortOrder
    season_number?: SortOrder
    profile_id?: SortOrder
    collection_id?: SortOrder
    tv_id?: SortOrder
    user_id?: SortOrder
  }

  export type seasonSumOrderByAggregateInput = {
    season_number?: SortOrder
  }

  export type Episode_profileRelationFilter = {
    is?: episode_profileWhereInput
    isNot?: episode_profileWhereInput
  }

  export type episodeUser_idProfile_idCompoundUniqueInput = {
    user_id: string
    profile_id: string
  }

  export type episodeCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_text?: SortOrder
    season_text?: SortOrder
    episode_number?: SortOrder
    profile_id?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    user_id?: SortOrder
  }

  export type episodeAvgOrderByAggregateInput = {
    episode_number?: SortOrder
  }

  export type episodeMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_text?: SortOrder
    season_text?: SortOrder
    episode_number?: SortOrder
    profile_id?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    user_id?: SortOrder
  }

  export type episodeMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_text?: SortOrder
    season_text?: SortOrder
    episode_number?: SortOrder
    profile_id?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    user_id?: SortOrder
  }

  export type episodeSumOrderByAggregateInput = {
    episode_number?: SortOrder
  }

  export type Movie_profileRelationFilter = {
    is?: movie_profileWhereInput
    isNot?: movie_profileWhereInput
  }

  export type movieUser_idProfile_idCompoundUniqueInput = {
    user_id: string
    profile_id: string
  }

  export type movieCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    profile_id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
  }

  export type movieMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    profile_id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
  }

  export type movieMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    profile_id?: SortOrder
    user_id?: SortOrder
    collection_id?: SortOrder
  }

  export type collectionCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    type?: SortOrder
    rules?: SortOrder
    sort?: SortOrder
    styles?: SortOrder
    user_id?: SortOrder
  }

  export type collectionAvgOrderByAggregateInput = {
    type?: SortOrder
    sort?: SortOrder
  }

  export type collectionMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    type?: SortOrder
    rules?: SortOrder
    sort?: SortOrder
    styles?: SortOrder
    user_id?: SortOrder
  }

  export type collectionMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
    desc?: SortOrder
    type?: SortOrder
    rules?: SortOrder
    sort?: SortOrder
    styles?: SortOrder
    user_id?: SortOrder
  }

  export type collectionSumOrderByAggregateInput = {
    type?: SortOrder
    sort?: SortOrder
  }

  export type OutputRelationFilter = {
    is?: outputWhereInput | null
    isNot?: outputWhereInput | null
  }

  export type async_taskCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    type?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    need_stop?: SortOrder
    error?: SortOrder
    output_id?: SortOrder
    user_id?: SortOrder
  }

  export type async_taskAvgOrderByAggregateInput = {
    type?: SortOrder
    status?: SortOrder
    need_stop?: SortOrder
  }

  export type async_taskMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    type?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    need_stop?: SortOrder
    error?: SortOrder
    output_id?: SortOrder
    user_id?: SortOrder
  }

  export type async_taskMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    type?: SortOrder
    desc?: SortOrder
    status?: SortOrder
    need_stop?: SortOrder
    error?: SortOrder
    output_id?: SortOrder
    user_id?: SortOrder
  }

  export type async_taskSumOrderByAggregateInput = {
    type?: SortOrder
    status?: SortOrder
    need_stop?: SortOrder
  }

  export type Output_lineListRelationFilter = {
    every?: output_lineWhereInput
    some?: output_lineWhereInput
    none?: output_lineWhereInput
  }

  export type Async_taskRelationFilter = {
    is?: async_taskWhereInput | null
    isNot?: async_taskWhereInput | null
  }

  export type output_lineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type outputCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    user_id?: SortOrder
  }

  export type outputMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    user_id?: SortOrder
  }

  export type outputMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    user_id?: SortOrder
  }

  export type output_lineCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    content?: SortOrder
    output_id?: SortOrder
  }

  export type output_lineMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    content?: SortOrder
    output_id?: SortOrder
  }

  export type output_lineMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    content?: SortOrder
    output_id?: SortOrder
  }

  export type MemberRelationFilter = {
    is?: memberWhereInput | null
    isNot?: memberWhereInput | null
  }

  export type play_historyCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    duration?: SortOrder
    current_time?: SortOrder
    thumbnail?: SortOrder
    file_id?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    episode_id?: SortOrder
    movie_id?: SortOrder
    member_id?: SortOrder
  }

  export type play_historyAvgOrderByAggregateInput = {
    duration?: SortOrder
    current_time?: SortOrder
  }

  export type play_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    duration?: SortOrder
    current_time?: SortOrder
    thumbnail?: SortOrder
    file_id?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    episode_id?: SortOrder
    movie_id?: SortOrder
    member_id?: SortOrder
  }

  export type play_historyMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    duration?: SortOrder
    current_time?: SortOrder
    thumbnail?: SortOrder
    file_id?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    episode_id?: SortOrder
    movie_id?: SortOrder
    member_id?: SortOrder
  }

  export type play_historySumOrderByAggregateInput = {
    duration?: SortOrder
    current_time?: SortOrder
  }

  export type tv_profile_quickCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    tv_profile_id?: SortOrder
  }

  export type tv_profile_quickMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    tv_profile_id?: SortOrder
  }

  export type tv_profile_quickMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    tv_profile_id?: SortOrder
  }

  export type shared_fileCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
    url?: SortOrder
    user_id?: SortOrder
  }

  export type shared_fileMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
    url?: SortOrder
    user_id?: SortOrder
  }

  export type shared_fileMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
    url?: SortOrder
    user_id?: SortOrder
  }

  export type shared_file_in_progressCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    url?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type shared_file_in_progressMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    url?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type shared_file_in_progressMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    url?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type bind_for_parsed_tvCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    url?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    file_id_link_resource?: SortOrder
    file_name_link_resource?: SortOrder
    in_production?: SortOrder
    invalid?: SortOrder
    season_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type bind_for_parsed_tvAvgOrderByAggregateInput = {
    in_production?: SortOrder
    invalid?: SortOrder
  }

  export type bind_for_parsed_tvMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    url?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    file_id_link_resource?: SortOrder
    file_name_link_resource?: SortOrder
    in_production?: SortOrder
    invalid?: SortOrder
    season_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type bind_for_parsed_tvMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    url?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    file_id_link_resource?: SortOrder
    file_name_link_resource?: SortOrder
    in_production?: SortOrder
    invalid?: SortOrder
    season_id?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type bind_for_parsed_tvSumOrderByAggregateInput = {
    in_production?: SortOrder
    invalid?: SortOrder
  }

  export type drive_check_inCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    checked_at?: SortOrder
    drive_id?: SortOrder
  }

  export type drive_check_inMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    checked_at?: SortOrder
    drive_id?: SortOrder
  }

  export type drive_check_inMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    checked_at?: SortOrder
    drive_id?: SortOrder
  }

  export type tmp_fileCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parent_paths?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type tmp_fileAvgOrderByAggregateInput = {
    type?: SortOrder
  }

  export type tmp_fileMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parent_paths?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type tmp_fileMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    name?: SortOrder
    type?: SortOrder
    parent_paths?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type tmp_fileSumOrderByAggregateInput = {
    type?: SortOrder
  }

  export type incomplete_tvCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_count?: SortOrder
    cur_count?: SortOrder
    user_id?: SortOrder
  }

  export type incomplete_tvAvgOrderByAggregateInput = {
    episode_count?: SortOrder
    cur_count?: SortOrder
  }

  export type incomplete_tvMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_count?: SortOrder
    cur_count?: SortOrder
    user_id?: SortOrder
  }

  export type incomplete_tvMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    episode_count?: SortOrder
    cur_count?: SortOrder
    user_id?: SortOrder
  }

  export type incomplete_tvSumOrderByAggregateInput = {
    episode_count?: SortOrder
    cur_count?: SortOrder
  }

  export type fileCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type fileAvgOrderByAggregateInput = {
    type?: SortOrder
    size?: SortOrder
  }

  export type fileMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type fileMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    file_id?: SortOrder
    name?: SortOrder
    parent_file_id?: SortOrder
    parent_paths?: SortOrder
    type?: SortOrder
    size?: SortOrder
    drive_id?: SortOrder
    user_id?: SortOrder
  }

  export type fileSumOrderByAggregateInput = {
    type?: SortOrder
    size?: SortOrder
  }

  export type logCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
  }

  export type logMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
  }

  export type logMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    title?: SortOrder
  }

  export type Member_settingRelationFilter = {
    is?: member_settingWhereInput | null
    isNot?: member_settingWhereInput | null
  }

  export type Member_tokenListRelationFilter = {
    every?: member_tokenWhereInput
    some?: member_tokenWhereInput
    none?: member_tokenWhereInput
  }

  export type MemberListRelationFilter = {
    every?: memberWhereInput
    some?: memberWhereInput
    none?: memberWhereInput
  }

  export type Member_notificationListRelationFilter = {
    every?: member_notificationWhereInput
    some?: member_notificationWhereInput
    none?: member_notificationWhereInput
  }

  export type member_tokenOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type memberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type member_notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type memberUser_idInviter_idRemarkCompoundUniqueInput = {
    user_id: string
    inviter_id: string
    remark: string
  }

  export type memberCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    remark?: SortOrder
    permission?: SortOrder
    disabled?: SortOrder
    delete?: SortOrder
    inviter_id?: SortOrder
    user_id?: SortOrder
  }

  export type memberAvgOrderByAggregateInput = {
    disabled?: SortOrder
    delete?: SortOrder
  }

  export type memberMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    remark?: SortOrder
    permission?: SortOrder
    disabled?: SortOrder
    delete?: SortOrder
    inviter_id?: SortOrder
    user_id?: SortOrder
  }

  export type memberMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    email?: SortOrder
    name?: SortOrder
    avatar?: SortOrder
    remark?: SortOrder
    permission?: SortOrder
    disabled?: SortOrder
    delete?: SortOrder
    inviter_id?: SortOrder
    user_id?: SortOrder
  }

  export type memberSumOrderByAggregateInput = {
    disabled?: SortOrder
    delete?: SortOrder
  }

  export type member_tokenCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    token?: SortOrder
    used?: SortOrder
    expired_at?: SortOrder
    member_id?: SortOrder
  }

  export type member_tokenAvgOrderByAggregateInput = {
    used?: SortOrder
  }

  export type member_tokenMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    token?: SortOrder
    used?: SortOrder
    expired_at?: SortOrder
    member_id?: SortOrder
  }

  export type member_tokenMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    token?: SortOrder
    used?: SortOrder
    expired_at?: SortOrder
    member_id?: SortOrder
  }

  export type member_tokenSumOrderByAggregateInput = {
    used?: SortOrder
  }

  export type member_settingCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    member_id?: SortOrder
  }

  export type member_settingMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    member_id?: SortOrder
  }

  export type member_settingMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    data?: SortOrder
    member_id?: SortOrder
  }

  export type permissionCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    desc?: SortOrder
    code?: SortOrder
    user_id?: SortOrder
  }

  export type permissionMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    desc?: SortOrder
    code?: SortOrder
    user_id?: SortOrder
  }

  export type permissionMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    desc?: SortOrder
    code?: SortOrder
    user_id?: SortOrder
  }

  export type member_notificationCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
    member_id?: SortOrder
  }

  export type member_notificationAvgOrderByAggregateInput = {
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
  }

  export type member_notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
    member_id?: SortOrder
  }

  export type member_notificationMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
    member_id?: SortOrder
  }

  export type member_notificationSumOrderByAggregateInput = {
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
  }

  export type notificationCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
    user_id?: SortOrder
  }

  export type notificationAvgOrderByAggregateInput = {
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
  }

  export type notificationMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
    user_id?: SortOrder
  }

  export type notificationMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    unique_id?: SortOrder
    content?: SortOrder
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
    user_id?: SortOrder
  }

  export type notificationSumOrderByAggregateInput = {
    type?: SortOrder
    status?: SortOrder
    is_delete?: SortOrder
  }

  export type reportCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    type?: SortOrder
    data?: SortOrder
    answer?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    episode_id?: SortOrder
    movie_id?: SortOrder
    member_id?: SortOrder
    user_id?: SortOrder
  }

  export type reportAvgOrderByAggregateInput = {
    type?: SortOrder
  }

  export type reportMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    type?: SortOrder
    data?: SortOrder
    answer?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    episode_id?: SortOrder
    movie_id?: SortOrder
    member_id?: SortOrder
    user_id?: SortOrder
  }

  export type reportMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    type?: SortOrder
    data?: SortOrder
    answer?: SortOrder
    tv_id?: SortOrder
    season_id?: SortOrder
    episode_id?: SortOrder
    movie_id?: SortOrder
    member_id?: SortOrder
    user_id?: SortOrder
  }

  export type reportSumOrderByAggregateInput = {
    type?: SortOrder
  }

  export type accountProviderProvider_account_idCompoundUniqueInput = {
    provider: string
    provider_account_id: string
  }

  export type accountCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    user_id?: SortOrder
  }

  export type accountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type accountMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    user_id?: SortOrder
  }

  export type accountMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    provider_account_id?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
    user_id?: SortOrder
  }

  export type accountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type BoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type credentialCountOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    verified?: SortOrder
    email?: SortOrder
    user_id?: SortOrder
  }

  export type credentialMaxOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    verified?: SortOrder
    email?: SortOrder
    user_id?: SortOrder
  }

  export type credentialMinOrderByAggregateInput = {
    id?: SortOrder
    password?: SortOrder
    salt?: SortOrder
    verified?: SortOrder
    email?: SortOrder
    user_id?: SortOrder
  }

  export type BoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type profileCountOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    avatar?: SortOrder
    user_id?: SortOrder
  }

  export type profileMaxOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    avatar?: SortOrder
    user_id?: SortOrder
  }

  export type profileMinOrderByAggregateInput = {
    id?: SortOrder
    nickname?: SortOrder
    avatar?: SortOrder
    user_id?: SortOrder
  }

  export type settingsCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    detail?: SortOrder
    user_id?: SortOrder
  }

  export type settingsMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    detail?: SortOrder
    user_id?: SortOrder
  }

  export type settingsMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
    detail?: SortOrder
    user_id?: SortOrder
  }

  export type CredentialRelationFilter = {
    is?: credentialWhereInput | null
    isNot?: credentialWhereInput | null
  }

  export type ProfileRelationFilter = {
    is?: profileWhereInput | null
    isNot?: profileWhereInput | null
  }

  export type SettingsRelationFilter = {
    is?: settingsWhereInput | null
    isNot?: settingsWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: accountWhereInput
    some?: accountWhereInput
    none?: accountWhereInput
  }

  export type Incomplete_tvListRelationFilter = {
    every?: incomplete_tvWhereInput
    some?: incomplete_tvWhereInput
    none?: incomplete_tvWhereInput
  }

  export type Async_taskListRelationFilter = {
    every?: async_taskWhereInput
    some?: async_taskWhereInput
    none?: async_taskWhereInput
  }

  export type Shared_fileListRelationFilter = {
    every?: shared_fileWhereInput
    some?: shared_fileWhereInput
    none?: shared_fileWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: notificationWhereInput
    some?: notificationWhereInput
    none?: notificationWhereInput
  }

  export type OutputListRelationFilter = {
    every?: outputWhereInput
    some?: outputWhereInput
    none?: outputWhereInput
  }

  export type CollectionListRelationFilter = {
    every?: collectionWhereInput
    some?: collectionWhereInput
    none?: collectionWhereInput
  }

  export type PermissionListRelationFilter = {
    every?: permissionWhereInput
    some?: permissionWhereInput
    none?: permissionWhereInput
  }

  export type accountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type incomplete_tvOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type async_taskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type shared_fileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type notificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type outputOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type collectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type permissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type userCountOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type userMaxOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type userMinOrderByAggregateInput = {
    id?: SortOrder
    created?: SortOrder
    updated?: SortOrder
  }

  export type drive_tokenCreateNestedOneWithoutDrivesInput = {
    create?: XOR<drive_tokenCreateWithoutDrivesInput, drive_tokenUncheckedCreateWithoutDrivesInput>
    connectOrCreate?: drive_tokenCreateOrConnectWithoutDrivesInput
    connect?: drive_tokenWhereUniqueInput
  }

  export type userCreateNestedOneWithoutDrivesInput = {
    create?: XOR<userCreateWithoutDrivesInput, userUncheckedCreateWithoutDrivesInput>
    connectOrCreate?: userCreateOrConnectWithoutDrivesInput
    connect?: userWhereUniqueInput
  }

  export type parsed_tvCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutDriveInput>, Enumerable<parsed_tvUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
  }

  export type parsed_seasonCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutDriveInput>, Enumerable<parsed_seasonUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
  }

  export type parsed_episodeCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutDriveInput>, Enumerable<parsed_episodeUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
  }

  export type drive_check_inCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<drive_check_inCreateWithoutDriveInput>, Enumerable<drive_check_inUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<drive_check_inCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<drive_check_inWhereUniqueInput>
  }

  export type fileCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<fileCreateWithoutDriveInput>, Enumerable<fileUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<fileCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<fileWhereUniqueInput>
  }

  export type tmp_fileCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<tmp_fileCreateWithoutDriveInput>, Enumerable<tmp_fileUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<tmp_fileCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<tmp_fileWhereUniqueInput>
  }

  export type parsed_movieCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutDriveInput>, Enumerable<parsed_movieUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
  }

  export type shared_file_in_progressCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<shared_file_in_progressCreateWithoutDriveInput>, Enumerable<shared_file_in_progressUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<shared_file_in_progressCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<shared_file_in_progressWhereUniqueInput>
  }

  export type subtitleCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutDriveInput>, Enumerable<subtitleUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
  }

  export type bind_for_parsed_tvCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutDriveInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
  }

  export type parsed_tvUncheckedCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutDriveInput>, Enumerable<parsed_tvUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
  }

  export type parsed_seasonUncheckedCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutDriveInput>, Enumerable<parsed_seasonUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
  }

  export type parsed_episodeUncheckedCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutDriveInput>, Enumerable<parsed_episodeUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
  }

  export type drive_check_inUncheckedCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<drive_check_inCreateWithoutDriveInput>, Enumerable<drive_check_inUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<drive_check_inCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<drive_check_inWhereUniqueInput>
  }

  export type fileUncheckedCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<fileCreateWithoutDriveInput>, Enumerable<fileUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<fileCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<fileWhereUniqueInput>
  }

  export type tmp_fileUncheckedCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<tmp_fileCreateWithoutDriveInput>, Enumerable<tmp_fileUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<tmp_fileCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<tmp_fileWhereUniqueInput>
  }

  export type parsed_movieUncheckedCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutDriveInput>, Enumerable<parsed_movieUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
  }

  export type shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<shared_file_in_progressCreateWithoutDriveInput>, Enumerable<shared_file_in_progressUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<shared_file_in_progressCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<shared_file_in_progressWhereUniqueInput>
  }

  export type subtitleUncheckedCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutDriveInput>, Enumerable<subtitleUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
  }

  export type bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutDriveInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutDriveInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type drive_tokenUpdateOneRequiredWithoutDrivesNestedInput = {
    create?: XOR<drive_tokenCreateWithoutDrivesInput, drive_tokenUncheckedCreateWithoutDrivesInput>
    connectOrCreate?: drive_tokenCreateOrConnectWithoutDrivesInput
    upsert?: drive_tokenUpsertWithoutDrivesInput
    connect?: drive_tokenWhereUniqueInput
    update?: XOR<drive_tokenUpdateWithoutDrivesInput, drive_tokenUncheckedUpdateWithoutDrivesInput>
  }

  export type userUpdateOneRequiredWithoutDrivesNestedInput = {
    create?: XOR<userCreateWithoutDrivesInput, userUncheckedCreateWithoutDrivesInput>
    connectOrCreate?: userCreateOrConnectWithoutDrivesInput
    upsert?: userUpsertWithoutDrivesInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutDrivesInput, userUncheckedUpdateWithoutDrivesInput>
  }

  export type parsed_tvUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutDriveInput>, Enumerable<parsed_tvUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<parsed_tvUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<parsed_tvWhereUniqueInput>
    delete?: Enumerable<parsed_tvWhereUniqueInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
    update?: Enumerable<parsed_tvUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<parsed_tvUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<parsed_tvScalarWhereInput>
  }

  export type parsed_seasonUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutDriveInput>, Enumerable<parsed_seasonUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<parsed_seasonUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<parsed_seasonWhereUniqueInput>
    disconnect?: Enumerable<parsed_seasonWhereUniqueInput>
    delete?: Enumerable<parsed_seasonWhereUniqueInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
    update?: Enumerable<parsed_seasonUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<parsed_seasonUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<parsed_seasonScalarWhereInput>
  }

  export type parsed_episodeUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutDriveInput>, Enumerable<parsed_episodeUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<parsed_episodeUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<parsed_episodeWhereUniqueInput>
    disconnect?: Enumerable<parsed_episodeWhereUniqueInput>
    delete?: Enumerable<parsed_episodeWhereUniqueInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
    update?: Enumerable<parsed_episodeUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<parsed_episodeUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<parsed_episodeScalarWhereInput>
  }

  export type drive_check_inUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<drive_check_inCreateWithoutDriveInput>, Enumerable<drive_check_inUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<drive_check_inCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<drive_check_inUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<drive_check_inWhereUniqueInput>
    disconnect?: Enumerable<drive_check_inWhereUniqueInput>
    delete?: Enumerable<drive_check_inWhereUniqueInput>
    connect?: Enumerable<drive_check_inWhereUniqueInput>
    update?: Enumerable<drive_check_inUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<drive_check_inUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<drive_check_inScalarWhereInput>
  }

  export type fileUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<fileCreateWithoutDriveInput>, Enumerable<fileUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<fileCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<fileUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<fileWhereUniqueInput>
    disconnect?: Enumerable<fileWhereUniqueInput>
    delete?: Enumerable<fileWhereUniqueInput>
    connect?: Enumerable<fileWhereUniqueInput>
    update?: Enumerable<fileUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<fileUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<fileScalarWhereInput>
  }

  export type tmp_fileUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<tmp_fileCreateWithoutDriveInput>, Enumerable<tmp_fileUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<tmp_fileCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<tmp_fileUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<tmp_fileWhereUniqueInput>
    disconnect?: Enumerable<tmp_fileWhereUniqueInput>
    delete?: Enumerable<tmp_fileWhereUniqueInput>
    connect?: Enumerable<tmp_fileWhereUniqueInput>
    update?: Enumerable<tmp_fileUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<tmp_fileUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<tmp_fileScalarWhereInput>
  }

  export type parsed_movieUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutDriveInput>, Enumerable<parsed_movieUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<parsed_movieUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<parsed_movieWhereUniqueInput>
    disconnect?: Enumerable<parsed_movieWhereUniqueInput>
    delete?: Enumerable<parsed_movieWhereUniqueInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
    update?: Enumerable<parsed_movieUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<parsed_movieUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<parsed_movieScalarWhereInput>
  }

  export type shared_file_in_progressUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<shared_file_in_progressCreateWithoutDriveInput>, Enumerable<shared_file_in_progressUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<shared_file_in_progressCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<shared_file_in_progressUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<shared_file_in_progressWhereUniqueInput>
    disconnect?: Enumerable<shared_file_in_progressWhereUniqueInput>
    delete?: Enumerable<shared_file_in_progressWhereUniqueInput>
    connect?: Enumerable<shared_file_in_progressWhereUniqueInput>
    update?: Enumerable<shared_file_in_progressUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<shared_file_in_progressUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<shared_file_in_progressScalarWhereInput>
  }

  export type subtitleUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutDriveInput>, Enumerable<subtitleUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<subtitleUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<subtitleWhereUniqueInput>
    disconnect?: Enumerable<subtitleWhereUniqueInput>
    delete?: Enumerable<subtitleWhereUniqueInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
    update?: Enumerable<subtitleUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<subtitleUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<subtitleScalarWhereInput>
  }

  export type bind_for_parsed_tvUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutDriveInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<bind_for_parsed_tvUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    delete?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    update?: Enumerable<bind_for_parsed_tvUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<bind_for_parsed_tvUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<bind_for_parsed_tvScalarWhereInput>
  }

  export type parsed_tvUncheckedUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutDriveInput>, Enumerable<parsed_tvUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<parsed_tvUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<parsed_tvWhereUniqueInput>
    delete?: Enumerable<parsed_tvWhereUniqueInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
    update?: Enumerable<parsed_tvUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<parsed_tvUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<parsed_tvScalarWhereInput>
  }

  export type parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutDriveInput>, Enumerable<parsed_seasonUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<parsed_seasonUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<parsed_seasonWhereUniqueInput>
    disconnect?: Enumerable<parsed_seasonWhereUniqueInput>
    delete?: Enumerable<parsed_seasonWhereUniqueInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
    update?: Enumerable<parsed_seasonUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<parsed_seasonUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<parsed_seasonScalarWhereInput>
  }

  export type parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutDriveInput>, Enumerable<parsed_episodeUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<parsed_episodeUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<parsed_episodeWhereUniqueInput>
    disconnect?: Enumerable<parsed_episodeWhereUniqueInput>
    delete?: Enumerable<parsed_episodeWhereUniqueInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
    update?: Enumerable<parsed_episodeUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<parsed_episodeUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<parsed_episodeScalarWhereInput>
  }

  export type drive_check_inUncheckedUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<drive_check_inCreateWithoutDriveInput>, Enumerable<drive_check_inUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<drive_check_inCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<drive_check_inUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<drive_check_inWhereUniqueInput>
    disconnect?: Enumerable<drive_check_inWhereUniqueInput>
    delete?: Enumerable<drive_check_inWhereUniqueInput>
    connect?: Enumerable<drive_check_inWhereUniqueInput>
    update?: Enumerable<drive_check_inUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<drive_check_inUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<drive_check_inScalarWhereInput>
  }

  export type fileUncheckedUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<fileCreateWithoutDriveInput>, Enumerable<fileUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<fileCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<fileUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<fileWhereUniqueInput>
    disconnect?: Enumerable<fileWhereUniqueInput>
    delete?: Enumerable<fileWhereUniqueInput>
    connect?: Enumerable<fileWhereUniqueInput>
    update?: Enumerable<fileUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<fileUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<fileScalarWhereInput>
  }

  export type tmp_fileUncheckedUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<tmp_fileCreateWithoutDriveInput>, Enumerable<tmp_fileUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<tmp_fileCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<tmp_fileUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<tmp_fileWhereUniqueInput>
    disconnect?: Enumerable<tmp_fileWhereUniqueInput>
    delete?: Enumerable<tmp_fileWhereUniqueInput>
    connect?: Enumerable<tmp_fileWhereUniqueInput>
    update?: Enumerable<tmp_fileUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<tmp_fileUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<tmp_fileScalarWhereInput>
  }

  export type parsed_movieUncheckedUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutDriveInput>, Enumerable<parsed_movieUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<parsed_movieUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<parsed_movieWhereUniqueInput>
    disconnect?: Enumerable<parsed_movieWhereUniqueInput>
    delete?: Enumerable<parsed_movieWhereUniqueInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
    update?: Enumerable<parsed_movieUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<parsed_movieUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<parsed_movieScalarWhereInput>
  }

  export type shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<shared_file_in_progressCreateWithoutDriveInput>, Enumerable<shared_file_in_progressUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<shared_file_in_progressCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<shared_file_in_progressUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<shared_file_in_progressWhereUniqueInput>
    disconnect?: Enumerable<shared_file_in_progressWhereUniqueInput>
    delete?: Enumerable<shared_file_in_progressWhereUniqueInput>
    connect?: Enumerable<shared_file_in_progressWhereUniqueInput>
    update?: Enumerable<shared_file_in_progressUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<shared_file_in_progressUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<shared_file_in_progressScalarWhereInput>
  }

  export type subtitleUncheckedUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutDriveInput>, Enumerable<subtitleUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<subtitleUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<subtitleWhereUniqueInput>
    disconnect?: Enumerable<subtitleWhereUniqueInput>
    delete?: Enumerable<subtitleWhereUniqueInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
    update?: Enumerable<subtitleUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<subtitleUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<subtitleScalarWhereInput>
  }

  export type bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutDriveInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutDriveInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutDriveInput>
    upsert?: Enumerable<bind_for_parsed_tvUpsertWithWhereUniqueWithoutDriveInput>
    set?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    delete?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    update?: Enumerable<bind_for_parsed_tvUpdateWithWhereUniqueWithoutDriveInput>
    updateMany?: Enumerable<bind_for_parsed_tvUpdateManyWithWhereWithoutDriveInput>
    deleteMany?: Enumerable<bind_for_parsed_tvScalarWhereInput>
  }

  export type driveCreateNestedManyWithoutDrive_tokenInput = {
    create?: XOR<Enumerable<driveCreateWithoutDrive_tokenInput>, Enumerable<driveUncheckedCreateWithoutDrive_tokenInput>>
    connectOrCreate?: Enumerable<driveCreateOrConnectWithoutDrive_tokenInput>
    connect?: Enumerable<driveWhereUniqueInput>
  }

  export type driveUncheckedCreateNestedManyWithoutDrive_tokenInput = {
    create?: XOR<Enumerable<driveCreateWithoutDrive_tokenInput>, Enumerable<driveUncheckedCreateWithoutDrive_tokenInput>>
    connectOrCreate?: Enumerable<driveCreateOrConnectWithoutDrive_tokenInput>
    connect?: Enumerable<driveWhereUniqueInput>
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type driveUpdateManyWithoutDrive_tokenNestedInput = {
    create?: XOR<Enumerable<driveCreateWithoutDrive_tokenInput>, Enumerable<driveUncheckedCreateWithoutDrive_tokenInput>>
    connectOrCreate?: Enumerable<driveCreateOrConnectWithoutDrive_tokenInput>
    upsert?: Enumerable<driveUpsertWithWhereUniqueWithoutDrive_tokenInput>
    set?: Enumerable<driveWhereUniqueInput>
    disconnect?: Enumerable<driveWhereUniqueInput>
    delete?: Enumerable<driveWhereUniqueInput>
    connect?: Enumerable<driveWhereUniqueInput>
    update?: Enumerable<driveUpdateWithWhereUniqueWithoutDrive_tokenInput>
    updateMany?: Enumerable<driveUpdateManyWithWhereWithoutDrive_tokenInput>
    deleteMany?: Enumerable<driveScalarWhereInput>
  }

  export type driveUncheckedUpdateManyWithoutDrive_tokenNestedInput = {
    create?: XOR<Enumerable<driveCreateWithoutDrive_tokenInput>, Enumerable<driveUncheckedCreateWithoutDrive_tokenInput>>
    connectOrCreate?: Enumerable<driveCreateOrConnectWithoutDrive_tokenInput>
    upsert?: Enumerable<driveUpsertWithWhereUniqueWithoutDrive_tokenInput>
    set?: Enumerable<driveWhereUniqueInput>
    disconnect?: Enumerable<driveWhereUniqueInput>
    delete?: Enumerable<driveWhereUniqueInput>
    connect?: Enumerable<driveWhereUniqueInput>
    update?: Enumerable<driveUpdateWithWhereUniqueWithoutDrive_tokenInput>
    updateMany?: Enumerable<driveUpdateManyWithWhereWithoutDrive_tokenInput>
    deleteMany?: Enumerable<driveScalarWhereInput>
  }

  export type tvCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<tvCreateWithoutProfileInput>, Enumerable<tvUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutProfileInput>
    connect?: Enumerable<tvWhereUniqueInput>
  }

  export type tv_profile_quickCreateNestedManyWithoutTv_profileInput = {
    create?: XOR<Enumerable<tv_profile_quickCreateWithoutTv_profileInput>, Enumerable<tv_profile_quickUncheckedCreateWithoutTv_profileInput>>
    connectOrCreate?: Enumerable<tv_profile_quickCreateOrConnectWithoutTv_profileInput>
    connect?: Enumerable<tv_profile_quickWhereUniqueInput>
  }

  export type tvUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<tvCreateWithoutProfileInput>, Enumerable<tvUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutProfileInput>
    connect?: Enumerable<tvWhereUniqueInput>
  }

  export type tv_profile_quickUncheckedCreateNestedManyWithoutTv_profileInput = {
    create?: XOR<Enumerable<tv_profile_quickCreateWithoutTv_profileInput>, Enumerable<tv_profile_quickUncheckedCreateWithoutTv_profileInput>>
    connectOrCreate?: Enumerable<tv_profile_quickCreateOrConnectWithoutTv_profileInput>
    connect?: Enumerable<tv_profile_quickWhereUniqueInput>
  }

  export type tvUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<tvCreateWithoutProfileInput>, Enumerable<tvUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<tvUpsertWithWhereUniqueWithoutProfileInput>
    set?: Enumerable<tvWhereUniqueInput>
    disconnect?: Enumerable<tvWhereUniqueInput>
    delete?: Enumerable<tvWhereUniqueInput>
    connect?: Enumerable<tvWhereUniqueInput>
    update?: Enumerable<tvUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<tvUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<tvScalarWhereInput>
  }

  export type tv_profile_quickUpdateManyWithoutTv_profileNestedInput = {
    create?: XOR<Enumerable<tv_profile_quickCreateWithoutTv_profileInput>, Enumerable<tv_profile_quickUncheckedCreateWithoutTv_profileInput>>
    connectOrCreate?: Enumerable<tv_profile_quickCreateOrConnectWithoutTv_profileInput>
    upsert?: Enumerable<tv_profile_quickUpsertWithWhereUniqueWithoutTv_profileInput>
    set?: Enumerable<tv_profile_quickWhereUniqueInput>
    disconnect?: Enumerable<tv_profile_quickWhereUniqueInput>
    delete?: Enumerable<tv_profile_quickWhereUniqueInput>
    connect?: Enumerable<tv_profile_quickWhereUniqueInput>
    update?: Enumerable<tv_profile_quickUpdateWithWhereUniqueWithoutTv_profileInput>
    updateMany?: Enumerable<tv_profile_quickUpdateManyWithWhereWithoutTv_profileInput>
    deleteMany?: Enumerable<tv_profile_quickScalarWhereInput>
  }

  export type tvUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<tvCreateWithoutProfileInput>, Enumerable<tvUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<tvUpsertWithWhereUniqueWithoutProfileInput>
    set?: Enumerable<tvWhereUniqueInput>
    disconnect?: Enumerable<tvWhereUniqueInput>
    delete?: Enumerable<tvWhereUniqueInput>
    connect?: Enumerable<tvWhereUniqueInput>
    update?: Enumerable<tvUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<tvUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<tvScalarWhereInput>
  }

  export type tv_profile_quickUncheckedUpdateManyWithoutTv_profileNestedInput = {
    create?: XOR<Enumerable<tv_profile_quickCreateWithoutTv_profileInput>, Enumerable<tv_profile_quickUncheckedCreateWithoutTv_profileInput>>
    connectOrCreate?: Enumerable<tv_profile_quickCreateOrConnectWithoutTv_profileInput>
    upsert?: Enumerable<tv_profile_quickUpsertWithWhereUniqueWithoutTv_profileInput>
    set?: Enumerable<tv_profile_quickWhereUniqueInput>
    disconnect?: Enumerable<tv_profile_quickWhereUniqueInput>
    delete?: Enumerable<tv_profile_quickWhereUniqueInput>
    connect?: Enumerable<tv_profile_quickWhereUniqueInput>
    update?: Enumerable<tv_profile_quickUpdateWithWhereUniqueWithoutTv_profileInput>
    updateMany?: Enumerable<tv_profile_quickUpdateManyWithWhereWithoutTv_profileInput>
    deleteMany?: Enumerable<tv_profile_quickScalarWhereInput>
  }

  export type seasonCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<seasonCreateWithoutProfileInput>, Enumerable<seasonUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutProfileInput>
    connect?: Enumerable<seasonWhereUniqueInput>
  }

  export type seasonUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<seasonCreateWithoutProfileInput>, Enumerable<seasonUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutProfileInput>
    connect?: Enumerable<seasonWhereUniqueInput>
  }

  export type seasonUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<seasonCreateWithoutProfileInput>, Enumerable<seasonUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<seasonUpsertWithWhereUniqueWithoutProfileInput>
    set?: Enumerable<seasonWhereUniqueInput>
    disconnect?: Enumerable<seasonWhereUniqueInput>
    delete?: Enumerable<seasonWhereUniqueInput>
    connect?: Enumerable<seasonWhereUniqueInput>
    update?: Enumerable<seasonUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<seasonUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<seasonScalarWhereInput>
  }

  export type seasonUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<seasonCreateWithoutProfileInput>, Enumerable<seasonUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<seasonUpsertWithWhereUniqueWithoutProfileInput>
    set?: Enumerable<seasonWhereUniqueInput>
    disconnect?: Enumerable<seasonWhereUniqueInput>
    delete?: Enumerable<seasonWhereUniqueInput>
    connect?: Enumerable<seasonWhereUniqueInput>
    update?: Enumerable<seasonUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<seasonUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<seasonScalarWhereInput>
  }

  export type episodeCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<episodeCreateWithoutProfileInput>, Enumerable<episodeUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutProfileInput>
    connect?: Enumerable<episodeWhereUniqueInput>
  }

  export type episodeUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<episodeCreateWithoutProfileInput>, Enumerable<episodeUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutProfileInput>
    connect?: Enumerable<episodeWhereUniqueInput>
  }

  export type episodeUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<episodeCreateWithoutProfileInput>, Enumerable<episodeUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<episodeUpsertWithWhereUniqueWithoutProfileInput>
    set?: Enumerable<episodeWhereUniqueInput>
    disconnect?: Enumerable<episodeWhereUniqueInput>
    delete?: Enumerable<episodeWhereUniqueInput>
    connect?: Enumerable<episodeWhereUniqueInput>
    update?: Enumerable<episodeUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<episodeUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<episodeScalarWhereInput>
  }

  export type episodeUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<episodeCreateWithoutProfileInput>, Enumerable<episodeUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<episodeUpsertWithWhereUniqueWithoutProfileInput>
    set?: Enumerable<episodeWhereUniqueInput>
    disconnect?: Enumerable<episodeWhereUniqueInput>
    delete?: Enumerable<episodeWhereUniqueInput>
    connect?: Enumerable<episodeWhereUniqueInput>
    update?: Enumerable<episodeUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<episodeUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<episodeScalarWhereInput>
  }

  export type movieCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<movieCreateWithoutProfileInput>, Enumerable<movieUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutProfileInput>
    connect?: Enumerable<movieWhereUniqueInput>
  }

  export type movieUncheckedCreateNestedManyWithoutProfileInput = {
    create?: XOR<Enumerable<movieCreateWithoutProfileInput>, Enumerable<movieUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutProfileInput>
    connect?: Enumerable<movieWhereUniqueInput>
  }

  export type movieUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<movieCreateWithoutProfileInput>, Enumerable<movieUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<movieUpsertWithWhereUniqueWithoutProfileInput>
    set?: Enumerable<movieWhereUniqueInput>
    disconnect?: Enumerable<movieWhereUniqueInput>
    delete?: Enumerable<movieWhereUniqueInput>
    connect?: Enumerable<movieWhereUniqueInput>
    update?: Enumerable<movieUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<movieUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<movieScalarWhereInput>
  }

  export type movieUncheckedUpdateManyWithoutProfileNestedInput = {
    create?: XOR<Enumerable<movieCreateWithoutProfileInput>, Enumerable<movieUncheckedCreateWithoutProfileInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutProfileInput>
    upsert?: Enumerable<movieUpsertWithWhereUniqueWithoutProfileInput>
    set?: Enumerable<movieWhereUniqueInput>
    disconnect?: Enumerable<movieWhereUniqueInput>
    delete?: Enumerable<movieWhereUniqueInput>
    connect?: Enumerable<movieWhereUniqueInput>
    update?: Enumerable<movieUpdateWithWhereUniqueWithoutProfileInput>
    updateMany?: Enumerable<movieUpdateManyWithWhereWithoutProfileInput>
    deleteMany?: Enumerable<movieScalarWhereInput>
  }

  export type movieCreateNestedOneWithoutSubtitlesInput = {
    create?: XOR<movieCreateWithoutSubtitlesInput, movieUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: movieCreateOrConnectWithoutSubtitlesInput
    connect?: movieWhereUniqueInput
  }

  export type episodeCreateNestedOneWithoutSubtitlesInput = {
    create?: XOR<episodeCreateWithoutSubtitlesInput, episodeUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: episodeCreateOrConnectWithoutSubtitlesInput
    connect?: episodeWhereUniqueInput
  }

  export type driveCreateNestedOneWithoutSubtitlesInput = {
    create?: XOR<driveCreateWithoutSubtitlesInput, driveUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: driveCreateOrConnectWithoutSubtitlesInput
    connect?: driveWhereUniqueInput
  }

  export type userCreateNestedOneWithoutSubtitlesInput = {
    create?: XOR<userCreateWithoutSubtitlesInput, userUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: userCreateOrConnectWithoutSubtitlesInput
    connect?: userWhereUniqueInput
  }

  export type movieUpdateOneWithoutSubtitlesNestedInput = {
    create?: XOR<movieCreateWithoutSubtitlesInput, movieUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: movieCreateOrConnectWithoutSubtitlesInput
    upsert?: movieUpsertWithoutSubtitlesInput
    disconnect?: boolean
    delete?: boolean
    connect?: movieWhereUniqueInput
    update?: XOR<movieUpdateWithoutSubtitlesInput, movieUncheckedUpdateWithoutSubtitlesInput>
  }

  export type episodeUpdateOneWithoutSubtitlesNestedInput = {
    create?: XOR<episodeCreateWithoutSubtitlesInput, episodeUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: episodeCreateOrConnectWithoutSubtitlesInput
    upsert?: episodeUpsertWithoutSubtitlesInput
    disconnect?: boolean
    delete?: boolean
    connect?: episodeWhereUniqueInput
    update?: XOR<episodeUpdateWithoutSubtitlesInput, episodeUncheckedUpdateWithoutSubtitlesInput>
  }

  export type driveUpdateOneRequiredWithoutSubtitlesNestedInput = {
    create?: XOR<driveCreateWithoutSubtitlesInput, driveUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: driveCreateOrConnectWithoutSubtitlesInput
    upsert?: driveUpsertWithoutSubtitlesInput
    connect?: driveWhereUniqueInput
    update?: XOR<driveUpdateWithoutSubtitlesInput, driveUncheckedUpdateWithoutSubtitlesInput>
  }

  export type userUpdateOneRequiredWithoutSubtitlesNestedInput = {
    create?: XOR<userCreateWithoutSubtitlesInput, userUncheckedCreateWithoutSubtitlesInput>
    connectOrCreate?: userCreateOrConnectWithoutSubtitlesInput
    upsert?: userUpsertWithoutSubtitlesInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutSubtitlesInput, userUncheckedUpdateWithoutSubtitlesInput>
  }

  export type tvCreateNestedOneWithoutParsed_tvsInput = {
    create?: XOR<tvCreateWithoutParsed_tvsInput, tvUncheckedCreateWithoutParsed_tvsInput>
    connectOrCreate?: tvCreateOrConnectWithoutParsed_tvsInput
    connect?: tvWhereUniqueInput
  }

  export type driveCreateNestedOneWithoutParsed_tvsInput = {
    create?: XOR<driveCreateWithoutParsed_tvsInput, driveUncheckedCreateWithoutParsed_tvsInput>
    connectOrCreate?: driveCreateOrConnectWithoutParsed_tvsInput
    connect?: driveWhereUniqueInput
  }

  export type userCreateNestedOneWithoutParsed_tvsInput = {
    create?: XOR<userCreateWithoutParsed_tvsInput, userUncheckedCreateWithoutParsed_tvsInput>
    connectOrCreate?: userCreateOrConnectWithoutParsed_tvsInput
    connect?: userWhereUniqueInput
  }

  export type parsed_episodeCreateNestedManyWithoutParsed_tvInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutParsed_tvInput>, Enumerable<parsed_episodeUncheckedCreateWithoutParsed_tvInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutParsed_tvInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
  }

  export type parsed_seasonCreateNestedManyWithoutParsed_tvInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutParsed_tvInput>, Enumerable<parsed_seasonUncheckedCreateWithoutParsed_tvInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutParsed_tvInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
  }

  export type parsed_episodeUncheckedCreateNestedManyWithoutParsed_tvInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutParsed_tvInput>, Enumerable<parsed_episodeUncheckedCreateWithoutParsed_tvInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutParsed_tvInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
  }

  export type parsed_seasonUncheckedCreateNestedManyWithoutParsed_tvInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutParsed_tvInput>, Enumerable<parsed_seasonUncheckedCreateWithoutParsed_tvInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutParsed_tvInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
  }

  export type tvUpdateOneWithoutParsed_tvsNestedInput = {
    create?: XOR<tvCreateWithoutParsed_tvsInput, tvUncheckedCreateWithoutParsed_tvsInput>
    connectOrCreate?: tvCreateOrConnectWithoutParsed_tvsInput
    upsert?: tvUpsertWithoutParsed_tvsInput
    disconnect?: boolean
    delete?: boolean
    connect?: tvWhereUniqueInput
    update?: XOR<tvUpdateWithoutParsed_tvsInput, tvUncheckedUpdateWithoutParsed_tvsInput>
  }

  export type driveUpdateOneRequiredWithoutParsed_tvsNestedInput = {
    create?: XOR<driveCreateWithoutParsed_tvsInput, driveUncheckedCreateWithoutParsed_tvsInput>
    connectOrCreate?: driveCreateOrConnectWithoutParsed_tvsInput
    upsert?: driveUpsertWithoutParsed_tvsInput
    connect?: driveWhereUniqueInput
    update?: XOR<driveUpdateWithoutParsed_tvsInput, driveUncheckedUpdateWithoutParsed_tvsInput>
  }

  export type userUpdateOneRequiredWithoutParsed_tvsNestedInput = {
    create?: XOR<userCreateWithoutParsed_tvsInput, userUncheckedCreateWithoutParsed_tvsInput>
    connectOrCreate?: userCreateOrConnectWithoutParsed_tvsInput
    upsert?: userUpsertWithoutParsed_tvsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutParsed_tvsInput, userUncheckedUpdateWithoutParsed_tvsInput>
  }

  export type parsed_episodeUpdateManyWithoutParsed_tvNestedInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutParsed_tvInput>, Enumerable<parsed_episodeUncheckedCreateWithoutParsed_tvInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutParsed_tvInput>
    upsert?: Enumerable<parsed_episodeUpsertWithWhereUniqueWithoutParsed_tvInput>
    set?: Enumerable<parsed_episodeWhereUniqueInput>
    disconnect?: Enumerable<parsed_episodeWhereUniqueInput>
    delete?: Enumerable<parsed_episodeWhereUniqueInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
    update?: Enumerable<parsed_episodeUpdateWithWhereUniqueWithoutParsed_tvInput>
    updateMany?: Enumerable<parsed_episodeUpdateManyWithWhereWithoutParsed_tvInput>
    deleteMany?: Enumerable<parsed_episodeScalarWhereInput>
  }

  export type parsed_seasonUpdateManyWithoutParsed_tvNestedInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutParsed_tvInput>, Enumerable<parsed_seasonUncheckedCreateWithoutParsed_tvInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutParsed_tvInput>
    upsert?: Enumerable<parsed_seasonUpsertWithWhereUniqueWithoutParsed_tvInput>
    set?: Enumerable<parsed_seasonWhereUniqueInput>
    disconnect?: Enumerable<parsed_seasonWhereUniqueInput>
    delete?: Enumerable<parsed_seasonWhereUniqueInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
    update?: Enumerable<parsed_seasonUpdateWithWhereUniqueWithoutParsed_tvInput>
    updateMany?: Enumerable<parsed_seasonUpdateManyWithWhereWithoutParsed_tvInput>
    deleteMany?: Enumerable<parsed_seasonScalarWhereInput>
  }

  export type parsed_episodeUncheckedUpdateManyWithoutParsed_tvNestedInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutParsed_tvInput>, Enumerable<parsed_episodeUncheckedCreateWithoutParsed_tvInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutParsed_tvInput>
    upsert?: Enumerable<parsed_episodeUpsertWithWhereUniqueWithoutParsed_tvInput>
    set?: Enumerable<parsed_episodeWhereUniqueInput>
    disconnect?: Enumerable<parsed_episodeWhereUniqueInput>
    delete?: Enumerable<parsed_episodeWhereUniqueInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
    update?: Enumerable<parsed_episodeUpdateWithWhereUniqueWithoutParsed_tvInput>
    updateMany?: Enumerable<parsed_episodeUpdateManyWithWhereWithoutParsed_tvInput>
    deleteMany?: Enumerable<parsed_episodeScalarWhereInput>
  }

  export type parsed_seasonUncheckedUpdateManyWithoutParsed_tvNestedInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutParsed_tvInput>, Enumerable<parsed_seasonUncheckedCreateWithoutParsed_tvInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutParsed_tvInput>
    upsert?: Enumerable<parsed_seasonUpsertWithWhereUniqueWithoutParsed_tvInput>
    set?: Enumerable<parsed_seasonWhereUniqueInput>
    disconnect?: Enumerable<parsed_seasonWhereUniqueInput>
    delete?: Enumerable<parsed_seasonWhereUniqueInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
    update?: Enumerable<parsed_seasonUpdateWithWhereUniqueWithoutParsed_tvInput>
    updateMany?: Enumerable<parsed_seasonUpdateManyWithWhereWithoutParsed_tvInput>
    deleteMany?: Enumerable<parsed_seasonScalarWhereInput>
  }

  export type seasonCreateNestedOneWithoutParsed_seasonInput = {
    create?: XOR<seasonCreateWithoutParsed_seasonInput, seasonUncheckedCreateWithoutParsed_seasonInput>
    connectOrCreate?: seasonCreateOrConnectWithoutParsed_seasonInput
    connect?: seasonWhereUniqueInput
  }

  export type parsed_tvCreateNestedOneWithoutParsed_seasonsInput = {
    create?: XOR<parsed_tvCreateWithoutParsed_seasonsInput, parsed_tvUncheckedCreateWithoutParsed_seasonsInput>
    connectOrCreate?: parsed_tvCreateOrConnectWithoutParsed_seasonsInput
    connect?: parsed_tvWhereUniqueInput
  }

  export type driveCreateNestedOneWithoutParsed_seasonsInput = {
    create?: XOR<driveCreateWithoutParsed_seasonsInput, driveUncheckedCreateWithoutParsed_seasonsInput>
    connectOrCreate?: driveCreateOrConnectWithoutParsed_seasonsInput
    connect?: driveWhereUniqueInput
  }

  export type userCreateNestedOneWithoutParsed_seasonsInput = {
    create?: XOR<userCreateWithoutParsed_seasonsInput, userUncheckedCreateWithoutParsed_seasonsInput>
    connectOrCreate?: userCreateOrConnectWithoutParsed_seasonsInput
    connect?: userWhereUniqueInput
  }

  export type parsed_episodeCreateNestedManyWithoutParsed_seasonInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutParsed_seasonInput>, Enumerable<parsed_episodeUncheckedCreateWithoutParsed_seasonInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutParsed_seasonInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
  }

  export type parsed_episodeUncheckedCreateNestedManyWithoutParsed_seasonInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutParsed_seasonInput>, Enumerable<parsed_episodeUncheckedCreateWithoutParsed_seasonInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutParsed_seasonInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
  }

  export type seasonUpdateOneWithoutParsed_seasonNestedInput = {
    create?: XOR<seasonCreateWithoutParsed_seasonInput, seasonUncheckedCreateWithoutParsed_seasonInput>
    connectOrCreate?: seasonCreateOrConnectWithoutParsed_seasonInput
    upsert?: seasonUpsertWithoutParsed_seasonInput
    disconnect?: boolean
    delete?: boolean
    connect?: seasonWhereUniqueInput
    update?: XOR<seasonUpdateWithoutParsed_seasonInput, seasonUncheckedUpdateWithoutParsed_seasonInput>
  }

  export type parsed_tvUpdateOneRequiredWithoutParsed_seasonsNestedInput = {
    create?: XOR<parsed_tvCreateWithoutParsed_seasonsInput, parsed_tvUncheckedCreateWithoutParsed_seasonsInput>
    connectOrCreate?: parsed_tvCreateOrConnectWithoutParsed_seasonsInput
    upsert?: parsed_tvUpsertWithoutParsed_seasonsInput
    connect?: parsed_tvWhereUniqueInput
    update?: XOR<parsed_tvUpdateWithoutParsed_seasonsInput, parsed_tvUncheckedUpdateWithoutParsed_seasonsInput>
  }

  export type driveUpdateOneRequiredWithoutParsed_seasonsNestedInput = {
    create?: XOR<driveCreateWithoutParsed_seasonsInput, driveUncheckedCreateWithoutParsed_seasonsInput>
    connectOrCreate?: driveCreateOrConnectWithoutParsed_seasonsInput
    upsert?: driveUpsertWithoutParsed_seasonsInput
    connect?: driveWhereUniqueInput
    update?: XOR<driveUpdateWithoutParsed_seasonsInput, driveUncheckedUpdateWithoutParsed_seasonsInput>
  }

  export type userUpdateOneRequiredWithoutParsed_seasonsNestedInput = {
    create?: XOR<userCreateWithoutParsed_seasonsInput, userUncheckedCreateWithoutParsed_seasonsInput>
    connectOrCreate?: userCreateOrConnectWithoutParsed_seasonsInput
    upsert?: userUpsertWithoutParsed_seasonsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutParsed_seasonsInput, userUncheckedUpdateWithoutParsed_seasonsInput>
  }

  export type parsed_episodeUpdateManyWithoutParsed_seasonNestedInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutParsed_seasonInput>, Enumerable<parsed_episodeUncheckedCreateWithoutParsed_seasonInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutParsed_seasonInput>
    upsert?: Enumerable<parsed_episodeUpsertWithWhereUniqueWithoutParsed_seasonInput>
    set?: Enumerable<parsed_episodeWhereUniqueInput>
    disconnect?: Enumerable<parsed_episodeWhereUniqueInput>
    delete?: Enumerable<parsed_episodeWhereUniqueInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
    update?: Enumerable<parsed_episodeUpdateWithWhereUniqueWithoutParsed_seasonInput>
    updateMany?: Enumerable<parsed_episodeUpdateManyWithWhereWithoutParsed_seasonInput>
    deleteMany?: Enumerable<parsed_episodeScalarWhereInput>
  }

  export type parsed_episodeUncheckedUpdateManyWithoutParsed_seasonNestedInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutParsed_seasonInput>, Enumerable<parsed_episodeUncheckedCreateWithoutParsed_seasonInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutParsed_seasonInput>
    upsert?: Enumerable<parsed_episodeUpsertWithWhereUniqueWithoutParsed_seasonInput>
    set?: Enumerable<parsed_episodeWhereUniqueInput>
    disconnect?: Enumerable<parsed_episodeWhereUniqueInput>
    delete?: Enumerable<parsed_episodeWhereUniqueInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
    update?: Enumerable<parsed_episodeUpdateWithWhereUniqueWithoutParsed_seasonInput>
    updateMany?: Enumerable<parsed_episodeUpdateManyWithWhereWithoutParsed_seasonInput>
    deleteMany?: Enumerable<parsed_episodeScalarWhereInput>
  }

  export type episodeCreateNestedOneWithoutParsed_episodesInput = {
    create?: XOR<episodeCreateWithoutParsed_episodesInput, episodeUncheckedCreateWithoutParsed_episodesInput>
    connectOrCreate?: episodeCreateOrConnectWithoutParsed_episodesInput
    connect?: episodeWhereUniqueInput
  }

  export type parsed_tvCreateNestedOneWithoutParsed_episodesInput = {
    create?: XOR<parsed_tvCreateWithoutParsed_episodesInput, parsed_tvUncheckedCreateWithoutParsed_episodesInput>
    connectOrCreate?: parsed_tvCreateOrConnectWithoutParsed_episodesInput
    connect?: parsed_tvWhereUniqueInput
  }

  export type parsed_seasonCreateNestedOneWithoutParsed_episodesInput = {
    create?: XOR<parsed_seasonCreateWithoutParsed_episodesInput, parsed_seasonUncheckedCreateWithoutParsed_episodesInput>
    connectOrCreate?: parsed_seasonCreateOrConnectWithoutParsed_episodesInput
    connect?: parsed_seasonWhereUniqueInput
  }

  export type driveCreateNestedOneWithoutParsed_episodesInput = {
    create?: XOR<driveCreateWithoutParsed_episodesInput, driveUncheckedCreateWithoutParsed_episodesInput>
    connectOrCreate?: driveCreateOrConnectWithoutParsed_episodesInput
    connect?: driveWhereUniqueInput
  }

  export type userCreateNestedOneWithoutParsed_episodesInput = {
    create?: XOR<userCreateWithoutParsed_episodesInput, userUncheckedCreateWithoutParsed_episodesInput>
    connectOrCreate?: userCreateOrConnectWithoutParsed_episodesInput
    connect?: userWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type episodeUpdateOneWithoutParsed_episodesNestedInput = {
    create?: XOR<episodeCreateWithoutParsed_episodesInput, episodeUncheckedCreateWithoutParsed_episodesInput>
    connectOrCreate?: episodeCreateOrConnectWithoutParsed_episodesInput
    upsert?: episodeUpsertWithoutParsed_episodesInput
    disconnect?: boolean
    delete?: boolean
    connect?: episodeWhereUniqueInput
    update?: XOR<episodeUpdateWithoutParsed_episodesInput, episodeUncheckedUpdateWithoutParsed_episodesInput>
  }

  export type parsed_tvUpdateOneRequiredWithoutParsed_episodesNestedInput = {
    create?: XOR<parsed_tvCreateWithoutParsed_episodesInput, parsed_tvUncheckedCreateWithoutParsed_episodesInput>
    connectOrCreate?: parsed_tvCreateOrConnectWithoutParsed_episodesInput
    upsert?: parsed_tvUpsertWithoutParsed_episodesInput
    connect?: parsed_tvWhereUniqueInput
    update?: XOR<parsed_tvUpdateWithoutParsed_episodesInput, parsed_tvUncheckedUpdateWithoutParsed_episodesInput>
  }

  export type parsed_seasonUpdateOneRequiredWithoutParsed_episodesNestedInput = {
    create?: XOR<parsed_seasonCreateWithoutParsed_episodesInput, parsed_seasonUncheckedCreateWithoutParsed_episodesInput>
    connectOrCreate?: parsed_seasonCreateOrConnectWithoutParsed_episodesInput
    upsert?: parsed_seasonUpsertWithoutParsed_episodesInput
    connect?: parsed_seasonWhereUniqueInput
    update?: XOR<parsed_seasonUpdateWithoutParsed_episodesInput, parsed_seasonUncheckedUpdateWithoutParsed_episodesInput>
  }

  export type driveUpdateOneRequiredWithoutParsed_episodesNestedInput = {
    create?: XOR<driveCreateWithoutParsed_episodesInput, driveUncheckedCreateWithoutParsed_episodesInput>
    connectOrCreate?: driveCreateOrConnectWithoutParsed_episodesInput
    upsert?: driveUpsertWithoutParsed_episodesInput
    connect?: driveWhereUniqueInput
    update?: XOR<driveUpdateWithoutParsed_episodesInput, driveUncheckedUpdateWithoutParsed_episodesInput>
  }

  export type userUpdateOneRequiredWithoutParsed_episodesNestedInput = {
    create?: XOR<userCreateWithoutParsed_episodesInput, userUncheckedCreateWithoutParsed_episodesInput>
    connectOrCreate?: userCreateOrConnectWithoutParsed_episodesInput
    upsert?: userUpsertWithoutParsed_episodesInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutParsed_episodesInput, userUncheckedUpdateWithoutParsed_episodesInput>
  }

  export type movieCreateNestedOneWithoutParsed_moviesInput = {
    create?: XOR<movieCreateWithoutParsed_moviesInput, movieUncheckedCreateWithoutParsed_moviesInput>
    connectOrCreate?: movieCreateOrConnectWithoutParsed_moviesInput
    connect?: movieWhereUniqueInput
  }

  export type driveCreateNestedOneWithoutParsed_moviesInput = {
    create?: XOR<driveCreateWithoutParsed_moviesInput, driveUncheckedCreateWithoutParsed_moviesInput>
    connectOrCreate?: driveCreateOrConnectWithoutParsed_moviesInput
    connect?: driveWhereUniqueInput
  }

  export type userCreateNestedOneWithoutParsed_moviesInput = {
    create?: XOR<userCreateWithoutParsed_moviesInput, userUncheckedCreateWithoutParsed_moviesInput>
    connectOrCreate?: userCreateOrConnectWithoutParsed_moviesInput
    connect?: userWhereUniqueInput
  }

  export type movieUpdateOneWithoutParsed_moviesNestedInput = {
    create?: XOR<movieCreateWithoutParsed_moviesInput, movieUncheckedCreateWithoutParsed_moviesInput>
    connectOrCreate?: movieCreateOrConnectWithoutParsed_moviesInput
    upsert?: movieUpsertWithoutParsed_moviesInput
    disconnect?: boolean
    delete?: boolean
    connect?: movieWhereUniqueInput
    update?: XOR<movieUpdateWithoutParsed_moviesInput, movieUncheckedUpdateWithoutParsed_moviesInput>
  }

  export type driveUpdateOneRequiredWithoutParsed_moviesNestedInput = {
    create?: XOR<driveCreateWithoutParsed_moviesInput, driveUncheckedCreateWithoutParsed_moviesInput>
    connectOrCreate?: driveCreateOrConnectWithoutParsed_moviesInput
    upsert?: driveUpsertWithoutParsed_moviesInput
    connect?: driveWhereUniqueInput
    update?: XOR<driveUpdateWithoutParsed_moviesInput, driveUncheckedUpdateWithoutParsed_moviesInput>
  }

  export type userUpdateOneRequiredWithoutParsed_moviesNestedInput = {
    create?: XOR<userCreateWithoutParsed_moviesInput, userUncheckedCreateWithoutParsed_moviesInput>
    connectOrCreate?: userCreateOrConnectWithoutParsed_moviesInput
    upsert?: userUpsertWithoutParsed_moviesInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutParsed_moviesInput, userUncheckedUpdateWithoutParsed_moviesInput>
  }

  export type tv_profileCreateNestedOneWithoutTvsInput = {
    create?: XOR<tv_profileCreateWithoutTvsInput, tv_profileUncheckedCreateWithoutTvsInput>
    connectOrCreate?: tv_profileCreateOrConnectWithoutTvsInput
    connect?: tv_profileWhereUniqueInput
  }

  export type collectionCreateNestedOneWithoutTvsInput = {
    create?: XOR<collectionCreateWithoutTvsInput, collectionUncheckedCreateWithoutTvsInput>
    connectOrCreate?: collectionCreateOrConnectWithoutTvsInput
    connect?: collectionWhereUniqueInput
  }

  export type userCreateNestedOneWithoutTvInput = {
    create?: XOR<userCreateWithoutTvInput, userUncheckedCreateWithoutTvInput>
    connectOrCreate?: userCreateOrConnectWithoutTvInput
    connect?: userWhereUniqueInput
  }

  export type seasonCreateNestedManyWithoutTvInput = {
    create?: XOR<Enumerable<seasonCreateWithoutTvInput>, Enumerable<seasonUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutTvInput>
    connect?: Enumerable<seasonWhereUniqueInput>
  }

  export type episodeCreateNestedManyWithoutTvInput = {
    create?: XOR<Enumerable<episodeCreateWithoutTvInput>, Enumerable<episodeUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutTvInput>
    connect?: Enumerable<episodeWhereUniqueInput>
  }

  export type play_historyCreateNestedManyWithoutTvInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutTvInput>, Enumerable<play_historyUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutTvInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
  }

  export type parsed_tvCreateNestedManyWithoutTvInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutTvInput>, Enumerable<parsed_tvUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutTvInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutTvInput = {
    create?: XOR<Enumerable<reportCreateWithoutTvInput>, Enumerable<reportUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTvInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type seasonUncheckedCreateNestedManyWithoutTvInput = {
    create?: XOR<Enumerable<seasonCreateWithoutTvInput>, Enumerable<seasonUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutTvInput>
    connect?: Enumerable<seasonWhereUniqueInput>
  }

  export type episodeUncheckedCreateNestedManyWithoutTvInput = {
    create?: XOR<Enumerable<episodeCreateWithoutTvInput>, Enumerable<episodeUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutTvInput>
    connect?: Enumerable<episodeWhereUniqueInput>
  }

  export type play_historyUncheckedCreateNestedManyWithoutTvInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutTvInput>, Enumerable<play_historyUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutTvInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
  }

  export type parsed_tvUncheckedCreateNestedManyWithoutTvInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutTvInput>, Enumerable<parsed_tvUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutTvInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutTvInput = {
    create?: XOR<Enumerable<reportCreateWithoutTvInput>, Enumerable<reportUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTvInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type tv_profileUpdateOneRequiredWithoutTvsNestedInput = {
    create?: XOR<tv_profileCreateWithoutTvsInput, tv_profileUncheckedCreateWithoutTvsInput>
    connectOrCreate?: tv_profileCreateOrConnectWithoutTvsInput
    upsert?: tv_profileUpsertWithoutTvsInput
    connect?: tv_profileWhereUniqueInput
    update?: XOR<tv_profileUpdateWithoutTvsInput, tv_profileUncheckedUpdateWithoutTvsInput>
  }

  export type collectionUpdateOneWithoutTvsNestedInput = {
    create?: XOR<collectionCreateWithoutTvsInput, collectionUncheckedCreateWithoutTvsInput>
    connectOrCreate?: collectionCreateOrConnectWithoutTvsInput
    upsert?: collectionUpsertWithoutTvsInput
    disconnect?: boolean
    delete?: boolean
    connect?: collectionWhereUniqueInput
    update?: XOR<collectionUpdateWithoutTvsInput, collectionUncheckedUpdateWithoutTvsInput>
  }

  export type userUpdateOneRequiredWithoutTvNestedInput = {
    create?: XOR<userCreateWithoutTvInput, userUncheckedCreateWithoutTvInput>
    connectOrCreate?: userCreateOrConnectWithoutTvInput
    upsert?: userUpsertWithoutTvInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutTvInput, userUncheckedUpdateWithoutTvInput>
  }

  export type seasonUpdateManyWithoutTvNestedInput = {
    create?: XOR<Enumerable<seasonCreateWithoutTvInput>, Enumerable<seasonUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutTvInput>
    upsert?: Enumerable<seasonUpsertWithWhereUniqueWithoutTvInput>
    set?: Enumerable<seasonWhereUniqueInput>
    disconnect?: Enumerable<seasonWhereUniqueInput>
    delete?: Enumerable<seasonWhereUniqueInput>
    connect?: Enumerable<seasonWhereUniqueInput>
    update?: Enumerable<seasonUpdateWithWhereUniqueWithoutTvInput>
    updateMany?: Enumerable<seasonUpdateManyWithWhereWithoutTvInput>
    deleteMany?: Enumerable<seasonScalarWhereInput>
  }

  export type episodeUpdateManyWithoutTvNestedInput = {
    create?: XOR<Enumerable<episodeCreateWithoutTvInput>, Enumerable<episodeUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutTvInput>
    upsert?: Enumerable<episodeUpsertWithWhereUniqueWithoutTvInput>
    set?: Enumerable<episodeWhereUniqueInput>
    disconnect?: Enumerable<episodeWhereUniqueInput>
    delete?: Enumerable<episodeWhereUniqueInput>
    connect?: Enumerable<episodeWhereUniqueInput>
    update?: Enumerable<episodeUpdateWithWhereUniqueWithoutTvInput>
    updateMany?: Enumerable<episodeUpdateManyWithWhereWithoutTvInput>
    deleteMany?: Enumerable<episodeScalarWhereInput>
  }

  export type play_historyUpdateManyWithoutTvNestedInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutTvInput>, Enumerable<play_historyUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutTvInput>
    upsert?: Enumerable<play_historyUpsertWithWhereUniqueWithoutTvInput>
    set?: Enumerable<play_historyWhereUniqueInput>
    disconnect?: Enumerable<play_historyWhereUniqueInput>
    delete?: Enumerable<play_historyWhereUniqueInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
    update?: Enumerable<play_historyUpdateWithWhereUniqueWithoutTvInput>
    updateMany?: Enumerable<play_historyUpdateManyWithWhereWithoutTvInput>
    deleteMany?: Enumerable<play_historyScalarWhereInput>
  }

  export type parsed_tvUpdateManyWithoutTvNestedInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutTvInput>, Enumerable<parsed_tvUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutTvInput>
    upsert?: Enumerable<parsed_tvUpsertWithWhereUniqueWithoutTvInput>
    set?: Enumerable<parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<parsed_tvWhereUniqueInput>
    delete?: Enumerable<parsed_tvWhereUniqueInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
    update?: Enumerable<parsed_tvUpdateWithWhereUniqueWithoutTvInput>
    updateMany?: Enumerable<parsed_tvUpdateManyWithWhereWithoutTvInput>
    deleteMany?: Enumerable<parsed_tvScalarWhereInput>
  }

  export type reportUpdateManyWithoutTvNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutTvInput>, Enumerable<reportUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTvInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutTvInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutTvInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutTvInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type seasonUncheckedUpdateManyWithoutTvNestedInput = {
    create?: XOR<Enumerable<seasonCreateWithoutTvInput>, Enumerable<seasonUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutTvInput>
    upsert?: Enumerable<seasonUpsertWithWhereUniqueWithoutTvInput>
    set?: Enumerable<seasonWhereUniqueInput>
    disconnect?: Enumerable<seasonWhereUniqueInput>
    delete?: Enumerable<seasonWhereUniqueInput>
    connect?: Enumerable<seasonWhereUniqueInput>
    update?: Enumerable<seasonUpdateWithWhereUniqueWithoutTvInput>
    updateMany?: Enumerable<seasonUpdateManyWithWhereWithoutTvInput>
    deleteMany?: Enumerable<seasonScalarWhereInput>
  }

  export type episodeUncheckedUpdateManyWithoutTvNestedInput = {
    create?: XOR<Enumerable<episodeCreateWithoutTvInput>, Enumerable<episodeUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutTvInput>
    upsert?: Enumerable<episodeUpsertWithWhereUniqueWithoutTvInput>
    set?: Enumerable<episodeWhereUniqueInput>
    disconnect?: Enumerable<episodeWhereUniqueInput>
    delete?: Enumerable<episodeWhereUniqueInput>
    connect?: Enumerable<episodeWhereUniqueInput>
    update?: Enumerable<episodeUpdateWithWhereUniqueWithoutTvInput>
    updateMany?: Enumerable<episodeUpdateManyWithWhereWithoutTvInput>
    deleteMany?: Enumerable<episodeScalarWhereInput>
  }

  export type play_historyUncheckedUpdateManyWithoutTvNestedInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutTvInput>, Enumerable<play_historyUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutTvInput>
    upsert?: Enumerable<play_historyUpsertWithWhereUniqueWithoutTvInput>
    set?: Enumerable<play_historyWhereUniqueInput>
    disconnect?: Enumerable<play_historyWhereUniqueInput>
    delete?: Enumerable<play_historyWhereUniqueInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
    update?: Enumerable<play_historyUpdateWithWhereUniqueWithoutTvInput>
    updateMany?: Enumerable<play_historyUpdateManyWithWhereWithoutTvInput>
    deleteMany?: Enumerable<play_historyScalarWhereInput>
  }

  export type parsed_tvUncheckedUpdateManyWithoutTvNestedInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutTvInput>, Enumerable<parsed_tvUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutTvInput>
    upsert?: Enumerable<parsed_tvUpsertWithWhereUniqueWithoutTvInput>
    set?: Enumerable<parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<parsed_tvWhereUniqueInput>
    delete?: Enumerable<parsed_tvWhereUniqueInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
    update?: Enumerable<parsed_tvUpdateWithWhereUniqueWithoutTvInput>
    updateMany?: Enumerable<parsed_tvUpdateManyWithWhereWithoutTvInput>
    deleteMany?: Enumerable<parsed_tvScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutTvNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutTvInput>, Enumerable<reportUncheckedCreateWithoutTvInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutTvInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutTvInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutTvInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutTvInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type season_profileCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<season_profileCreateWithoutSeasonsInput, season_profileUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: season_profileCreateOrConnectWithoutSeasonsInput
    connect?: season_profileWhereUniqueInput
  }

  export type collectionCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<collectionCreateWithoutSeasonsInput, collectionUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: collectionCreateOrConnectWithoutSeasonsInput
    connect?: collectionWhereUniqueInput
  }

  export type tvCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<tvCreateWithoutSeasonsInput, tvUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: tvCreateOrConnectWithoutSeasonsInput
    connect?: tvWhereUniqueInput
  }

  export type userCreateNestedOneWithoutSeasonsInput = {
    create?: XOR<userCreateWithoutSeasonsInput, userUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: userCreateOrConnectWithoutSeasonsInput
    connect?: userWhereUniqueInput
  }

  export type parsed_seasonCreateNestedManyWithoutSeasonInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutSeasonInput>, Enumerable<parsed_seasonUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutSeasonInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
  }

  export type play_historyCreateNestedManyWithoutSeasonInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutSeasonInput>, Enumerable<play_historyUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutSeasonInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
  }

  export type episodeCreateNestedManyWithoutSeasonInput = {
    create?: XOR<Enumerable<episodeCreateWithoutSeasonInput>, Enumerable<episodeUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutSeasonInput>
    connect?: Enumerable<episodeWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutSeasonInput = {
    create?: XOR<Enumerable<reportCreateWithoutSeasonInput>, Enumerable<reportUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutSeasonInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type bind_for_parsed_tvCreateNestedManyWithoutSeasonInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutSeasonInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutSeasonInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
  }

  export type parsed_seasonUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutSeasonInput>, Enumerable<parsed_seasonUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutSeasonInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
  }

  export type play_historyUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutSeasonInput>, Enumerable<play_historyUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutSeasonInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
  }

  export type episodeUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<Enumerable<episodeCreateWithoutSeasonInput>, Enumerable<episodeUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutSeasonInput>
    connect?: Enumerable<episodeWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<Enumerable<reportCreateWithoutSeasonInput>, Enumerable<reportUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutSeasonInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type bind_for_parsed_tvUncheckedCreateNestedManyWithoutSeasonInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutSeasonInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutSeasonInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
  }

  export type season_profileUpdateOneRequiredWithoutSeasonsNestedInput = {
    create?: XOR<season_profileCreateWithoutSeasonsInput, season_profileUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: season_profileCreateOrConnectWithoutSeasonsInput
    upsert?: season_profileUpsertWithoutSeasonsInput
    connect?: season_profileWhereUniqueInput
    update?: XOR<season_profileUpdateWithoutSeasonsInput, season_profileUncheckedUpdateWithoutSeasonsInput>
  }

  export type collectionUpdateOneWithoutSeasonsNestedInput = {
    create?: XOR<collectionCreateWithoutSeasonsInput, collectionUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: collectionCreateOrConnectWithoutSeasonsInput
    upsert?: collectionUpsertWithoutSeasonsInput
    disconnect?: boolean
    delete?: boolean
    connect?: collectionWhereUniqueInput
    update?: XOR<collectionUpdateWithoutSeasonsInput, collectionUncheckedUpdateWithoutSeasonsInput>
  }

  export type tvUpdateOneRequiredWithoutSeasonsNestedInput = {
    create?: XOR<tvCreateWithoutSeasonsInput, tvUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: tvCreateOrConnectWithoutSeasonsInput
    upsert?: tvUpsertWithoutSeasonsInput
    connect?: tvWhereUniqueInput
    update?: XOR<tvUpdateWithoutSeasonsInput, tvUncheckedUpdateWithoutSeasonsInput>
  }

  export type userUpdateOneRequiredWithoutSeasonsNestedInput = {
    create?: XOR<userCreateWithoutSeasonsInput, userUncheckedCreateWithoutSeasonsInput>
    connectOrCreate?: userCreateOrConnectWithoutSeasonsInput
    upsert?: userUpsertWithoutSeasonsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutSeasonsInput, userUncheckedUpdateWithoutSeasonsInput>
  }

  export type parsed_seasonUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutSeasonInput>, Enumerable<parsed_seasonUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutSeasonInput>
    upsert?: Enumerable<parsed_seasonUpsertWithWhereUniqueWithoutSeasonInput>
    set?: Enumerable<parsed_seasonWhereUniqueInput>
    disconnect?: Enumerable<parsed_seasonWhereUniqueInput>
    delete?: Enumerable<parsed_seasonWhereUniqueInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
    update?: Enumerable<parsed_seasonUpdateWithWhereUniqueWithoutSeasonInput>
    updateMany?: Enumerable<parsed_seasonUpdateManyWithWhereWithoutSeasonInput>
    deleteMany?: Enumerable<parsed_seasonScalarWhereInput>
  }

  export type play_historyUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutSeasonInput>, Enumerable<play_historyUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutSeasonInput>
    upsert?: Enumerable<play_historyUpsertWithWhereUniqueWithoutSeasonInput>
    set?: Enumerable<play_historyWhereUniqueInput>
    disconnect?: Enumerable<play_historyWhereUniqueInput>
    delete?: Enumerable<play_historyWhereUniqueInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
    update?: Enumerable<play_historyUpdateWithWhereUniqueWithoutSeasonInput>
    updateMany?: Enumerable<play_historyUpdateManyWithWhereWithoutSeasonInput>
    deleteMany?: Enumerable<play_historyScalarWhereInput>
  }

  export type episodeUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<Enumerable<episodeCreateWithoutSeasonInput>, Enumerable<episodeUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutSeasonInput>
    upsert?: Enumerable<episodeUpsertWithWhereUniqueWithoutSeasonInput>
    set?: Enumerable<episodeWhereUniqueInput>
    disconnect?: Enumerable<episodeWhereUniqueInput>
    delete?: Enumerable<episodeWhereUniqueInput>
    connect?: Enumerable<episodeWhereUniqueInput>
    update?: Enumerable<episodeUpdateWithWhereUniqueWithoutSeasonInput>
    updateMany?: Enumerable<episodeUpdateManyWithWhereWithoutSeasonInput>
    deleteMany?: Enumerable<episodeScalarWhereInput>
  }

  export type reportUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutSeasonInput>, Enumerable<reportUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutSeasonInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutSeasonInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutSeasonInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutSeasonInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type bind_for_parsed_tvUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutSeasonInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutSeasonInput>
    upsert?: Enumerable<bind_for_parsed_tvUpsertWithWhereUniqueWithoutSeasonInput>
    set?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    delete?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    update?: Enumerable<bind_for_parsed_tvUpdateWithWhereUniqueWithoutSeasonInput>
    updateMany?: Enumerable<bind_for_parsed_tvUpdateManyWithWhereWithoutSeasonInput>
    deleteMany?: Enumerable<bind_for_parsed_tvScalarWhereInput>
  }

  export type parsed_seasonUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutSeasonInput>, Enumerable<parsed_seasonUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutSeasonInput>
    upsert?: Enumerable<parsed_seasonUpsertWithWhereUniqueWithoutSeasonInput>
    set?: Enumerable<parsed_seasonWhereUniqueInput>
    disconnect?: Enumerable<parsed_seasonWhereUniqueInput>
    delete?: Enumerable<parsed_seasonWhereUniqueInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
    update?: Enumerable<parsed_seasonUpdateWithWhereUniqueWithoutSeasonInput>
    updateMany?: Enumerable<parsed_seasonUpdateManyWithWhereWithoutSeasonInput>
    deleteMany?: Enumerable<parsed_seasonScalarWhereInput>
  }

  export type play_historyUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutSeasonInput>, Enumerable<play_historyUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutSeasonInput>
    upsert?: Enumerable<play_historyUpsertWithWhereUniqueWithoutSeasonInput>
    set?: Enumerable<play_historyWhereUniqueInput>
    disconnect?: Enumerable<play_historyWhereUniqueInput>
    delete?: Enumerable<play_historyWhereUniqueInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
    update?: Enumerable<play_historyUpdateWithWhereUniqueWithoutSeasonInput>
    updateMany?: Enumerable<play_historyUpdateManyWithWhereWithoutSeasonInput>
    deleteMany?: Enumerable<play_historyScalarWhereInput>
  }

  export type episodeUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<Enumerable<episodeCreateWithoutSeasonInput>, Enumerable<episodeUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutSeasonInput>
    upsert?: Enumerable<episodeUpsertWithWhereUniqueWithoutSeasonInput>
    set?: Enumerable<episodeWhereUniqueInput>
    disconnect?: Enumerable<episodeWhereUniqueInput>
    delete?: Enumerable<episodeWhereUniqueInput>
    connect?: Enumerable<episodeWhereUniqueInput>
    update?: Enumerable<episodeUpdateWithWhereUniqueWithoutSeasonInput>
    updateMany?: Enumerable<episodeUpdateManyWithWhereWithoutSeasonInput>
    deleteMany?: Enumerable<episodeScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutSeasonInput>, Enumerable<reportUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutSeasonInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutSeasonInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutSeasonInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutSeasonInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type bind_for_parsed_tvUncheckedUpdateManyWithoutSeasonNestedInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutSeasonInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutSeasonInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutSeasonInput>
    upsert?: Enumerable<bind_for_parsed_tvUpsertWithWhereUniqueWithoutSeasonInput>
    set?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    delete?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    update?: Enumerable<bind_for_parsed_tvUpdateWithWhereUniqueWithoutSeasonInput>
    updateMany?: Enumerable<bind_for_parsed_tvUpdateManyWithWhereWithoutSeasonInput>
    deleteMany?: Enumerable<bind_for_parsed_tvScalarWhereInput>
  }

  export type episode_profileCreateNestedOneWithoutEpisodesInput = {
    create?: XOR<episode_profileCreateWithoutEpisodesInput, episode_profileUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: episode_profileCreateOrConnectWithoutEpisodesInput
    connect?: episode_profileWhereUniqueInput
  }

  export type tvCreateNestedOneWithoutEpisodesInput = {
    create?: XOR<tvCreateWithoutEpisodesInput, tvUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: tvCreateOrConnectWithoutEpisodesInput
    connect?: tvWhereUniqueInput
  }

  export type seasonCreateNestedOneWithoutEpisodesInput = {
    create?: XOR<seasonCreateWithoutEpisodesInput, seasonUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: seasonCreateOrConnectWithoutEpisodesInput
    connect?: seasonWhereUniqueInput
  }

  export type userCreateNestedOneWithoutEpisodeInput = {
    create?: XOR<userCreateWithoutEpisodeInput, userUncheckedCreateWithoutEpisodeInput>
    connectOrCreate?: userCreateOrConnectWithoutEpisodeInput
    connect?: userWhereUniqueInput
  }

  export type parsed_episodeCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutEpisodeInput>, Enumerable<parsed_episodeUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutEpisodeInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
  }

  export type play_historyCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutEpisodeInput>, Enumerable<play_historyUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutEpisodeInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<Enumerable<reportCreateWithoutEpisodeInput>, Enumerable<reportUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutEpisodeInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type subtitleCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutEpisodeInput>, Enumerable<subtitleUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutEpisodeInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
  }

  export type parsed_episodeUncheckedCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutEpisodeInput>, Enumerable<parsed_episodeUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutEpisodeInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
  }

  export type play_historyUncheckedCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutEpisodeInput>, Enumerable<play_historyUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutEpisodeInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<Enumerable<reportCreateWithoutEpisodeInput>, Enumerable<reportUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutEpisodeInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type subtitleUncheckedCreateNestedManyWithoutEpisodeInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutEpisodeInput>, Enumerable<subtitleUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutEpisodeInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
  }

  export type episode_profileUpdateOneRequiredWithoutEpisodesNestedInput = {
    create?: XOR<episode_profileCreateWithoutEpisodesInput, episode_profileUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: episode_profileCreateOrConnectWithoutEpisodesInput
    upsert?: episode_profileUpsertWithoutEpisodesInput
    connect?: episode_profileWhereUniqueInput
    update?: XOR<episode_profileUpdateWithoutEpisodesInput, episode_profileUncheckedUpdateWithoutEpisodesInput>
  }

  export type tvUpdateOneRequiredWithoutEpisodesNestedInput = {
    create?: XOR<tvCreateWithoutEpisodesInput, tvUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: tvCreateOrConnectWithoutEpisodesInput
    upsert?: tvUpsertWithoutEpisodesInput
    connect?: tvWhereUniqueInput
    update?: XOR<tvUpdateWithoutEpisodesInput, tvUncheckedUpdateWithoutEpisodesInput>
  }

  export type seasonUpdateOneRequiredWithoutEpisodesNestedInput = {
    create?: XOR<seasonCreateWithoutEpisodesInput, seasonUncheckedCreateWithoutEpisodesInput>
    connectOrCreate?: seasonCreateOrConnectWithoutEpisodesInput
    upsert?: seasonUpsertWithoutEpisodesInput
    connect?: seasonWhereUniqueInput
    update?: XOR<seasonUpdateWithoutEpisodesInput, seasonUncheckedUpdateWithoutEpisodesInput>
  }

  export type userUpdateOneRequiredWithoutEpisodeNestedInput = {
    create?: XOR<userCreateWithoutEpisodeInput, userUncheckedCreateWithoutEpisodeInput>
    connectOrCreate?: userCreateOrConnectWithoutEpisodeInput
    upsert?: userUpsertWithoutEpisodeInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutEpisodeInput, userUncheckedUpdateWithoutEpisodeInput>
  }

  export type parsed_episodeUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutEpisodeInput>, Enumerable<parsed_episodeUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutEpisodeInput>
    upsert?: Enumerable<parsed_episodeUpsertWithWhereUniqueWithoutEpisodeInput>
    set?: Enumerable<parsed_episodeWhereUniqueInput>
    disconnect?: Enumerable<parsed_episodeWhereUniqueInput>
    delete?: Enumerable<parsed_episodeWhereUniqueInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
    update?: Enumerable<parsed_episodeUpdateWithWhereUniqueWithoutEpisodeInput>
    updateMany?: Enumerable<parsed_episodeUpdateManyWithWhereWithoutEpisodeInput>
    deleteMany?: Enumerable<parsed_episodeScalarWhereInput>
  }

  export type play_historyUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutEpisodeInput>, Enumerable<play_historyUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutEpisodeInput>
    upsert?: Enumerable<play_historyUpsertWithWhereUniqueWithoutEpisodeInput>
    set?: Enumerable<play_historyWhereUniqueInput>
    disconnect?: Enumerable<play_historyWhereUniqueInput>
    delete?: Enumerable<play_historyWhereUniqueInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
    update?: Enumerable<play_historyUpdateWithWhereUniqueWithoutEpisodeInput>
    updateMany?: Enumerable<play_historyUpdateManyWithWhereWithoutEpisodeInput>
    deleteMany?: Enumerable<play_historyScalarWhereInput>
  }

  export type reportUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutEpisodeInput>, Enumerable<reportUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutEpisodeInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutEpisodeInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutEpisodeInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutEpisodeInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type subtitleUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutEpisodeInput>, Enumerable<subtitleUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutEpisodeInput>
    upsert?: Enumerable<subtitleUpsertWithWhereUniqueWithoutEpisodeInput>
    set?: Enumerable<subtitleWhereUniqueInput>
    disconnect?: Enumerable<subtitleWhereUniqueInput>
    delete?: Enumerable<subtitleWhereUniqueInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
    update?: Enumerable<subtitleUpdateWithWhereUniqueWithoutEpisodeInput>
    updateMany?: Enumerable<subtitleUpdateManyWithWhereWithoutEpisodeInput>
    deleteMany?: Enumerable<subtitleScalarWhereInput>
  }

  export type parsed_episodeUncheckedUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutEpisodeInput>, Enumerable<parsed_episodeUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutEpisodeInput>
    upsert?: Enumerable<parsed_episodeUpsertWithWhereUniqueWithoutEpisodeInput>
    set?: Enumerable<parsed_episodeWhereUniqueInput>
    disconnect?: Enumerable<parsed_episodeWhereUniqueInput>
    delete?: Enumerable<parsed_episodeWhereUniqueInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
    update?: Enumerable<parsed_episodeUpdateWithWhereUniqueWithoutEpisodeInput>
    updateMany?: Enumerable<parsed_episodeUpdateManyWithWhereWithoutEpisodeInput>
    deleteMany?: Enumerable<parsed_episodeScalarWhereInput>
  }

  export type play_historyUncheckedUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutEpisodeInput>, Enumerable<play_historyUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutEpisodeInput>
    upsert?: Enumerable<play_historyUpsertWithWhereUniqueWithoutEpisodeInput>
    set?: Enumerable<play_historyWhereUniqueInput>
    disconnect?: Enumerable<play_historyWhereUniqueInput>
    delete?: Enumerable<play_historyWhereUniqueInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
    update?: Enumerable<play_historyUpdateWithWhereUniqueWithoutEpisodeInput>
    updateMany?: Enumerable<play_historyUpdateManyWithWhereWithoutEpisodeInput>
    deleteMany?: Enumerable<play_historyScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutEpisodeInput>, Enumerable<reportUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutEpisodeInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutEpisodeInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutEpisodeInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutEpisodeInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type subtitleUncheckedUpdateManyWithoutEpisodeNestedInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutEpisodeInput>, Enumerable<subtitleUncheckedCreateWithoutEpisodeInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutEpisodeInput>
    upsert?: Enumerable<subtitleUpsertWithWhereUniqueWithoutEpisodeInput>
    set?: Enumerable<subtitleWhereUniqueInput>
    disconnect?: Enumerable<subtitleWhereUniqueInput>
    delete?: Enumerable<subtitleWhereUniqueInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
    update?: Enumerable<subtitleUpdateWithWhereUniqueWithoutEpisodeInput>
    updateMany?: Enumerable<subtitleUpdateManyWithWhereWithoutEpisodeInput>
    deleteMany?: Enumerable<subtitleScalarWhereInput>
  }

  export type movie_profileCreateNestedOneWithoutMoviesInput = {
    create?: XOR<movie_profileCreateWithoutMoviesInput, movie_profileUncheckedCreateWithoutMoviesInput>
    connectOrCreate?: movie_profileCreateOrConnectWithoutMoviesInput
    connect?: movie_profileWhereUniqueInput
  }

  export type userCreateNestedOneWithoutMovieInput = {
    create?: XOR<userCreateWithoutMovieInput, userUncheckedCreateWithoutMovieInput>
    connectOrCreate?: userCreateOrConnectWithoutMovieInput
    connect?: userWhereUniqueInput
  }

  export type collectionCreateNestedOneWithoutMoviesInput = {
    create?: XOR<collectionCreateWithoutMoviesInput, collectionUncheckedCreateWithoutMoviesInput>
    connectOrCreate?: collectionCreateOrConnectWithoutMoviesInput
    connect?: collectionWhereUniqueInput
  }

  export type play_historyCreateNestedManyWithoutMovieInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutMovieInput>, Enumerable<play_historyUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutMovieInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
  }

  export type parsed_movieCreateNestedManyWithoutMovieInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutMovieInput>, Enumerable<parsed_movieUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutMovieInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutMovieInput = {
    create?: XOR<Enumerable<reportCreateWithoutMovieInput>, Enumerable<reportUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutMovieInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type subtitleCreateNestedManyWithoutMovieInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutMovieInput>, Enumerable<subtitleUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutMovieInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
  }

  export type play_historyUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutMovieInput>, Enumerable<play_historyUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutMovieInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
  }

  export type parsed_movieUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutMovieInput>, Enumerable<parsed_movieUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutMovieInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<Enumerable<reportCreateWithoutMovieInput>, Enumerable<reportUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutMovieInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type subtitleUncheckedCreateNestedManyWithoutMovieInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutMovieInput>, Enumerable<subtitleUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutMovieInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
  }

  export type movie_profileUpdateOneRequiredWithoutMoviesNestedInput = {
    create?: XOR<movie_profileCreateWithoutMoviesInput, movie_profileUncheckedCreateWithoutMoviesInput>
    connectOrCreate?: movie_profileCreateOrConnectWithoutMoviesInput
    upsert?: movie_profileUpsertWithoutMoviesInput
    connect?: movie_profileWhereUniqueInput
    update?: XOR<movie_profileUpdateWithoutMoviesInput, movie_profileUncheckedUpdateWithoutMoviesInput>
  }

  export type userUpdateOneRequiredWithoutMovieNestedInput = {
    create?: XOR<userCreateWithoutMovieInput, userUncheckedCreateWithoutMovieInput>
    connectOrCreate?: userCreateOrConnectWithoutMovieInput
    upsert?: userUpsertWithoutMovieInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutMovieInput, userUncheckedUpdateWithoutMovieInput>
  }

  export type collectionUpdateOneWithoutMoviesNestedInput = {
    create?: XOR<collectionCreateWithoutMoviesInput, collectionUncheckedCreateWithoutMoviesInput>
    connectOrCreate?: collectionCreateOrConnectWithoutMoviesInput
    upsert?: collectionUpsertWithoutMoviesInput
    disconnect?: boolean
    delete?: boolean
    connect?: collectionWhereUniqueInput
    update?: XOR<collectionUpdateWithoutMoviesInput, collectionUncheckedUpdateWithoutMoviesInput>
  }

  export type play_historyUpdateManyWithoutMovieNestedInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutMovieInput>, Enumerable<play_historyUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutMovieInput>
    upsert?: Enumerable<play_historyUpsertWithWhereUniqueWithoutMovieInput>
    set?: Enumerable<play_historyWhereUniqueInput>
    disconnect?: Enumerable<play_historyWhereUniqueInput>
    delete?: Enumerable<play_historyWhereUniqueInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
    update?: Enumerable<play_historyUpdateWithWhereUniqueWithoutMovieInput>
    updateMany?: Enumerable<play_historyUpdateManyWithWhereWithoutMovieInput>
    deleteMany?: Enumerable<play_historyScalarWhereInput>
  }

  export type parsed_movieUpdateManyWithoutMovieNestedInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutMovieInput>, Enumerable<parsed_movieUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutMovieInput>
    upsert?: Enumerable<parsed_movieUpsertWithWhereUniqueWithoutMovieInput>
    set?: Enumerable<parsed_movieWhereUniqueInput>
    disconnect?: Enumerable<parsed_movieWhereUniqueInput>
    delete?: Enumerable<parsed_movieWhereUniqueInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
    update?: Enumerable<parsed_movieUpdateWithWhereUniqueWithoutMovieInput>
    updateMany?: Enumerable<parsed_movieUpdateManyWithWhereWithoutMovieInput>
    deleteMany?: Enumerable<parsed_movieScalarWhereInput>
  }

  export type reportUpdateManyWithoutMovieNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutMovieInput>, Enumerable<reportUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutMovieInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutMovieInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutMovieInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutMovieInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type subtitleUpdateManyWithoutMovieNestedInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutMovieInput>, Enumerable<subtitleUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutMovieInput>
    upsert?: Enumerable<subtitleUpsertWithWhereUniqueWithoutMovieInput>
    set?: Enumerable<subtitleWhereUniqueInput>
    disconnect?: Enumerable<subtitleWhereUniqueInput>
    delete?: Enumerable<subtitleWhereUniqueInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
    update?: Enumerable<subtitleUpdateWithWhereUniqueWithoutMovieInput>
    updateMany?: Enumerable<subtitleUpdateManyWithWhereWithoutMovieInput>
    deleteMany?: Enumerable<subtitleScalarWhereInput>
  }

  export type play_historyUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutMovieInput>, Enumerable<play_historyUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutMovieInput>
    upsert?: Enumerable<play_historyUpsertWithWhereUniqueWithoutMovieInput>
    set?: Enumerable<play_historyWhereUniqueInput>
    disconnect?: Enumerable<play_historyWhereUniqueInput>
    delete?: Enumerable<play_historyWhereUniqueInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
    update?: Enumerable<play_historyUpdateWithWhereUniqueWithoutMovieInput>
    updateMany?: Enumerable<play_historyUpdateManyWithWhereWithoutMovieInput>
    deleteMany?: Enumerable<play_historyScalarWhereInput>
  }

  export type parsed_movieUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutMovieInput>, Enumerable<parsed_movieUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutMovieInput>
    upsert?: Enumerable<parsed_movieUpsertWithWhereUniqueWithoutMovieInput>
    set?: Enumerable<parsed_movieWhereUniqueInput>
    disconnect?: Enumerable<parsed_movieWhereUniqueInput>
    delete?: Enumerable<parsed_movieWhereUniqueInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
    update?: Enumerable<parsed_movieUpdateWithWhereUniqueWithoutMovieInput>
    updateMany?: Enumerable<parsed_movieUpdateManyWithWhereWithoutMovieInput>
    deleteMany?: Enumerable<parsed_movieScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutMovieInput>, Enumerable<reportUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutMovieInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutMovieInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutMovieInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutMovieInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type subtitleUncheckedUpdateManyWithoutMovieNestedInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutMovieInput>, Enumerable<subtitleUncheckedCreateWithoutMovieInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutMovieInput>
    upsert?: Enumerable<subtitleUpsertWithWhereUniqueWithoutMovieInput>
    set?: Enumerable<subtitleWhereUniqueInput>
    disconnect?: Enumerable<subtitleWhereUniqueInput>
    delete?: Enumerable<subtitleWhereUniqueInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
    update?: Enumerable<subtitleUpdateWithWhereUniqueWithoutMovieInput>
    updateMany?: Enumerable<subtitleUpdateManyWithWhereWithoutMovieInput>
    deleteMany?: Enumerable<subtitleScalarWhereInput>
  }

  export type tvCreateNestedManyWithoutCollectionInput = {
    create?: XOR<Enumerable<tvCreateWithoutCollectionInput>, Enumerable<tvUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutCollectionInput>
    connect?: Enumerable<tvWhereUniqueInput>
  }

  export type seasonCreateNestedManyWithoutCollectionInput = {
    create?: XOR<Enumerable<seasonCreateWithoutCollectionInput>, Enumerable<seasonUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutCollectionInput>
    connect?: Enumerable<seasonWhereUniqueInput>
  }

  export type movieCreateNestedManyWithoutCollectionInput = {
    create?: XOR<Enumerable<movieCreateWithoutCollectionInput>, Enumerable<movieUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutCollectionInput>
    connect?: Enumerable<movieWhereUniqueInput>
  }

  export type userCreateNestedOneWithoutCollectionsInput = {
    create?: XOR<userCreateWithoutCollectionsInput, userUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: userCreateOrConnectWithoutCollectionsInput
    connect?: userWhereUniqueInput
  }

  export type tvUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<Enumerable<tvCreateWithoutCollectionInput>, Enumerable<tvUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutCollectionInput>
    connect?: Enumerable<tvWhereUniqueInput>
  }

  export type seasonUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<Enumerable<seasonCreateWithoutCollectionInput>, Enumerable<seasonUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutCollectionInput>
    connect?: Enumerable<seasonWhereUniqueInput>
  }

  export type movieUncheckedCreateNestedManyWithoutCollectionInput = {
    create?: XOR<Enumerable<movieCreateWithoutCollectionInput>, Enumerable<movieUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutCollectionInput>
    connect?: Enumerable<movieWhereUniqueInput>
  }

  export type tvUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<Enumerable<tvCreateWithoutCollectionInput>, Enumerable<tvUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutCollectionInput>
    upsert?: Enumerable<tvUpsertWithWhereUniqueWithoutCollectionInput>
    set?: Enumerable<tvWhereUniqueInput>
    disconnect?: Enumerable<tvWhereUniqueInput>
    delete?: Enumerable<tvWhereUniqueInput>
    connect?: Enumerable<tvWhereUniqueInput>
    update?: Enumerable<tvUpdateWithWhereUniqueWithoutCollectionInput>
    updateMany?: Enumerable<tvUpdateManyWithWhereWithoutCollectionInput>
    deleteMany?: Enumerable<tvScalarWhereInput>
  }

  export type seasonUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<Enumerable<seasonCreateWithoutCollectionInput>, Enumerable<seasonUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutCollectionInput>
    upsert?: Enumerable<seasonUpsertWithWhereUniqueWithoutCollectionInput>
    set?: Enumerable<seasonWhereUniqueInput>
    disconnect?: Enumerable<seasonWhereUniqueInput>
    delete?: Enumerable<seasonWhereUniqueInput>
    connect?: Enumerable<seasonWhereUniqueInput>
    update?: Enumerable<seasonUpdateWithWhereUniqueWithoutCollectionInput>
    updateMany?: Enumerable<seasonUpdateManyWithWhereWithoutCollectionInput>
    deleteMany?: Enumerable<seasonScalarWhereInput>
  }

  export type movieUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<Enumerable<movieCreateWithoutCollectionInput>, Enumerable<movieUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutCollectionInput>
    upsert?: Enumerable<movieUpsertWithWhereUniqueWithoutCollectionInput>
    set?: Enumerable<movieWhereUniqueInput>
    disconnect?: Enumerable<movieWhereUniqueInput>
    delete?: Enumerable<movieWhereUniqueInput>
    connect?: Enumerable<movieWhereUniqueInput>
    update?: Enumerable<movieUpdateWithWhereUniqueWithoutCollectionInput>
    updateMany?: Enumerable<movieUpdateManyWithWhereWithoutCollectionInput>
    deleteMany?: Enumerable<movieScalarWhereInput>
  }

  export type userUpdateOneRequiredWithoutCollectionsNestedInput = {
    create?: XOR<userCreateWithoutCollectionsInput, userUncheckedCreateWithoutCollectionsInput>
    connectOrCreate?: userCreateOrConnectWithoutCollectionsInput
    upsert?: userUpsertWithoutCollectionsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutCollectionsInput, userUncheckedUpdateWithoutCollectionsInput>
  }

  export type tvUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<Enumerable<tvCreateWithoutCollectionInput>, Enumerable<tvUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutCollectionInput>
    upsert?: Enumerable<tvUpsertWithWhereUniqueWithoutCollectionInput>
    set?: Enumerable<tvWhereUniqueInput>
    disconnect?: Enumerable<tvWhereUniqueInput>
    delete?: Enumerable<tvWhereUniqueInput>
    connect?: Enumerable<tvWhereUniqueInput>
    update?: Enumerable<tvUpdateWithWhereUniqueWithoutCollectionInput>
    updateMany?: Enumerable<tvUpdateManyWithWhereWithoutCollectionInput>
    deleteMany?: Enumerable<tvScalarWhereInput>
  }

  export type seasonUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<Enumerable<seasonCreateWithoutCollectionInput>, Enumerable<seasonUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutCollectionInput>
    upsert?: Enumerable<seasonUpsertWithWhereUniqueWithoutCollectionInput>
    set?: Enumerable<seasonWhereUniqueInput>
    disconnect?: Enumerable<seasonWhereUniqueInput>
    delete?: Enumerable<seasonWhereUniqueInput>
    connect?: Enumerable<seasonWhereUniqueInput>
    update?: Enumerable<seasonUpdateWithWhereUniqueWithoutCollectionInput>
    updateMany?: Enumerable<seasonUpdateManyWithWhereWithoutCollectionInput>
    deleteMany?: Enumerable<seasonScalarWhereInput>
  }

  export type movieUncheckedUpdateManyWithoutCollectionNestedInput = {
    create?: XOR<Enumerable<movieCreateWithoutCollectionInput>, Enumerable<movieUncheckedCreateWithoutCollectionInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutCollectionInput>
    upsert?: Enumerable<movieUpsertWithWhereUniqueWithoutCollectionInput>
    set?: Enumerable<movieWhereUniqueInput>
    disconnect?: Enumerable<movieWhereUniqueInput>
    delete?: Enumerable<movieWhereUniqueInput>
    connect?: Enumerable<movieWhereUniqueInput>
    update?: Enumerable<movieUpdateWithWhereUniqueWithoutCollectionInput>
    updateMany?: Enumerable<movieUpdateManyWithWhereWithoutCollectionInput>
    deleteMany?: Enumerable<movieScalarWhereInput>
  }

  export type outputCreateNestedOneWithoutAsync_taskInput = {
    create?: XOR<outputCreateWithoutAsync_taskInput, outputUncheckedCreateWithoutAsync_taskInput>
    connectOrCreate?: outputCreateOrConnectWithoutAsync_taskInput
    connect?: outputWhereUniqueInput
  }

  export type userCreateNestedOneWithoutAsync_taskInput = {
    create?: XOR<userCreateWithoutAsync_taskInput, userUncheckedCreateWithoutAsync_taskInput>
    connectOrCreate?: userCreateOrConnectWithoutAsync_taskInput
    connect?: userWhereUniqueInput
  }

  export type outputUpdateOneRequiredWithoutAsync_taskNestedInput = {
    create?: XOR<outputCreateWithoutAsync_taskInput, outputUncheckedCreateWithoutAsync_taskInput>
    connectOrCreate?: outputCreateOrConnectWithoutAsync_taskInput
    upsert?: outputUpsertWithoutAsync_taskInput
    connect?: outputWhereUniqueInput
    update?: XOR<outputUpdateWithoutAsync_taskInput, outputUncheckedUpdateWithoutAsync_taskInput>
  }

  export type userUpdateOneRequiredWithoutAsync_taskNestedInput = {
    create?: XOR<userCreateWithoutAsync_taskInput, userUncheckedCreateWithoutAsync_taskInput>
    connectOrCreate?: userCreateOrConnectWithoutAsync_taskInput
    upsert?: userUpsertWithoutAsync_taskInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutAsync_taskInput, userUncheckedUpdateWithoutAsync_taskInput>
  }

  export type output_lineCreateNestedManyWithoutOutputInput = {
    create?: XOR<Enumerable<output_lineCreateWithoutOutputInput>, Enumerable<output_lineUncheckedCreateWithoutOutputInput>>
    connectOrCreate?: Enumerable<output_lineCreateOrConnectWithoutOutputInput>
    connect?: Enumerable<output_lineWhereUniqueInput>
  }

  export type userCreateNestedOneWithoutOutputsInput = {
    create?: XOR<userCreateWithoutOutputsInput, userUncheckedCreateWithoutOutputsInput>
    connectOrCreate?: userCreateOrConnectWithoutOutputsInput
    connect?: userWhereUniqueInput
  }

  export type async_taskCreateNestedOneWithoutOutputInput = {
    create?: XOR<async_taskCreateWithoutOutputInput, async_taskUncheckedCreateWithoutOutputInput>
    connectOrCreate?: async_taskCreateOrConnectWithoutOutputInput
    connect?: async_taskWhereUniqueInput
  }

  export type output_lineUncheckedCreateNestedManyWithoutOutputInput = {
    create?: XOR<Enumerable<output_lineCreateWithoutOutputInput>, Enumerable<output_lineUncheckedCreateWithoutOutputInput>>
    connectOrCreate?: Enumerable<output_lineCreateOrConnectWithoutOutputInput>
    connect?: Enumerable<output_lineWhereUniqueInput>
  }

  export type async_taskUncheckedCreateNestedOneWithoutOutputInput = {
    create?: XOR<async_taskCreateWithoutOutputInput, async_taskUncheckedCreateWithoutOutputInput>
    connectOrCreate?: async_taskCreateOrConnectWithoutOutputInput
    connect?: async_taskWhereUniqueInput
  }

  export type output_lineUpdateManyWithoutOutputNestedInput = {
    create?: XOR<Enumerable<output_lineCreateWithoutOutputInput>, Enumerable<output_lineUncheckedCreateWithoutOutputInput>>
    connectOrCreate?: Enumerable<output_lineCreateOrConnectWithoutOutputInput>
    upsert?: Enumerable<output_lineUpsertWithWhereUniqueWithoutOutputInput>
    set?: Enumerable<output_lineWhereUniqueInput>
    disconnect?: Enumerable<output_lineWhereUniqueInput>
    delete?: Enumerable<output_lineWhereUniqueInput>
    connect?: Enumerable<output_lineWhereUniqueInput>
    update?: Enumerable<output_lineUpdateWithWhereUniqueWithoutOutputInput>
    updateMany?: Enumerable<output_lineUpdateManyWithWhereWithoutOutputInput>
    deleteMany?: Enumerable<output_lineScalarWhereInput>
  }

  export type userUpdateOneRequiredWithoutOutputsNestedInput = {
    create?: XOR<userCreateWithoutOutputsInput, userUncheckedCreateWithoutOutputsInput>
    connectOrCreate?: userCreateOrConnectWithoutOutputsInput
    upsert?: userUpsertWithoutOutputsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutOutputsInput, userUncheckedUpdateWithoutOutputsInput>
  }

  export type async_taskUpdateOneWithoutOutputNestedInput = {
    create?: XOR<async_taskCreateWithoutOutputInput, async_taskUncheckedCreateWithoutOutputInput>
    connectOrCreate?: async_taskCreateOrConnectWithoutOutputInput
    upsert?: async_taskUpsertWithoutOutputInput
    disconnect?: boolean
    delete?: boolean
    connect?: async_taskWhereUniqueInput
    update?: XOR<async_taskUpdateWithoutOutputInput, async_taskUncheckedUpdateWithoutOutputInput>
  }

  export type output_lineUncheckedUpdateManyWithoutOutputNestedInput = {
    create?: XOR<Enumerable<output_lineCreateWithoutOutputInput>, Enumerable<output_lineUncheckedCreateWithoutOutputInput>>
    connectOrCreate?: Enumerable<output_lineCreateOrConnectWithoutOutputInput>
    upsert?: Enumerable<output_lineUpsertWithWhereUniqueWithoutOutputInput>
    set?: Enumerable<output_lineWhereUniqueInput>
    disconnect?: Enumerable<output_lineWhereUniqueInput>
    delete?: Enumerable<output_lineWhereUniqueInput>
    connect?: Enumerable<output_lineWhereUniqueInput>
    update?: Enumerable<output_lineUpdateWithWhereUniqueWithoutOutputInput>
    updateMany?: Enumerable<output_lineUpdateManyWithWhereWithoutOutputInput>
    deleteMany?: Enumerable<output_lineScalarWhereInput>
  }

  export type async_taskUncheckedUpdateOneWithoutOutputNestedInput = {
    create?: XOR<async_taskCreateWithoutOutputInput, async_taskUncheckedCreateWithoutOutputInput>
    connectOrCreate?: async_taskCreateOrConnectWithoutOutputInput
    upsert?: async_taskUpsertWithoutOutputInput
    disconnect?: boolean
    delete?: boolean
    connect?: async_taskWhereUniqueInput
    update?: XOR<async_taskUpdateWithoutOutputInput, async_taskUncheckedUpdateWithoutOutputInput>
  }

  export type outputCreateNestedOneWithoutLinesInput = {
    create?: XOR<outputCreateWithoutLinesInput, outputUncheckedCreateWithoutLinesInput>
    connectOrCreate?: outputCreateOrConnectWithoutLinesInput
    connect?: outputWhereUniqueInput
  }

  export type outputUpdateOneWithoutLinesNestedInput = {
    create?: XOR<outputCreateWithoutLinesInput, outputUncheckedCreateWithoutLinesInput>
    connectOrCreate?: outputCreateOrConnectWithoutLinesInput
    upsert?: outputUpsertWithoutLinesInput
    disconnect?: boolean
    delete?: boolean
    connect?: outputWhereUniqueInput
    update?: XOR<outputUpdateWithoutLinesInput, outputUncheckedUpdateWithoutLinesInput>
  }

  export type tvCreateNestedOneWithoutPlay_historiesInput = {
    create?: XOR<tvCreateWithoutPlay_historiesInput, tvUncheckedCreateWithoutPlay_historiesInput>
    connectOrCreate?: tvCreateOrConnectWithoutPlay_historiesInput
    connect?: tvWhereUniqueInput
  }

  export type seasonCreateNestedOneWithoutPlay_historiesInput = {
    create?: XOR<seasonCreateWithoutPlay_historiesInput, seasonUncheckedCreateWithoutPlay_historiesInput>
    connectOrCreate?: seasonCreateOrConnectWithoutPlay_historiesInput
    connect?: seasonWhereUniqueInput
  }

  export type episodeCreateNestedOneWithoutPlay_historiesInput = {
    create?: XOR<episodeCreateWithoutPlay_historiesInput, episodeUncheckedCreateWithoutPlay_historiesInput>
    connectOrCreate?: episodeCreateOrConnectWithoutPlay_historiesInput
    connect?: episodeWhereUniqueInput
  }

  export type movieCreateNestedOneWithoutPlay_historiesInput = {
    create?: XOR<movieCreateWithoutPlay_historiesInput, movieUncheckedCreateWithoutPlay_historiesInput>
    connectOrCreate?: movieCreateOrConnectWithoutPlay_historiesInput
    connect?: movieWhereUniqueInput
  }

  export type memberCreateNestedOneWithoutPlay_historiesInput = {
    create?: XOR<memberCreateWithoutPlay_historiesInput, memberUncheckedCreateWithoutPlay_historiesInput>
    connectOrCreate?: memberCreateOrConnectWithoutPlay_historiesInput
    connect?: memberWhereUniqueInput
  }

  export type tvUpdateOneWithoutPlay_historiesNestedInput = {
    create?: XOR<tvCreateWithoutPlay_historiesInput, tvUncheckedCreateWithoutPlay_historiesInput>
    connectOrCreate?: tvCreateOrConnectWithoutPlay_historiesInput
    upsert?: tvUpsertWithoutPlay_historiesInput
    disconnect?: boolean
    delete?: boolean
    connect?: tvWhereUniqueInput
    update?: XOR<tvUpdateWithoutPlay_historiesInput, tvUncheckedUpdateWithoutPlay_historiesInput>
  }

  export type seasonUpdateOneWithoutPlay_historiesNestedInput = {
    create?: XOR<seasonCreateWithoutPlay_historiesInput, seasonUncheckedCreateWithoutPlay_historiesInput>
    connectOrCreate?: seasonCreateOrConnectWithoutPlay_historiesInput
    upsert?: seasonUpsertWithoutPlay_historiesInput
    disconnect?: boolean
    delete?: boolean
    connect?: seasonWhereUniqueInput
    update?: XOR<seasonUpdateWithoutPlay_historiesInput, seasonUncheckedUpdateWithoutPlay_historiesInput>
  }

  export type episodeUpdateOneWithoutPlay_historiesNestedInput = {
    create?: XOR<episodeCreateWithoutPlay_historiesInput, episodeUncheckedCreateWithoutPlay_historiesInput>
    connectOrCreate?: episodeCreateOrConnectWithoutPlay_historiesInput
    upsert?: episodeUpsertWithoutPlay_historiesInput
    disconnect?: boolean
    delete?: boolean
    connect?: episodeWhereUniqueInput
    update?: XOR<episodeUpdateWithoutPlay_historiesInput, episodeUncheckedUpdateWithoutPlay_historiesInput>
  }

  export type movieUpdateOneWithoutPlay_historiesNestedInput = {
    create?: XOR<movieCreateWithoutPlay_historiesInput, movieUncheckedCreateWithoutPlay_historiesInput>
    connectOrCreate?: movieCreateOrConnectWithoutPlay_historiesInput
    upsert?: movieUpsertWithoutPlay_historiesInput
    disconnect?: boolean
    delete?: boolean
    connect?: movieWhereUniqueInput
    update?: XOR<movieUpdateWithoutPlay_historiesInput, movieUncheckedUpdateWithoutPlay_historiesInput>
  }

  export type memberUpdateOneRequiredWithoutPlay_historiesNestedInput = {
    create?: XOR<memberCreateWithoutPlay_historiesInput, memberUncheckedCreateWithoutPlay_historiesInput>
    connectOrCreate?: memberCreateOrConnectWithoutPlay_historiesInput
    upsert?: memberUpsertWithoutPlay_historiesInput
    connect?: memberWhereUniqueInput
    update?: XOR<memberUpdateWithoutPlay_historiesInput, memberUncheckedUpdateWithoutPlay_historiesInput>
  }

  export type tv_profileCreateNestedOneWithoutSnapshotsInput = {
    create?: XOR<tv_profileCreateWithoutSnapshotsInput, tv_profileUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: tv_profileCreateOrConnectWithoutSnapshotsInput
    connect?: tv_profileWhereUniqueInput
  }

  export type tv_profileUpdateOneRequiredWithoutSnapshotsNestedInput = {
    create?: XOR<tv_profileCreateWithoutSnapshotsInput, tv_profileUncheckedCreateWithoutSnapshotsInput>
    connectOrCreate?: tv_profileCreateOrConnectWithoutSnapshotsInput
    upsert?: tv_profileUpsertWithoutSnapshotsInput
    connect?: tv_profileWhereUniqueInput
    update?: XOR<tv_profileUpdateWithoutSnapshotsInput, tv_profileUncheckedUpdateWithoutSnapshotsInput>
  }

  export type userCreateNestedOneWithoutShared_filesInput = {
    create?: XOR<userCreateWithoutShared_filesInput, userUncheckedCreateWithoutShared_filesInput>
    connectOrCreate?: userCreateOrConnectWithoutShared_filesInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutShared_filesNestedInput = {
    create?: XOR<userCreateWithoutShared_filesInput, userUncheckedCreateWithoutShared_filesInput>
    connectOrCreate?: userCreateOrConnectWithoutShared_filesInput
    upsert?: userUpsertWithoutShared_filesInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutShared_filesInput, userUncheckedUpdateWithoutShared_filesInput>
  }

  export type driveCreateNestedOneWithoutShared_file_in_progressInput = {
    create?: XOR<driveCreateWithoutShared_file_in_progressInput, driveUncheckedCreateWithoutShared_file_in_progressInput>
    connectOrCreate?: driveCreateOrConnectWithoutShared_file_in_progressInput
    connect?: driveWhereUniqueInput
  }

  export type userCreateNestedOneWithoutShared_file_in_progressInput = {
    create?: XOR<userCreateWithoutShared_file_in_progressInput, userUncheckedCreateWithoutShared_file_in_progressInput>
    connectOrCreate?: userCreateOrConnectWithoutShared_file_in_progressInput
    connect?: userWhereUniqueInput
  }

  export type driveUpdateOneRequiredWithoutShared_file_in_progressNestedInput = {
    create?: XOR<driveCreateWithoutShared_file_in_progressInput, driveUncheckedCreateWithoutShared_file_in_progressInput>
    connectOrCreate?: driveCreateOrConnectWithoutShared_file_in_progressInput
    upsert?: driveUpsertWithoutShared_file_in_progressInput
    connect?: driveWhereUniqueInput
    update?: XOR<driveUpdateWithoutShared_file_in_progressInput, driveUncheckedUpdateWithoutShared_file_in_progressInput>
  }

  export type userUpdateOneRequiredWithoutShared_file_in_progressNestedInput = {
    create?: XOR<userCreateWithoutShared_file_in_progressInput, userUncheckedCreateWithoutShared_file_in_progressInput>
    connectOrCreate?: userCreateOrConnectWithoutShared_file_in_progressInput
    upsert?: userUpsertWithoutShared_file_in_progressInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutShared_file_in_progressInput, userUncheckedUpdateWithoutShared_file_in_progressInput>
  }

  export type seasonCreateNestedOneWithoutSync_tasksInput = {
    create?: XOR<seasonCreateWithoutSync_tasksInput, seasonUncheckedCreateWithoutSync_tasksInput>
    connectOrCreate?: seasonCreateOrConnectWithoutSync_tasksInput
    connect?: seasonWhereUniqueInput
  }

  export type driveCreateNestedOneWithoutSync_tasksInput = {
    create?: XOR<driveCreateWithoutSync_tasksInput, driveUncheckedCreateWithoutSync_tasksInput>
    connectOrCreate?: driveCreateOrConnectWithoutSync_tasksInput
    connect?: driveWhereUniqueInput
  }

  export type userCreateNestedOneWithoutSync_tasksInput = {
    create?: XOR<userCreateWithoutSync_tasksInput, userUncheckedCreateWithoutSync_tasksInput>
    connectOrCreate?: userCreateOrConnectWithoutSync_tasksInput
    connect?: userWhereUniqueInput
  }

  export type seasonUpdateOneWithoutSync_tasksNestedInput = {
    create?: XOR<seasonCreateWithoutSync_tasksInput, seasonUncheckedCreateWithoutSync_tasksInput>
    connectOrCreate?: seasonCreateOrConnectWithoutSync_tasksInput
    upsert?: seasonUpsertWithoutSync_tasksInput
    disconnect?: boolean
    delete?: boolean
    connect?: seasonWhereUniqueInput
    update?: XOR<seasonUpdateWithoutSync_tasksInput, seasonUncheckedUpdateWithoutSync_tasksInput>
  }

  export type driveUpdateOneRequiredWithoutSync_tasksNestedInput = {
    create?: XOR<driveCreateWithoutSync_tasksInput, driveUncheckedCreateWithoutSync_tasksInput>
    connectOrCreate?: driveCreateOrConnectWithoutSync_tasksInput
    upsert?: driveUpsertWithoutSync_tasksInput
    connect?: driveWhereUniqueInput
    update?: XOR<driveUpdateWithoutSync_tasksInput, driveUncheckedUpdateWithoutSync_tasksInput>
  }

  export type userUpdateOneRequiredWithoutSync_tasksNestedInput = {
    create?: XOR<userCreateWithoutSync_tasksInput, userUncheckedCreateWithoutSync_tasksInput>
    connectOrCreate?: userCreateOrConnectWithoutSync_tasksInput
    upsert?: userUpsertWithoutSync_tasksInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutSync_tasksInput, userUncheckedUpdateWithoutSync_tasksInput>
  }

  export type driveCreateNestedOneWithoutDrive_check_inInput = {
    create?: XOR<driveCreateWithoutDrive_check_inInput, driveUncheckedCreateWithoutDrive_check_inInput>
    connectOrCreate?: driveCreateOrConnectWithoutDrive_check_inInput
    connect?: driveWhereUniqueInput
  }

  export type driveUpdateOneRequiredWithoutDrive_check_inNestedInput = {
    create?: XOR<driveCreateWithoutDrive_check_inInput, driveUncheckedCreateWithoutDrive_check_inInput>
    connectOrCreate?: driveCreateOrConnectWithoutDrive_check_inInput
    upsert?: driveUpsertWithoutDrive_check_inInput
    connect?: driveWhereUniqueInput
    update?: XOR<driveUpdateWithoutDrive_check_inInput, driveUncheckedUpdateWithoutDrive_check_inInput>
  }

  export type driveCreateNestedOneWithoutTmp_filesInput = {
    create?: XOR<driveCreateWithoutTmp_filesInput, driveUncheckedCreateWithoutTmp_filesInput>
    connectOrCreate?: driveCreateOrConnectWithoutTmp_filesInput
    connect?: driveWhereUniqueInput
  }

  export type userCreateNestedOneWithoutTmp_filesInput = {
    create?: XOR<userCreateWithoutTmp_filesInput, userUncheckedCreateWithoutTmp_filesInput>
    connectOrCreate?: userCreateOrConnectWithoutTmp_filesInput
    connect?: userWhereUniqueInput
  }

  export type driveUpdateOneRequiredWithoutTmp_filesNestedInput = {
    create?: XOR<driveCreateWithoutTmp_filesInput, driveUncheckedCreateWithoutTmp_filesInput>
    connectOrCreate?: driveCreateOrConnectWithoutTmp_filesInput
    upsert?: driveUpsertWithoutTmp_filesInput
    connect?: driveWhereUniqueInput
    update?: XOR<driveUpdateWithoutTmp_filesInput, driveUncheckedUpdateWithoutTmp_filesInput>
  }

  export type userUpdateOneRequiredWithoutTmp_filesNestedInput = {
    create?: XOR<userCreateWithoutTmp_filesInput, userUncheckedCreateWithoutTmp_filesInput>
    connectOrCreate?: userCreateOrConnectWithoutTmp_filesInput
    upsert?: userUpsertWithoutTmp_filesInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutTmp_filesInput, userUncheckedUpdateWithoutTmp_filesInput>
  }

  export type userCreateNestedOneWithoutTv_need_completeInput = {
    create?: XOR<userCreateWithoutTv_need_completeInput, userUncheckedCreateWithoutTv_need_completeInput>
    connectOrCreate?: userCreateOrConnectWithoutTv_need_completeInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutTv_need_completeNestedInput = {
    create?: XOR<userCreateWithoutTv_need_completeInput, userUncheckedCreateWithoutTv_need_completeInput>
    connectOrCreate?: userCreateOrConnectWithoutTv_need_completeInput
    upsert?: userUpsertWithoutTv_need_completeInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutTv_need_completeInput, userUncheckedUpdateWithoutTv_need_completeInput>
  }

  export type driveCreateNestedOneWithoutFilesInput = {
    create?: XOR<driveCreateWithoutFilesInput, driveUncheckedCreateWithoutFilesInput>
    connectOrCreate?: driveCreateOrConnectWithoutFilesInput
    connect?: driveWhereUniqueInput
  }

  export type userCreateNestedOneWithoutFilesInput = {
    create?: XOR<userCreateWithoutFilesInput, userUncheckedCreateWithoutFilesInput>
    connectOrCreate?: userCreateOrConnectWithoutFilesInput
    connect?: userWhereUniqueInput
  }

  export type driveUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<driveCreateWithoutFilesInput, driveUncheckedCreateWithoutFilesInput>
    connectOrCreate?: driveCreateOrConnectWithoutFilesInput
    upsert?: driveUpsertWithoutFilesInput
    connect?: driveWhereUniqueInput
    update?: XOR<driveUpdateWithoutFilesInput, driveUncheckedUpdateWithoutFilesInput>
  }

  export type userUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<userCreateWithoutFilesInput, userUncheckedCreateWithoutFilesInput>
    connectOrCreate?: userCreateOrConnectWithoutFilesInput
    upsert?: userUpsertWithoutFilesInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutFilesInput, userUncheckedUpdateWithoutFilesInput>
  }

  export type memberCreateNestedOneWithoutInviteesInput = {
    create?: XOR<memberCreateWithoutInviteesInput, memberUncheckedCreateWithoutInviteesInput>
    connectOrCreate?: memberCreateOrConnectWithoutInviteesInput
    connect?: memberWhereUniqueInput
  }

  export type userCreateNestedOneWithoutMembersInput = {
    create?: XOR<userCreateWithoutMembersInput, userUncheckedCreateWithoutMembersInput>
    connectOrCreate?: userCreateOrConnectWithoutMembersInput
    connect?: userWhereUniqueInput
  }

  export type member_settingCreateNestedOneWithoutMemberInput = {
    create?: XOR<member_settingCreateWithoutMemberInput, member_settingUncheckedCreateWithoutMemberInput>
    connectOrCreate?: member_settingCreateOrConnectWithoutMemberInput
    connect?: member_settingWhereUniqueInput
  }

  export type member_tokenCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<member_tokenCreateWithoutMemberInput>, Enumerable<member_tokenUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<member_tokenCreateOrConnectWithoutMemberInput>
    connect?: Enumerable<member_tokenWhereUniqueInput>
  }

  export type play_historyCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutMemberInput>, Enumerable<play_historyUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutMemberInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<reportCreateWithoutMemberInput>, Enumerable<reportUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutMemberInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type memberCreateNestedManyWithoutInviterInput = {
    create?: XOR<Enumerable<memberCreateWithoutInviterInput>, Enumerable<memberUncheckedCreateWithoutInviterInput>>
    connectOrCreate?: Enumerable<memberCreateOrConnectWithoutInviterInput>
    connect?: Enumerable<memberWhereUniqueInput>
  }

  export type member_notificationCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<member_notificationCreateWithoutMemberInput>, Enumerable<member_notificationUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<member_notificationCreateOrConnectWithoutMemberInput>
    connect?: Enumerable<member_notificationWhereUniqueInput>
  }

  export type member_settingUncheckedCreateNestedOneWithoutMemberInput = {
    create?: XOR<member_settingCreateWithoutMemberInput, member_settingUncheckedCreateWithoutMemberInput>
    connectOrCreate?: member_settingCreateOrConnectWithoutMemberInput
    connect?: member_settingWhereUniqueInput
  }

  export type member_tokenUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<member_tokenCreateWithoutMemberInput>, Enumerable<member_tokenUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<member_tokenCreateOrConnectWithoutMemberInput>
    connect?: Enumerable<member_tokenWhereUniqueInput>
  }

  export type play_historyUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutMemberInput>, Enumerable<play_historyUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutMemberInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<reportCreateWithoutMemberInput>, Enumerable<reportUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutMemberInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type memberUncheckedCreateNestedManyWithoutInviterInput = {
    create?: XOR<Enumerable<memberCreateWithoutInviterInput>, Enumerable<memberUncheckedCreateWithoutInviterInput>>
    connectOrCreate?: Enumerable<memberCreateOrConnectWithoutInviterInput>
    connect?: Enumerable<memberWhereUniqueInput>
  }

  export type member_notificationUncheckedCreateNestedManyWithoutMemberInput = {
    create?: XOR<Enumerable<member_notificationCreateWithoutMemberInput>, Enumerable<member_notificationUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<member_notificationCreateOrConnectWithoutMemberInput>
    connect?: Enumerable<member_notificationWhereUniqueInput>
  }

  export type memberUpdateOneWithoutInviteesNestedInput = {
    create?: XOR<memberCreateWithoutInviteesInput, memberUncheckedCreateWithoutInviteesInput>
    connectOrCreate?: memberCreateOrConnectWithoutInviteesInput
    upsert?: memberUpsertWithoutInviteesInput
    disconnect?: boolean
    delete?: boolean
    connect?: memberWhereUniqueInput
    update?: XOR<memberUpdateWithoutInviteesInput, memberUncheckedUpdateWithoutInviteesInput>
  }

  export type userUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<userCreateWithoutMembersInput, userUncheckedCreateWithoutMembersInput>
    connectOrCreate?: userCreateOrConnectWithoutMembersInput
    upsert?: userUpsertWithoutMembersInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutMembersInput, userUncheckedUpdateWithoutMembersInput>
  }

  export type member_settingUpdateOneWithoutMemberNestedInput = {
    create?: XOR<member_settingCreateWithoutMemberInput, member_settingUncheckedCreateWithoutMemberInput>
    connectOrCreate?: member_settingCreateOrConnectWithoutMemberInput
    upsert?: member_settingUpsertWithoutMemberInput
    disconnect?: boolean
    delete?: boolean
    connect?: member_settingWhereUniqueInput
    update?: XOR<member_settingUpdateWithoutMemberInput, member_settingUncheckedUpdateWithoutMemberInput>
  }

  export type member_tokenUpdateManyWithoutMemberNestedInput = {
    create?: XOR<Enumerable<member_tokenCreateWithoutMemberInput>, Enumerable<member_tokenUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<member_tokenCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<member_tokenUpsertWithWhereUniqueWithoutMemberInput>
    set?: Enumerable<member_tokenWhereUniqueInput>
    disconnect?: Enumerable<member_tokenWhereUniqueInput>
    delete?: Enumerable<member_tokenWhereUniqueInput>
    connect?: Enumerable<member_tokenWhereUniqueInput>
    update?: Enumerable<member_tokenUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<member_tokenUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<member_tokenScalarWhereInput>
  }

  export type play_historyUpdateManyWithoutMemberNestedInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutMemberInput>, Enumerable<play_historyUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<play_historyUpsertWithWhereUniqueWithoutMemberInput>
    set?: Enumerable<play_historyWhereUniqueInput>
    disconnect?: Enumerable<play_historyWhereUniqueInput>
    delete?: Enumerable<play_historyWhereUniqueInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
    update?: Enumerable<play_historyUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<play_historyUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<play_historyScalarWhereInput>
  }

  export type reportUpdateManyWithoutMemberNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutMemberInput>, Enumerable<reportUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutMemberInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type memberUpdateManyWithoutInviterNestedInput = {
    create?: XOR<Enumerable<memberCreateWithoutInviterInput>, Enumerable<memberUncheckedCreateWithoutInviterInput>>
    connectOrCreate?: Enumerable<memberCreateOrConnectWithoutInviterInput>
    upsert?: Enumerable<memberUpsertWithWhereUniqueWithoutInviterInput>
    set?: Enumerable<memberWhereUniqueInput>
    disconnect?: Enumerable<memberWhereUniqueInput>
    delete?: Enumerable<memberWhereUniqueInput>
    connect?: Enumerable<memberWhereUniqueInput>
    update?: Enumerable<memberUpdateWithWhereUniqueWithoutInviterInput>
    updateMany?: Enumerable<memberUpdateManyWithWhereWithoutInviterInput>
    deleteMany?: Enumerable<memberScalarWhereInput>
  }

  export type member_notificationUpdateManyWithoutMemberNestedInput = {
    create?: XOR<Enumerable<member_notificationCreateWithoutMemberInput>, Enumerable<member_notificationUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<member_notificationCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<member_notificationUpsertWithWhereUniqueWithoutMemberInput>
    set?: Enumerable<member_notificationWhereUniqueInput>
    disconnect?: Enumerable<member_notificationWhereUniqueInput>
    delete?: Enumerable<member_notificationWhereUniqueInput>
    connect?: Enumerable<member_notificationWhereUniqueInput>
    update?: Enumerable<member_notificationUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<member_notificationUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<member_notificationScalarWhereInput>
  }

  export type member_settingUncheckedUpdateOneWithoutMemberNestedInput = {
    create?: XOR<member_settingCreateWithoutMemberInput, member_settingUncheckedCreateWithoutMemberInput>
    connectOrCreate?: member_settingCreateOrConnectWithoutMemberInput
    upsert?: member_settingUpsertWithoutMemberInput
    disconnect?: boolean
    delete?: boolean
    connect?: member_settingWhereUniqueInput
    update?: XOR<member_settingUpdateWithoutMemberInput, member_settingUncheckedUpdateWithoutMemberInput>
  }

  export type member_tokenUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<Enumerable<member_tokenCreateWithoutMemberInput>, Enumerable<member_tokenUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<member_tokenCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<member_tokenUpsertWithWhereUniqueWithoutMemberInput>
    set?: Enumerable<member_tokenWhereUniqueInput>
    disconnect?: Enumerable<member_tokenWhereUniqueInput>
    delete?: Enumerable<member_tokenWhereUniqueInput>
    connect?: Enumerable<member_tokenWhereUniqueInput>
    update?: Enumerable<member_tokenUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<member_tokenUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<member_tokenScalarWhereInput>
  }

  export type play_historyUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<Enumerable<play_historyCreateWithoutMemberInput>, Enumerable<play_historyUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<play_historyCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<play_historyUpsertWithWhereUniqueWithoutMemberInput>
    set?: Enumerable<play_historyWhereUniqueInput>
    disconnect?: Enumerable<play_historyWhereUniqueInput>
    delete?: Enumerable<play_historyWhereUniqueInput>
    connect?: Enumerable<play_historyWhereUniqueInput>
    update?: Enumerable<play_historyUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<play_historyUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<play_historyScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutMemberInput>, Enumerable<reportUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutMemberInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type memberUncheckedUpdateManyWithoutInviterNestedInput = {
    create?: XOR<Enumerable<memberCreateWithoutInviterInput>, Enumerable<memberUncheckedCreateWithoutInviterInput>>
    connectOrCreate?: Enumerable<memberCreateOrConnectWithoutInviterInput>
    upsert?: Enumerable<memberUpsertWithWhereUniqueWithoutInviterInput>
    set?: Enumerable<memberWhereUniqueInput>
    disconnect?: Enumerable<memberWhereUniqueInput>
    delete?: Enumerable<memberWhereUniqueInput>
    connect?: Enumerable<memberWhereUniqueInput>
    update?: Enumerable<memberUpdateWithWhereUniqueWithoutInviterInput>
    updateMany?: Enumerable<memberUpdateManyWithWhereWithoutInviterInput>
    deleteMany?: Enumerable<memberScalarWhereInput>
  }

  export type member_notificationUncheckedUpdateManyWithoutMemberNestedInput = {
    create?: XOR<Enumerable<member_notificationCreateWithoutMemberInput>, Enumerable<member_notificationUncheckedCreateWithoutMemberInput>>
    connectOrCreate?: Enumerable<member_notificationCreateOrConnectWithoutMemberInput>
    upsert?: Enumerable<member_notificationUpsertWithWhereUniqueWithoutMemberInput>
    set?: Enumerable<member_notificationWhereUniqueInput>
    disconnect?: Enumerable<member_notificationWhereUniqueInput>
    delete?: Enumerable<member_notificationWhereUniqueInput>
    connect?: Enumerable<member_notificationWhereUniqueInput>
    update?: Enumerable<member_notificationUpdateWithWhereUniqueWithoutMemberInput>
    updateMany?: Enumerable<member_notificationUpdateManyWithWhereWithoutMemberInput>
    deleteMany?: Enumerable<member_notificationScalarWhereInput>
  }

  export type memberCreateNestedOneWithoutMember_tokensInput = {
    create?: XOR<memberCreateWithoutMember_tokensInput, memberUncheckedCreateWithoutMember_tokensInput>
    connectOrCreate?: memberCreateOrConnectWithoutMember_tokensInput
    connect?: memberWhereUniqueInput
  }

  export type memberUpdateOneRequiredWithoutMember_tokensNestedInput = {
    create?: XOR<memberCreateWithoutMember_tokensInput, memberUncheckedCreateWithoutMember_tokensInput>
    connectOrCreate?: memberCreateOrConnectWithoutMember_tokensInput
    upsert?: memberUpsertWithoutMember_tokensInput
    connect?: memberWhereUniqueInput
    update?: XOR<memberUpdateWithoutMember_tokensInput, memberUncheckedUpdateWithoutMember_tokensInput>
  }

  export type memberCreateNestedOneWithoutMember_settingInput = {
    create?: XOR<memberCreateWithoutMember_settingInput, memberUncheckedCreateWithoutMember_settingInput>
    connectOrCreate?: memberCreateOrConnectWithoutMember_settingInput
    connect?: memberWhereUniqueInput
  }

  export type memberUpdateOneRequiredWithoutMember_settingNestedInput = {
    create?: XOR<memberCreateWithoutMember_settingInput, memberUncheckedCreateWithoutMember_settingInput>
    connectOrCreate?: memberCreateOrConnectWithoutMember_settingInput
    upsert?: memberUpsertWithoutMember_settingInput
    connect?: memberWhereUniqueInput
    update?: XOR<memberUpdateWithoutMember_settingInput, memberUncheckedUpdateWithoutMember_settingInput>
  }

  export type userCreateNestedOneWithoutPermissionInput = {
    create?: XOR<userCreateWithoutPermissionInput, userUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: userCreateOrConnectWithoutPermissionInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutPermissionNestedInput = {
    create?: XOR<userCreateWithoutPermissionInput, userUncheckedCreateWithoutPermissionInput>
    connectOrCreate?: userCreateOrConnectWithoutPermissionInput
    upsert?: userUpsertWithoutPermissionInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutPermissionInput, userUncheckedUpdateWithoutPermissionInput>
  }

  export type memberCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<memberCreateWithoutNotificationsInput, memberUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: memberCreateOrConnectWithoutNotificationsInput
    connect?: memberWhereUniqueInput
  }

  export type memberUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<memberCreateWithoutNotificationsInput, memberUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: memberCreateOrConnectWithoutNotificationsInput
    upsert?: memberUpsertWithoutNotificationsInput
    connect?: memberWhereUniqueInput
    update?: XOR<memberUpdateWithoutNotificationsInput, memberUncheckedUpdateWithoutNotificationsInput>
  }

  export type userCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<userCreateWithoutNotificationsInput, userUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<userCreateWithoutNotificationsInput, userUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: userCreateOrConnectWithoutNotificationsInput
    upsert?: userUpsertWithoutNotificationsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutNotificationsInput, userUncheckedUpdateWithoutNotificationsInput>
  }

  export type tvCreateNestedOneWithoutReportsInput = {
    create?: XOR<tvCreateWithoutReportsInput, tvUncheckedCreateWithoutReportsInput>
    connectOrCreate?: tvCreateOrConnectWithoutReportsInput
    connect?: tvWhereUniqueInput
  }

  export type seasonCreateNestedOneWithoutReportsInput = {
    create?: XOR<seasonCreateWithoutReportsInput, seasonUncheckedCreateWithoutReportsInput>
    connectOrCreate?: seasonCreateOrConnectWithoutReportsInput
    connect?: seasonWhereUniqueInput
  }

  export type episodeCreateNestedOneWithoutReportsInput = {
    create?: XOR<episodeCreateWithoutReportsInput, episodeUncheckedCreateWithoutReportsInput>
    connectOrCreate?: episodeCreateOrConnectWithoutReportsInput
    connect?: episodeWhereUniqueInput
  }

  export type movieCreateNestedOneWithoutReportsInput = {
    create?: XOR<movieCreateWithoutReportsInput, movieUncheckedCreateWithoutReportsInput>
    connectOrCreate?: movieCreateOrConnectWithoutReportsInput
    connect?: movieWhereUniqueInput
  }

  export type memberCreateNestedOneWithoutReportsInput = {
    create?: XOR<memberCreateWithoutReportsInput, memberUncheckedCreateWithoutReportsInput>
    connectOrCreate?: memberCreateOrConnectWithoutReportsInput
    connect?: memberWhereUniqueInput
  }

  export type userCreateNestedOneWithoutReportsInput = {
    create?: XOR<userCreateWithoutReportsInput, userUncheckedCreateWithoutReportsInput>
    connectOrCreate?: userCreateOrConnectWithoutReportsInput
    connect?: userWhereUniqueInput
  }

  export type tvUpdateOneWithoutReportsNestedInput = {
    create?: XOR<tvCreateWithoutReportsInput, tvUncheckedCreateWithoutReportsInput>
    connectOrCreate?: tvCreateOrConnectWithoutReportsInput
    upsert?: tvUpsertWithoutReportsInput
    disconnect?: boolean
    delete?: boolean
    connect?: tvWhereUniqueInput
    update?: XOR<tvUpdateWithoutReportsInput, tvUncheckedUpdateWithoutReportsInput>
  }

  export type seasonUpdateOneWithoutReportsNestedInput = {
    create?: XOR<seasonCreateWithoutReportsInput, seasonUncheckedCreateWithoutReportsInput>
    connectOrCreate?: seasonCreateOrConnectWithoutReportsInput
    upsert?: seasonUpsertWithoutReportsInput
    disconnect?: boolean
    delete?: boolean
    connect?: seasonWhereUniqueInput
    update?: XOR<seasonUpdateWithoutReportsInput, seasonUncheckedUpdateWithoutReportsInput>
  }

  export type episodeUpdateOneWithoutReportsNestedInput = {
    create?: XOR<episodeCreateWithoutReportsInput, episodeUncheckedCreateWithoutReportsInput>
    connectOrCreate?: episodeCreateOrConnectWithoutReportsInput
    upsert?: episodeUpsertWithoutReportsInput
    disconnect?: boolean
    delete?: boolean
    connect?: episodeWhereUniqueInput
    update?: XOR<episodeUpdateWithoutReportsInput, episodeUncheckedUpdateWithoutReportsInput>
  }

  export type movieUpdateOneWithoutReportsNestedInput = {
    create?: XOR<movieCreateWithoutReportsInput, movieUncheckedCreateWithoutReportsInput>
    connectOrCreate?: movieCreateOrConnectWithoutReportsInput
    upsert?: movieUpsertWithoutReportsInput
    disconnect?: boolean
    delete?: boolean
    connect?: movieWhereUniqueInput
    update?: XOR<movieUpdateWithoutReportsInput, movieUncheckedUpdateWithoutReportsInput>
  }

  export type memberUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<memberCreateWithoutReportsInput, memberUncheckedCreateWithoutReportsInput>
    connectOrCreate?: memberCreateOrConnectWithoutReportsInput
    upsert?: memberUpsertWithoutReportsInput
    connect?: memberWhereUniqueInput
    update?: XOR<memberUpdateWithoutReportsInput, memberUncheckedUpdateWithoutReportsInput>
  }

  export type userUpdateOneRequiredWithoutReportsNestedInput = {
    create?: XOR<userCreateWithoutReportsInput, userUncheckedCreateWithoutReportsInput>
    connectOrCreate?: userCreateOrConnectWithoutReportsInput
    upsert?: userUpsertWithoutReportsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutReportsInput, userUncheckedUpdateWithoutReportsInput>
  }

  export type userCreateNestedOneWithoutAccountsInput = {
    create?: XOR<userCreateWithoutAccountsInput, userUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: userCreateOrConnectWithoutAccountsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<userCreateWithoutAccountsInput, userUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: userCreateOrConnectWithoutAccountsInput
    upsert?: userUpsertWithoutAccountsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutAccountsInput, userUncheckedUpdateWithoutAccountsInput>
  }

  export type userCreateNestedOneWithoutCredentialInput = {
    create?: XOR<userCreateWithoutCredentialInput, userUncheckedCreateWithoutCredentialInput>
    connectOrCreate?: userCreateOrConnectWithoutCredentialInput
    connect?: userWhereUniqueInput
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type userUpdateOneRequiredWithoutCredentialNestedInput = {
    create?: XOR<userCreateWithoutCredentialInput, userUncheckedCreateWithoutCredentialInput>
    connectOrCreate?: userCreateOrConnectWithoutCredentialInput
    upsert?: userUpsertWithoutCredentialInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutCredentialInput, userUncheckedUpdateWithoutCredentialInput>
  }

  export type userCreateNestedOneWithoutProfileInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutProfileNestedInput = {
    create?: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
    connectOrCreate?: userCreateOrConnectWithoutProfileInput
    upsert?: userUpsertWithoutProfileInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
  }

  export type userCreateNestedOneWithoutSettingsInput = {
    create?: XOR<userCreateWithoutSettingsInput, userUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: userCreateOrConnectWithoutSettingsInput
    connect?: userWhereUniqueInput
  }

  export type userUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<userCreateWithoutSettingsInput, userUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: userCreateOrConnectWithoutSettingsInput
    upsert?: userUpsertWithoutSettingsInput
    connect?: userWhereUniqueInput
    update?: XOR<userUpdateWithoutSettingsInput, userUncheckedUpdateWithoutSettingsInput>
  }

  export type credentialCreateNestedOneWithoutUserInput = {
    create?: XOR<credentialCreateWithoutUserInput, credentialUncheckedCreateWithoutUserInput>
    connectOrCreate?: credentialCreateOrConnectWithoutUserInput
    connect?: credentialWhereUniqueInput
  }

  export type profileCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type settingsCreateNestedOneWithoutUserInput = {
    create?: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: settingsCreateOrConnectWithoutUserInput
    connect?: settingsWhereUniqueInput
  }

  export type accountCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<accountCreateWithoutUserInput>, Enumerable<accountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<accountCreateOrConnectWithoutUserInput>
    connect?: Enumerable<accountWhereUniqueInput>
  }

  export type driveCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<driveCreateWithoutUserInput>, Enumerable<driveUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<driveCreateOrConnectWithoutUserInput>
    connect?: Enumerable<driveWhereUniqueInput>
  }

  export type tvCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<tvCreateWithoutUserInput>, Enumerable<tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutUserInput>
    connect?: Enumerable<tvWhereUniqueInput>
  }

  export type seasonCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<seasonCreateWithoutUserInput>, Enumerable<seasonUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutUserInput>
    connect?: Enumerable<seasonWhereUniqueInput>
  }

  export type episodeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<episodeCreateWithoutUserInput>, Enumerable<episodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutUserInput>
    connect?: Enumerable<episodeWhereUniqueInput>
  }

  export type movieCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<movieCreateWithoutUserInput>, Enumerable<movieUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutUserInput>
    connect?: Enumerable<movieWhereUniqueInput>
  }

  export type parsed_tvCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutUserInput>, Enumerable<parsed_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutUserInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
  }

  export type parsed_seasonCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutUserInput>, Enumerable<parsed_seasonUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutUserInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
  }

  export type parsed_episodeCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutUserInput>, Enumerable<parsed_episodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutUserInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
  }

  export type parsed_movieCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutUserInput>, Enumerable<parsed_movieUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutUserInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
  }

  export type incomplete_tvCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<incomplete_tvCreateWithoutUserInput>, Enumerable<incomplete_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<incomplete_tvCreateOrConnectWithoutUserInput>
    connect?: Enumerable<incomplete_tvWhereUniqueInput>
  }

  export type async_taskCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<async_taskCreateWithoutUserInput>, Enumerable<async_taskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<async_taskCreateOrConnectWithoutUserInput>
    connect?: Enumerable<async_taskWhereUniqueInput>
  }

  export type fileCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<fileCreateWithoutUserInput>, Enumerable<fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<fileCreateOrConnectWithoutUserInput>
    connect?: Enumerable<fileWhereUniqueInput>
  }

  export type memberCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<memberCreateWithoutUserInput>, Enumerable<memberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<memberCreateOrConnectWithoutUserInput>
    connect?: Enumerable<memberWhereUniqueInput>
  }

  export type shared_fileCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<shared_fileCreateWithoutUserInput>, Enumerable<shared_fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<shared_fileCreateOrConnectWithoutUserInput>
    connect?: Enumerable<shared_fileWhereUniqueInput>
  }

  export type shared_file_in_progressCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<shared_file_in_progressCreateWithoutUserInput>, Enumerable<shared_file_in_progressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<shared_file_in_progressCreateOrConnectWithoutUserInput>
    connect?: Enumerable<shared_file_in_progressWhereUniqueInput>
  }

  export type tmp_fileCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<tmp_fileCreateWithoutUserInput>, Enumerable<tmp_fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<tmp_fileCreateOrConnectWithoutUserInput>
    connect?: Enumerable<tmp_fileWhereUniqueInput>
  }

  export type bind_for_parsed_tvCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutUserInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutUserInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
  }

  export type notificationCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<notificationCreateWithoutUserInput>, Enumerable<notificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<notificationCreateOrConnectWithoutUserInput>
    connect?: Enumerable<notificationWhereUniqueInput>
  }

  export type outputCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<outputCreateWithoutUserInput>, Enumerable<outputUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<outputCreateOrConnectWithoutUserInput>
    connect?: Enumerable<outputWhereUniqueInput>
  }

  export type reportCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<reportCreateWithoutUserInput>, Enumerable<reportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutUserInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type collectionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<collectionCreateWithoutUserInput>, Enumerable<collectionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<collectionCreateOrConnectWithoutUserInput>
    connect?: Enumerable<collectionWhereUniqueInput>
  }

  export type subtitleCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutUserInput>, Enumerable<subtitleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutUserInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
  }

  export type permissionCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<permissionCreateWithoutUserInput>, Enumerable<permissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<permissionCreateOrConnectWithoutUserInput>
    connect?: Enumerable<permissionWhereUniqueInput>
  }

  export type credentialUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<credentialCreateWithoutUserInput, credentialUncheckedCreateWithoutUserInput>
    connectOrCreate?: credentialCreateOrConnectWithoutUserInput
    connect?: credentialWhereUniqueInput
  }

  export type profileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    connect?: profileWhereUniqueInput
  }

  export type settingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: settingsCreateOrConnectWithoutUserInput
    connect?: settingsWhereUniqueInput
  }

  export type accountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<accountCreateWithoutUserInput>, Enumerable<accountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<accountCreateOrConnectWithoutUserInput>
    connect?: Enumerable<accountWhereUniqueInput>
  }

  export type driveUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<driveCreateWithoutUserInput>, Enumerable<driveUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<driveCreateOrConnectWithoutUserInput>
    connect?: Enumerable<driveWhereUniqueInput>
  }

  export type tvUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<tvCreateWithoutUserInput>, Enumerable<tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutUserInput>
    connect?: Enumerable<tvWhereUniqueInput>
  }

  export type seasonUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<seasonCreateWithoutUserInput>, Enumerable<seasonUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutUserInput>
    connect?: Enumerable<seasonWhereUniqueInput>
  }

  export type episodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<episodeCreateWithoutUserInput>, Enumerable<episodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutUserInput>
    connect?: Enumerable<episodeWhereUniqueInput>
  }

  export type movieUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<movieCreateWithoutUserInput>, Enumerable<movieUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutUserInput>
    connect?: Enumerable<movieWhereUniqueInput>
  }

  export type parsed_tvUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutUserInput>, Enumerable<parsed_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutUserInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
  }

  export type parsed_seasonUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutUserInput>, Enumerable<parsed_seasonUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutUserInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
  }

  export type parsed_episodeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutUserInput>, Enumerable<parsed_episodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutUserInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
  }

  export type parsed_movieUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutUserInput>, Enumerable<parsed_movieUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutUserInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
  }

  export type incomplete_tvUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<incomplete_tvCreateWithoutUserInput>, Enumerable<incomplete_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<incomplete_tvCreateOrConnectWithoutUserInput>
    connect?: Enumerable<incomplete_tvWhereUniqueInput>
  }

  export type async_taskUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<async_taskCreateWithoutUserInput>, Enumerable<async_taskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<async_taskCreateOrConnectWithoutUserInput>
    connect?: Enumerable<async_taskWhereUniqueInput>
  }

  export type fileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<fileCreateWithoutUserInput>, Enumerable<fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<fileCreateOrConnectWithoutUserInput>
    connect?: Enumerable<fileWhereUniqueInput>
  }

  export type memberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<memberCreateWithoutUserInput>, Enumerable<memberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<memberCreateOrConnectWithoutUserInput>
    connect?: Enumerable<memberWhereUniqueInput>
  }

  export type shared_fileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<shared_fileCreateWithoutUserInput>, Enumerable<shared_fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<shared_fileCreateOrConnectWithoutUserInput>
    connect?: Enumerable<shared_fileWhereUniqueInput>
  }

  export type shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<shared_file_in_progressCreateWithoutUserInput>, Enumerable<shared_file_in_progressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<shared_file_in_progressCreateOrConnectWithoutUserInput>
    connect?: Enumerable<shared_file_in_progressWhereUniqueInput>
  }

  export type tmp_fileUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<tmp_fileCreateWithoutUserInput>, Enumerable<tmp_fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<tmp_fileCreateOrConnectWithoutUserInput>
    connect?: Enumerable<tmp_fileWhereUniqueInput>
  }

  export type bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutUserInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutUserInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
  }

  export type notificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<notificationCreateWithoutUserInput>, Enumerable<notificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<notificationCreateOrConnectWithoutUserInput>
    connect?: Enumerable<notificationWhereUniqueInput>
  }

  export type outputUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<outputCreateWithoutUserInput>, Enumerable<outputUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<outputCreateOrConnectWithoutUserInput>
    connect?: Enumerable<outputWhereUniqueInput>
  }

  export type reportUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<reportCreateWithoutUserInput>, Enumerable<reportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutUserInput>
    connect?: Enumerable<reportWhereUniqueInput>
  }

  export type collectionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<collectionCreateWithoutUserInput>, Enumerable<collectionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<collectionCreateOrConnectWithoutUserInput>
    connect?: Enumerable<collectionWhereUniqueInput>
  }

  export type subtitleUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutUserInput>, Enumerable<subtitleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutUserInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
  }

  export type permissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<Enumerable<permissionCreateWithoutUserInput>, Enumerable<permissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<permissionCreateOrConnectWithoutUserInput>
    connect?: Enumerable<permissionWhereUniqueInput>
  }

  export type credentialUpdateOneWithoutUserNestedInput = {
    create?: XOR<credentialCreateWithoutUserInput, credentialUncheckedCreateWithoutUserInput>
    connectOrCreate?: credentialCreateOrConnectWithoutUserInput
    upsert?: credentialUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: credentialWhereUniqueInput
    update?: XOR<credentialUpdateWithoutUserInput, credentialUncheckedUpdateWithoutUserInput>
  }

  export type profileUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: profileWhereUniqueInput
    update?: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
  }

  export type settingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: settingsCreateOrConnectWithoutUserInput
    upsert?: settingsUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: settingsWhereUniqueInput
    update?: XOR<settingsUpdateWithoutUserInput, settingsUncheckedUpdateWithoutUserInput>
  }

  export type accountUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<accountCreateWithoutUserInput>, Enumerable<accountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<accountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<accountUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<accountWhereUniqueInput>
    disconnect?: Enumerable<accountWhereUniqueInput>
    delete?: Enumerable<accountWhereUniqueInput>
    connect?: Enumerable<accountWhereUniqueInput>
    update?: Enumerable<accountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<accountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<accountScalarWhereInput>
  }

  export type driveUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<driveCreateWithoutUserInput>, Enumerable<driveUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<driveCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<driveUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<driveWhereUniqueInput>
    disconnect?: Enumerable<driveWhereUniqueInput>
    delete?: Enumerable<driveWhereUniqueInput>
    connect?: Enumerable<driveWhereUniqueInput>
    update?: Enumerable<driveUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<driveUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<driveScalarWhereInput>
  }

  export type tvUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<tvCreateWithoutUserInput>, Enumerable<tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<tvUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<tvWhereUniqueInput>
    disconnect?: Enumerable<tvWhereUniqueInput>
    delete?: Enumerable<tvWhereUniqueInput>
    connect?: Enumerable<tvWhereUniqueInput>
    update?: Enumerable<tvUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<tvUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<tvScalarWhereInput>
  }

  export type seasonUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<seasonCreateWithoutUserInput>, Enumerable<seasonUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<seasonUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<seasonWhereUniqueInput>
    disconnect?: Enumerable<seasonWhereUniqueInput>
    delete?: Enumerable<seasonWhereUniqueInput>
    connect?: Enumerable<seasonWhereUniqueInput>
    update?: Enumerable<seasonUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<seasonUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<seasonScalarWhereInput>
  }

  export type episodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<episodeCreateWithoutUserInput>, Enumerable<episodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<episodeUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<episodeWhereUniqueInput>
    disconnect?: Enumerable<episodeWhereUniqueInput>
    delete?: Enumerable<episodeWhereUniqueInput>
    connect?: Enumerable<episodeWhereUniqueInput>
    update?: Enumerable<episodeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<episodeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<episodeScalarWhereInput>
  }

  export type movieUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<movieCreateWithoutUserInput>, Enumerable<movieUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<movieUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<movieWhereUniqueInput>
    disconnect?: Enumerable<movieWhereUniqueInput>
    delete?: Enumerable<movieWhereUniqueInput>
    connect?: Enumerable<movieWhereUniqueInput>
    update?: Enumerable<movieUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<movieUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<movieScalarWhereInput>
  }

  export type parsed_tvUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutUserInput>, Enumerable<parsed_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<parsed_tvUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<parsed_tvWhereUniqueInput>
    delete?: Enumerable<parsed_tvWhereUniqueInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
    update?: Enumerable<parsed_tvUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<parsed_tvUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<parsed_tvScalarWhereInput>
  }

  export type parsed_seasonUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutUserInput>, Enumerable<parsed_seasonUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<parsed_seasonUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<parsed_seasonWhereUniqueInput>
    disconnect?: Enumerable<parsed_seasonWhereUniqueInput>
    delete?: Enumerable<parsed_seasonWhereUniqueInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
    update?: Enumerable<parsed_seasonUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<parsed_seasonUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<parsed_seasonScalarWhereInput>
  }

  export type parsed_episodeUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutUserInput>, Enumerable<parsed_episodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<parsed_episodeUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<parsed_episodeWhereUniqueInput>
    disconnect?: Enumerable<parsed_episodeWhereUniqueInput>
    delete?: Enumerable<parsed_episodeWhereUniqueInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
    update?: Enumerable<parsed_episodeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<parsed_episodeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<parsed_episodeScalarWhereInput>
  }

  export type parsed_movieUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutUserInput>, Enumerable<parsed_movieUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<parsed_movieUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<parsed_movieWhereUniqueInput>
    disconnect?: Enumerable<parsed_movieWhereUniqueInput>
    delete?: Enumerable<parsed_movieWhereUniqueInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
    update?: Enumerable<parsed_movieUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<parsed_movieUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<parsed_movieScalarWhereInput>
  }

  export type incomplete_tvUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<incomplete_tvCreateWithoutUserInput>, Enumerable<incomplete_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<incomplete_tvCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<incomplete_tvUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<incomplete_tvWhereUniqueInput>
    disconnect?: Enumerable<incomplete_tvWhereUniqueInput>
    delete?: Enumerable<incomplete_tvWhereUniqueInput>
    connect?: Enumerable<incomplete_tvWhereUniqueInput>
    update?: Enumerable<incomplete_tvUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<incomplete_tvUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<incomplete_tvScalarWhereInput>
  }

  export type async_taskUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<async_taskCreateWithoutUserInput>, Enumerable<async_taskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<async_taskCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<async_taskUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<async_taskWhereUniqueInput>
    disconnect?: Enumerable<async_taskWhereUniqueInput>
    delete?: Enumerable<async_taskWhereUniqueInput>
    connect?: Enumerable<async_taskWhereUniqueInput>
    update?: Enumerable<async_taskUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<async_taskUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<async_taskScalarWhereInput>
  }

  export type fileUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<fileCreateWithoutUserInput>, Enumerable<fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<fileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<fileUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<fileWhereUniqueInput>
    disconnect?: Enumerable<fileWhereUniqueInput>
    delete?: Enumerable<fileWhereUniqueInput>
    connect?: Enumerable<fileWhereUniqueInput>
    update?: Enumerable<fileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<fileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<fileScalarWhereInput>
  }

  export type memberUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<memberCreateWithoutUserInput>, Enumerable<memberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<memberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<memberUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<memberWhereUniqueInput>
    disconnect?: Enumerable<memberWhereUniqueInput>
    delete?: Enumerable<memberWhereUniqueInput>
    connect?: Enumerable<memberWhereUniqueInput>
    update?: Enumerable<memberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<memberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<memberScalarWhereInput>
  }

  export type shared_fileUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<shared_fileCreateWithoutUserInput>, Enumerable<shared_fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<shared_fileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<shared_fileUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<shared_fileWhereUniqueInput>
    disconnect?: Enumerable<shared_fileWhereUniqueInput>
    delete?: Enumerable<shared_fileWhereUniqueInput>
    connect?: Enumerable<shared_fileWhereUniqueInput>
    update?: Enumerable<shared_fileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<shared_fileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<shared_fileScalarWhereInput>
  }

  export type shared_file_in_progressUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<shared_file_in_progressCreateWithoutUserInput>, Enumerable<shared_file_in_progressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<shared_file_in_progressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<shared_file_in_progressUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<shared_file_in_progressWhereUniqueInput>
    disconnect?: Enumerable<shared_file_in_progressWhereUniqueInput>
    delete?: Enumerable<shared_file_in_progressWhereUniqueInput>
    connect?: Enumerable<shared_file_in_progressWhereUniqueInput>
    update?: Enumerable<shared_file_in_progressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<shared_file_in_progressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<shared_file_in_progressScalarWhereInput>
  }

  export type tmp_fileUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<tmp_fileCreateWithoutUserInput>, Enumerable<tmp_fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<tmp_fileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<tmp_fileUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<tmp_fileWhereUniqueInput>
    disconnect?: Enumerable<tmp_fileWhereUniqueInput>
    delete?: Enumerable<tmp_fileWhereUniqueInput>
    connect?: Enumerable<tmp_fileWhereUniqueInput>
    update?: Enumerable<tmp_fileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<tmp_fileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<tmp_fileScalarWhereInput>
  }

  export type bind_for_parsed_tvUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutUserInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<bind_for_parsed_tvUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    delete?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    update?: Enumerable<bind_for_parsed_tvUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<bind_for_parsed_tvUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<bind_for_parsed_tvScalarWhereInput>
  }

  export type notificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<notificationCreateWithoutUserInput>, Enumerable<notificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<notificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<notificationUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<notificationWhereUniqueInput>
    disconnect?: Enumerable<notificationWhereUniqueInput>
    delete?: Enumerable<notificationWhereUniqueInput>
    connect?: Enumerable<notificationWhereUniqueInput>
    update?: Enumerable<notificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<notificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<notificationScalarWhereInput>
  }

  export type outputUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<outputCreateWithoutUserInput>, Enumerable<outputUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<outputCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<outputUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<outputWhereUniqueInput>
    disconnect?: Enumerable<outputWhereUniqueInput>
    delete?: Enumerable<outputWhereUniqueInput>
    connect?: Enumerable<outputWhereUniqueInput>
    update?: Enumerable<outputUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<outputUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<outputScalarWhereInput>
  }

  export type reportUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutUserInput>, Enumerable<reportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type collectionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<collectionCreateWithoutUserInput>, Enumerable<collectionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<collectionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<collectionUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<collectionWhereUniqueInput>
    disconnect?: Enumerable<collectionWhereUniqueInput>
    delete?: Enumerable<collectionWhereUniqueInput>
    connect?: Enumerable<collectionWhereUniqueInput>
    update?: Enumerable<collectionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<collectionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<collectionScalarWhereInput>
  }

  export type subtitleUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutUserInput>, Enumerable<subtitleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<subtitleUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<subtitleWhereUniqueInput>
    disconnect?: Enumerable<subtitleWhereUniqueInput>
    delete?: Enumerable<subtitleWhereUniqueInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
    update?: Enumerable<subtitleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<subtitleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<subtitleScalarWhereInput>
  }

  export type permissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<permissionCreateWithoutUserInput>, Enumerable<permissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<permissionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<permissionUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<permissionWhereUniqueInput>
    disconnect?: Enumerable<permissionWhereUniqueInput>
    delete?: Enumerable<permissionWhereUniqueInput>
    connect?: Enumerable<permissionWhereUniqueInput>
    update?: Enumerable<permissionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<permissionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<permissionScalarWhereInput>
  }

  export type credentialUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<credentialCreateWithoutUserInput, credentialUncheckedCreateWithoutUserInput>
    connectOrCreate?: credentialCreateOrConnectWithoutUserInput
    upsert?: credentialUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: credentialWhereUniqueInput
    update?: XOR<credentialUpdateWithoutUserInput, credentialUncheckedUpdateWithoutUserInput>
  }

  export type profileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
    connectOrCreate?: profileCreateOrConnectWithoutUserInput
    upsert?: profileUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: profileWhereUniqueInput
    update?: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
  }

  export type settingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: settingsCreateOrConnectWithoutUserInput
    upsert?: settingsUpsertWithoutUserInput
    disconnect?: boolean
    delete?: boolean
    connect?: settingsWhereUniqueInput
    update?: XOR<settingsUpdateWithoutUserInput, settingsUncheckedUpdateWithoutUserInput>
  }

  export type accountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<accountCreateWithoutUserInput>, Enumerable<accountUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<accountCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<accountUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<accountWhereUniqueInput>
    disconnect?: Enumerable<accountWhereUniqueInput>
    delete?: Enumerable<accountWhereUniqueInput>
    connect?: Enumerable<accountWhereUniqueInput>
    update?: Enumerable<accountUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<accountUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<accountScalarWhereInput>
  }

  export type driveUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<driveCreateWithoutUserInput>, Enumerable<driveUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<driveCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<driveUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<driveWhereUniqueInput>
    disconnect?: Enumerable<driveWhereUniqueInput>
    delete?: Enumerable<driveWhereUniqueInput>
    connect?: Enumerable<driveWhereUniqueInput>
    update?: Enumerable<driveUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<driveUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<driveScalarWhereInput>
  }

  export type tvUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<tvCreateWithoutUserInput>, Enumerable<tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<tvCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<tvUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<tvWhereUniqueInput>
    disconnect?: Enumerable<tvWhereUniqueInput>
    delete?: Enumerable<tvWhereUniqueInput>
    connect?: Enumerable<tvWhereUniqueInput>
    update?: Enumerable<tvUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<tvUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<tvScalarWhereInput>
  }

  export type seasonUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<seasonCreateWithoutUserInput>, Enumerable<seasonUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<seasonCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<seasonUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<seasonWhereUniqueInput>
    disconnect?: Enumerable<seasonWhereUniqueInput>
    delete?: Enumerable<seasonWhereUniqueInput>
    connect?: Enumerable<seasonWhereUniqueInput>
    update?: Enumerable<seasonUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<seasonUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<seasonScalarWhereInput>
  }

  export type episodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<episodeCreateWithoutUserInput>, Enumerable<episodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<episodeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<episodeUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<episodeWhereUniqueInput>
    disconnect?: Enumerable<episodeWhereUniqueInput>
    delete?: Enumerable<episodeWhereUniqueInput>
    connect?: Enumerable<episodeWhereUniqueInput>
    update?: Enumerable<episodeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<episodeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<episodeScalarWhereInput>
  }

  export type movieUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<movieCreateWithoutUserInput>, Enumerable<movieUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<movieCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<movieUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<movieWhereUniqueInput>
    disconnect?: Enumerable<movieWhereUniqueInput>
    delete?: Enumerable<movieWhereUniqueInput>
    connect?: Enumerable<movieWhereUniqueInput>
    update?: Enumerable<movieUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<movieUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<movieScalarWhereInput>
  }

  export type parsed_tvUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<parsed_tvCreateWithoutUserInput>, Enumerable<parsed_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_tvCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<parsed_tvUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<parsed_tvWhereUniqueInput>
    delete?: Enumerable<parsed_tvWhereUniqueInput>
    connect?: Enumerable<parsed_tvWhereUniqueInput>
    update?: Enumerable<parsed_tvUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<parsed_tvUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<parsed_tvScalarWhereInput>
  }

  export type parsed_seasonUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<parsed_seasonCreateWithoutUserInput>, Enumerable<parsed_seasonUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_seasonCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<parsed_seasonUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<parsed_seasonWhereUniqueInput>
    disconnect?: Enumerable<parsed_seasonWhereUniqueInput>
    delete?: Enumerable<parsed_seasonWhereUniqueInput>
    connect?: Enumerable<parsed_seasonWhereUniqueInput>
    update?: Enumerable<parsed_seasonUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<parsed_seasonUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<parsed_seasonScalarWhereInput>
  }

  export type parsed_episodeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<parsed_episodeCreateWithoutUserInput>, Enumerable<parsed_episodeUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_episodeCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<parsed_episodeUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<parsed_episodeWhereUniqueInput>
    disconnect?: Enumerable<parsed_episodeWhereUniqueInput>
    delete?: Enumerable<parsed_episodeWhereUniqueInput>
    connect?: Enumerable<parsed_episodeWhereUniqueInput>
    update?: Enumerable<parsed_episodeUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<parsed_episodeUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<parsed_episodeScalarWhereInput>
  }

  export type parsed_movieUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<parsed_movieCreateWithoutUserInput>, Enumerable<parsed_movieUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<parsed_movieCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<parsed_movieUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<parsed_movieWhereUniqueInput>
    disconnect?: Enumerable<parsed_movieWhereUniqueInput>
    delete?: Enumerable<parsed_movieWhereUniqueInput>
    connect?: Enumerable<parsed_movieWhereUniqueInput>
    update?: Enumerable<parsed_movieUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<parsed_movieUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<parsed_movieScalarWhereInput>
  }

  export type incomplete_tvUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<incomplete_tvCreateWithoutUserInput>, Enumerable<incomplete_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<incomplete_tvCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<incomplete_tvUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<incomplete_tvWhereUniqueInput>
    disconnect?: Enumerable<incomplete_tvWhereUniqueInput>
    delete?: Enumerable<incomplete_tvWhereUniqueInput>
    connect?: Enumerable<incomplete_tvWhereUniqueInput>
    update?: Enumerable<incomplete_tvUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<incomplete_tvUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<incomplete_tvScalarWhereInput>
  }

  export type async_taskUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<async_taskCreateWithoutUserInput>, Enumerable<async_taskUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<async_taskCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<async_taskUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<async_taskWhereUniqueInput>
    disconnect?: Enumerable<async_taskWhereUniqueInput>
    delete?: Enumerable<async_taskWhereUniqueInput>
    connect?: Enumerable<async_taskWhereUniqueInput>
    update?: Enumerable<async_taskUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<async_taskUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<async_taskScalarWhereInput>
  }

  export type fileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<fileCreateWithoutUserInput>, Enumerable<fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<fileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<fileUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<fileWhereUniqueInput>
    disconnect?: Enumerable<fileWhereUniqueInput>
    delete?: Enumerable<fileWhereUniqueInput>
    connect?: Enumerable<fileWhereUniqueInput>
    update?: Enumerable<fileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<fileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<fileScalarWhereInput>
  }

  export type memberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<memberCreateWithoutUserInput>, Enumerable<memberUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<memberCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<memberUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<memberWhereUniqueInput>
    disconnect?: Enumerable<memberWhereUniqueInput>
    delete?: Enumerable<memberWhereUniqueInput>
    connect?: Enumerable<memberWhereUniqueInput>
    update?: Enumerable<memberUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<memberUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<memberScalarWhereInput>
  }

  export type shared_fileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<shared_fileCreateWithoutUserInput>, Enumerable<shared_fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<shared_fileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<shared_fileUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<shared_fileWhereUniqueInput>
    disconnect?: Enumerable<shared_fileWhereUniqueInput>
    delete?: Enumerable<shared_fileWhereUniqueInput>
    connect?: Enumerable<shared_fileWhereUniqueInput>
    update?: Enumerable<shared_fileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<shared_fileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<shared_fileScalarWhereInput>
  }

  export type shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<shared_file_in_progressCreateWithoutUserInput>, Enumerable<shared_file_in_progressUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<shared_file_in_progressCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<shared_file_in_progressUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<shared_file_in_progressWhereUniqueInput>
    disconnect?: Enumerable<shared_file_in_progressWhereUniqueInput>
    delete?: Enumerable<shared_file_in_progressWhereUniqueInput>
    connect?: Enumerable<shared_file_in_progressWhereUniqueInput>
    update?: Enumerable<shared_file_in_progressUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<shared_file_in_progressUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<shared_file_in_progressScalarWhereInput>
  }

  export type tmp_fileUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<tmp_fileCreateWithoutUserInput>, Enumerable<tmp_fileUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<tmp_fileCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<tmp_fileUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<tmp_fileWhereUniqueInput>
    disconnect?: Enumerable<tmp_fileWhereUniqueInput>
    delete?: Enumerable<tmp_fileWhereUniqueInput>
    connect?: Enumerable<tmp_fileWhereUniqueInput>
    update?: Enumerable<tmp_fileUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<tmp_fileUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<tmp_fileScalarWhereInput>
  }

  export type bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<bind_for_parsed_tvCreateWithoutUserInput>, Enumerable<bind_for_parsed_tvUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<bind_for_parsed_tvCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<bind_for_parsed_tvUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    disconnect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    delete?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    connect?: Enumerable<bind_for_parsed_tvWhereUniqueInput>
    update?: Enumerable<bind_for_parsed_tvUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<bind_for_parsed_tvUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<bind_for_parsed_tvScalarWhereInput>
  }

  export type notificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<notificationCreateWithoutUserInput>, Enumerable<notificationUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<notificationCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<notificationUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<notificationWhereUniqueInput>
    disconnect?: Enumerable<notificationWhereUniqueInput>
    delete?: Enumerable<notificationWhereUniqueInput>
    connect?: Enumerable<notificationWhereUniqueInput>
    update?: Enumerable<notificationUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<notificationUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<notificationScalarWhereInput>
  }

  export type outputUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<outputCreateWithoutUserInput>, Enumerable<outputUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<outputCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<outputUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<outputWhereUniqueInput>
    disconnect?: Enumerable<outputWhereUniqueInput>
    delete?: Enumerable<outputWhereUniqueInput>
    connect?: Enumerable<outputWhereUniqueInput>
    update?: Enumerable<outputUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<outputUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<outputScalarWhereInput>
  }

  export type reportUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<reportCreateWithoutUserInput>, Enumerable<reportUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<reportCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<reportUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<reportWhereUniqueInput>
    disconnect?: Enumerable<reportWhereUniqueInput>
    delete?: Enumerable<reportWhereUniqueInput>
    connect?: Enumerable<reportWhereUniqueInput>
    update?: Enumerable<reportUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<reportUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<reportScalarWhereInput>
  }

  export type collectionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<collectionCreateWithoutUserInput>, Enumerable<collectionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<collectionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<collectionUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<collectionWhereUniqueInput>
    disconnect?: Enumerable<collectionWhereUniqueInput>
    delete?: Enumerable<collectionWhereUniqueInput>
    connect?: Enumerable<collectionWhereUniqueInput>
    update?: Enumerable<collectionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<collectionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<collectionScalarWhereInput>
  }

  export type subtitleUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<subtitleCreateWithoutUserInput>, Enumerable<subtitleUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<subtitleCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<subtitleUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<subtitleWhereUniqueInput>
    disconnect?: Enumerable<subtitleWhereUniqueInput>
    delete?: Enumerable<subtitleWhereUniqueInput>
    connect?: Enumerable<subtitleWhereUniqueInput>
    update?: Enumerable<subtitleUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<subtitleUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<subtitleScalarWhereInput>
  }

  export type permissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<Enumerable<permissionCreateWithoutUserInput>, Enumerable<permissionUncheckedCreateWithoutUserInput>>
    connectOrCreate?: Enumerable<permissionCreateOrConnectWithoutUserInput>
    upsert?: Enumerable<permissionUpsertWithWhereUniqueWithoutUserInput>
    set?: Enumerable<permissionWhereUniqueInput>
    disconnect?: Enumerable<permissionWhereUniqueInput>
    delete?: Enumerable<permissionWhereUniqueInput>
    connect?: Enumerable<permissionWhereUniqueInput>
    update?: Enumerable<permissionUpdateWithWhereUniqueWithoutUserInput>
    updateMany?: Enumerable<permissionUpdateManyWithWhereWithoutUserInput>
    deleteMany?: Enumerable<permissionScalarWhereInput>
  }

  export type NestedStringFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringFilter | string
  }

  export type NestedDateTimeFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeFilter | Date | string
  }

  export type NestedIntNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableFilter | number | null
  }

  export type NestedStringNullableFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableFilter | string | null
  }

  export type NestedFloatNullableFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableFilter | number | null
  }

  export type NestedDateTimeNullableFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableFilter | Date | string | null
  }

  export type NestedStringWithAggregatesFilter = {
    equals?: string
    in?: Enumerable<string> | string
    notIn?: Enumerable<string> | string
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringWithAggregatesFilter | string
    _count?: NestedIntFilter
    _min?: NestedStringFilter
    _max?: NestedStringFilter
  }

  export type NestedIntFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntFilter | number
  }

  export type NestedDateTimeWithAggregatesFilter = {
    equals?: Date | string
    in?: Enumerable<Date> | Enumerable<string> | Date | string
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeWithAggregatesFilter | Date | string
    _count?: NestedIntFilter
    _min?: NestedDateTimeFilter
    _max?: NestedDateTimeFilter
  }

  export type NestedIntNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedIntNullableFilter
    _min?: NestedIntNullableFilter
    _max?: NestedIntNullableFilter
  }

  export type NestedStringNullableWithAggregatesFilter = {
    equals?: string | null
    in?: Enumerable<string> | string | null
    notIn?: Enumerable<string> | string | null
    lt?: string
    lte?: string
    gt?: string
    gte?: string
    contains?: string
    startsWith?: string
    endsWith?: string
    not?: NestedStringNullableWithAggregatesFilter | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedStringNullableFilter
    _max?: NestedStringNullableFilter
  }

  export type NestedFloatNullableWithAggregatesFilter = {
    equals?: number | null
    in?: Enumerable<number> | number | null
    notIn?: Enumerable<number> | number | null
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatNullableWithAggregatesFilter | number | null
    _count?: NestedIntNullableFilter
    _avg?: NestedFloatNullableFilter
    _sum?: NestedFloatNullableFilter
    _min?: NestedFloatNullableFilter
    _max?: NestedFloatNullableFilter
  }

  export type NestedDateTimeNullableWithAggregatesFilter = {
    equals?: Date | string | null
    in?: Enumerable<Date> | Enumerable<string> | Date | string | null
    notIn?: Enumerable<Date> | Enumerable<string> | Date | string | null
    lt?: Date | string
    lte?: Date | string
    gt?: Date | string
    gte?: Date | string
    not?: NestedDateTimeNullableWithAggregatesFilter | Date | string | null
    _count?: NestedIntNullableFilter
    _min?: NestedDateTimeNullableFilter
    _max?: NestedDateTimeNullableFilter
  }

  export type NestedFloatFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatFilter | number
  }

  export type NestedFloatWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedFloatWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedFloatFilter
    _min?: NestedFloatFilter
    _max?: NestedFloatFilter
  }

  export type NestedIntWithAggregatesFilter = {
    equals?: number
    in?: Enumerable<number> | number
    notIn?: Enumerable<number> | number
    lt?: number
    lte?: number
    gt?: number
    gte?: number
    not?: NestedIntWithAggregatesFilter | number
    _count?: NestedIntFilter
    _avg?: NestedFloatFilter
    _sum?: NestedIntFilter
    _min?: NestedIntFilter
    _max?: NestedIntFilter
  }

  export type NestedBoolFilter = {
    equals?: boolean
    not?: NestedBoolFilter | boolean
  }

  export type NestedBoolWithAggregatesFilter = {
    equals?: boolean
    not?: NestedBoolWithAggregatesFilter | boolean
    _count?: NestedIntFilter
    _min?: NestedBoolFilter
    _max?: NestedBoolFilter
  }

  export type drive_tokenCreateWithoutDrivesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    data: string
    expired_at: number
  }

  export type drive_tokenUncheckedCreateWithoutDrivesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    data: string
    expired_at: number
  }

  export type drive_tokenCreateOrConnectWithoutDrivesInput = {
    where: drive_tokenWhereUniqueInput
    create: XOR<drive_tokenCreateWithoutDrivesInput, drive_tokenUncheckedCreateWithoutDrivesInput>
  }

  export type userCreateWithoutDrivesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutDrivesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutDrivesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutDrivesInput, userUncheckedCreateWithoutDrivesInput>
  }

  export type parsed_tvCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    tv?: tvCreateNestedOneWithoutParsed_tvsInput
    user: userCreateNestedOneWithoutParsed_tvsInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutParsed_tvInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvUncheckedCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    tv_id?: string | null
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutParsed_tvInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvCreateOrConnectWithoutDriveInput = {
    where: parsed_tvWhereUniqueInput
    create: XOR<parsed_tvCreateWithoutDriveInput, parsed_tvUncheckedCreateWithoutDriveInput>
  }

  export type parsed_seasonCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    season?: seasonCreateNestedOneWithoutParsed_seasonInput
    parsed_tv: parsed_tvCreateNestedOneWithoutParsed_seasonsInput
    user: userCreateNestedOneWithoutParsed_seasonsInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutParsed_seasonInput
  }

  export type parsed_seasonUncheckedCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    season_id?: string | null
    parsed_tv_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutParsed_seasonInput
  }

  export type parsed_seasonCreateOrConnectWithoutDriveInput = {
    where: parsed_seasonWhereUniqueInput
    create: XOR<parsed_seasonCreateWithoutDriveInput, parsed_seasonUncheckedCreateWithoutDriveInput>
  }

  export type parsed_episodeCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    episode?: episodeCreateNestedOneWithoutParsed_episodesInput
    parsed_tv: parsed_tvCreateNestedOneWithoutParsed_episodesInput
    parsed_season: parsed_seasonCreateNestedOneWithoutParsed_episodesInput
    user: userCreateNestedOneWithoutParsed_episodesInput
  }

  export type parsed_episodeUncheckedCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    episode_id?: string | null
    parsed_tv_id: string
    parsed_season_id: string
    user_id: string
  }

  export type parsed_episodeCreateOrConnectWithoutDriveInput = {
    where: parsed_episodeWhereUniqueInput
    create: XOR<parsed_episodeCreateWithoutDriveInput, parsed_episodeUncheckedCreateWithoutDriveInput>
  }

  export type drive_check_inCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    checked_at?: Date | string | null
  }

  export type drive_check_inUncheckedCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    checked_at?: Date | string | null
  }

  export type drive_check_inCreateOrConnectWithoutDriveInput = {
    where: drive_check_inWhereUniqueInput
    create: XOR<drive_check_inCreateWithoutDriveInput, drive_check_inUncheckedCreateWithoutDriveInput>
  }

  export type fileCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    user: userCreateNestedOneWithoutFilesInput
  }

  export type fileUncheckedCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    user_id: string
  }

  export type fileCreateOrConnectWithoutDriveInput = {
    where: fileWhereUniqueInput
    create: XOR<fileCreateWithoutDriveInput, fileUncheckedCreateWithoutDriveInput>
  }

  export type tmp_fileCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    type?: number | null
    parent_paths: string
    user: userCreateNestedOneWithoutTmp_filesInput
  }

  export type tmp_fileUncheckedCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    type?: number | null
    parent_paths: string
    user_id: string
  }

  export type tmp_fileCreateOrConnectWithoutDriveInput = {
    where: tmp_fileWhereUniqueInput
    create: XOR<tmp_fileCreateWithoutDriveInput, tmp_fileUncheckedCreateWithoutDriveInput>
  }

  export type parsed_movieCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    original_name?: string | null
    correct_name?: string | null
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    movie?: movieCreateNestedOneWithoutParsed_moviesInput
    user: userCreateNestedOneWithoutParsed_moviesInput
  }

  export type parsed_movieUncheckedCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    original_name?: string | null
    correct_name?: string | null
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    movie_id?: string | null
    user_id: string
  }

  export type parsed_movieCreateOrConnectWithoutDriveInput = {
    where: parsed_movieWhereUniqueInput
    create: XOR<parsed_movieCreateWithoutDriveInput, parsed_movieUncheckedCreateWithoutDriveInput>
  }

  export type shared_file_in_progressCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    user: userCreateNestedOneWithoutShared_file_in_progressInput
  }

  export type shared_file_in_progressUncheckedCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    user_id: string
  }

  export type shared_file_in_progressCreateOrConnectWithoutDriveInput = {
    where: shared_file_in_progressWhereUniqueInput
    create: XOR<shared_file_in_progressCreateWithoutDriveInput, shared_file_in_progressUncheckedCreateWithoutDriveInput>
  }

  export type subtitleCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    language: string
    movie?: movieCreateNestedOneWithoutSubtitlesInput
    episode?: episodeCreateNestedOneWithoutSubtitlesInput
    user: userCreateNestedOneWithoutSubtitlesInput
  }

  export type subtitleUncheckedCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    language: string
    movie_id?: string | null
    episode_id?: string | null
    user_id: string
  }

  export type subtitleCreateOrConnectWithoutDriveInput = {
    where: subtitleWhereUniqueInput
    create: XOR<subtitleCreateWithoutDriveInput, subtitleUncheckedCreateWithoutDriveInput>
  }

  export type bind_for_parsed_tvCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    file_id_link_resource: string
    file_name_link_resource: string
    in_production?: number | null
    invalid?: number | null
    season?: seasonCreateNestedOneWithoutSync_tasksInput
    user: userCreateNestedOneWithoutSync_tasksInput
  }

  export type bind_for_parsed_tvUncheckedCreateWithoutDriveInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    file_id_link_resource: string
    file_name_link_resource: string
    in_production?: number | null
    invalid?: number | null
    season_id?: string | null
    user_id: string
  }

  export type bind_for_parsed_tvCreateOrConnectWithoutDriveInput = {
    where: bind_for_parsed_tvWhereUniqueInput
    create: XOR<bind_for_parsed_tvCreateWithoutDriveInput, bind_for_parsed_tvUncheckedCreateWithoutDriveInput>
  }

  export type drive_tokenUpsertWithoutDrivesInput = {
    update: XOR<drive_tokenUpdateWithoutDrivesInput, drive_tokenUncheckedUpdateWithoutDrivesInput>
    create: XOR<drive_tokenCreateWithoutDrivesInput, drive_tokenUncheckedCreateWithoutDrivesInput>
  }

  export type drive_tokenUpdateWithoutDrivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    expired_at?: FloatFieldUpdateOperationsInput | number
  }

  export type drive_tokenUncheckedUpdateWithoutDrivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
    expired_at?: FloatFieldUpdateOperationsInput | number
  }

  export type userUpsertWithoutDrivesInput = {
    update: XOR<userUpdateWithoutDrivesInput, userUncheckedUpdateWithoutDrivesInput>
    create: XOR<userCreateWithoutDrivesInput, userUncheckedCreateWithoutDrivesInput>
  }

  export type userUpdateWithoutDrivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutDrivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type parsed_tvUpsertWithWhereUniqueWithoutDriveInput = {
    where: parsed_tvWhereUniqueInput
    update: XOR<parsed_tvUpdateWithoutDriveInput, parsed_tvUncheckedUpdateWithoutDriveInput>
    create: XOR<parsed_tvCreateWithoutDriveInput, parsed_tvUncheckedCreateWithoutDriveInput>
  }

  export type parsed_tvUpdateWithWhereUniqueWithoutDriveInput = {
    where: parsed_tvWhereUniqueInput
    data: XOR<parsed_tvUpdateWithoutDriveInput, parsed_tvUncheckedUpdateWithoutDriveInput>
  }

  export type parsed_tvUpdateManyWithWhereWithoutDriveInput = {
    where: parsed_tvScalarWhereInput
    data: XOR<parsed_tvUpdateManyMutationInput, parsed_tvUncheckedUpdateManyWithoutParsed_tvsInput>
  }

  export type parsed_tvScalarWhereInput = {
    AND?: Enumerable<parsed_tvScalarWhereInput>
    OR?: Enumerable<parsed_tvScalarWhereInput>
    NOT?: Enumerable<parsed_tvScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    name?: StringNullableFilter | string | null
    original_name?: StringNullableFilter | string | null
    file_id?: StringNullableFilter | string | null
    file_name?: StringNullableFilter | string | null
    can_search?: IntNullableFilter | number | null
    correct_name?: StringNullableFilter | string | null
    tmdb_id?: IntNullableFilter | number | null
    tv_id?: StringNullableFilter | string | null
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type parsed_seasonUpsertWithWhereUniqueWithoutDriveInput = {
    where: parsed_seasonWhereUniqueInput
    update: XOR<parsed_seasonUpdateWithoutDriveInput, parsed_seasonUncheckedUpdateWithoutDriveInput>
    create: XOR<parsed_seasonCreateWithoutDriveInput, parsed_seasonUncheckedCreateWithoutDriveInput>
  }

  export type parsed_seasonUpdateWithWhereUniqueWithoutDriveInput = {
    where: parsed_seasonWhereUniqueInput
    data: XOR<parsed_seasonUpdateWithoutDriveInput, parsed_seasonUncheckedUpdateWithoutDriveInput>
  }

  export type parsed_seasonUpdateManyWithWhereWithoutDriveInput = {
    where: parsed_seasonScalarWhereInput
    data: XOR<parsed_seasonUpdateManyMutationInput, parsed_seasonUncheckedUpdateManyWithoutParsed_seasonsInput>
  }

  export type parsed_seasonScalarWhereInput = {
    AND?: Enumerable<parsed_seasonScalarWhereInput>
    OR?: Enumerable<parsed_seasonScalarWhereInput>
    NOT?: Enumerable<parsed_seasonScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    season_number?: StringFilter | string
    file_id?: StringNullableFilter | string | null
    file_name?: StringNullableFilter | string | null
    can_search?: IntNullableFilter | number | null
    correct_season_number?: StringNullableFilter | string | null
    season_id?: StringNullableFilter | string | null
    parsed_tv_id?: StringFilter | string
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type parsed_episodeUpsertWithWhereUniqueWithoutDriveInput = {
    where: parsed_episodeWhereUniqueInput
    update: XOR<parsed_episodeUpdateWithoutDriveInput, parsed_episodeUncheckedUpdateWithoutDriveInput>
    create: XOR<parsed_episodeCreateWithoutDriveInput, parsed_episodeUncheckedCreateWithoutDriveInput>
  }

  export type parsed_episodeUpdateWithWhereUniqueWithoutDriveInput = {
    where: parsed_episodeWhereUniqueInput
    data: XOR<parsed_episodeUpdateWithoutDriveInput, parsed_episodeUncheckedUpdateWithoutDriveInput>
  }

  export type parsed_episodeUpdateManyWithWhereWithoutDriveInput = {
    where: parsed_episodeScalarWhereInput
    data: XOR<parsed_episodeUpdateManyMutationInput, parsed_episodeUncheckedUpdateManyWithoutParsed_episodesInput>
  }

  export type parsed_episodeScalarWhereInput = {
    AND?: Enumerable<parsed_episodeScalarWhereInput>
    OR?: Enumerable<parsed_episodeScalarWhereInput>
    NOT?: Enumerable<parsed_episodeScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    episode_number?: StringFilter | string
    season_number?: StringFilter | string
    name?: StringFilter | string
    file_id?: StringFilter | string
    file_name?: StringFilter | string
    parent_file_id?: StringFilter | string
    parent_paths?: StringFilter | string
    type?: IntFilter | number
    size?: FloatNullableFilter | number | null
    can_search?: IntNullableFilter | number | null
    episode_id?: StringNullableFilter | string | null
    parsed_tv_id?: StringFilter | string
    parsed_season_id?: StringFilter | string
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type drive_check_inUpsertWithWhereUniqueWithoutDriveInput = {
    where: drive_check_inWhereUniqueInput
    update: XOR<drive_check_inUpdateWithoutDriveInput, drive_check_inUncheckedUpdateWithoutDriveInput>
    create: XOR<drive_check_inCreateWithoutDriveInput, drive_check_inUncheckedCreateWithoutDriveInput>
  }

  export type drive_check_inUpdateWithWhereUniqueWithoutDriveInput = {
    where: drive_check_inWhereUniqueInput
    data: XOR<drive_check_inUpdateWithoutDriveInput, drive_check_inUncheckedUpdateWithoutDriveInput>
  }

  export type drive_check_inUpdateManyWithWhereWithoutDriveInput = {
    where: drive_check_inScalarWhereInput
    data: XOR<drive_check_inUpdateManyMutationInput, drive_check_inUncheckedUpdateManyWithoutDrive_check_inInput>
  }

  export type drive_check_inScalarWhereInput = {
    AND?: Enumerable<drive_check_inScalarWhereInput>
    OR?: Enumerable<drive_check_inScalarWhereInput>
    NOT?: Enumerable<drive_check_inScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    checked_at?: DateTimeNullableFilter | Date | string | null
    drive_id?: StringFilter | string
  }

  export type fileUpsertWithWhereUniqueWithoutDriveInput = {
    where: fileWhereUniqueInput
    update: XOR<fileUpdateWithoutDriveInput, fileUncheckedUpdateWithoutDriveInput>
    create: XOR<fileCreateWithoutDriveInput, fileUncheckedCreateWithoutDriveInput>
  }

  export type fileUpdateWithWhereUniqueWithoutDriveInput = {
    where: fileWhereUniqueInput
    data: XOR<fileUpdateWithoutDriveInput, fileUncheckedUpdateWithoutDriveInput>
  }

  export type fileUpdateManyWithWhereWithoutDriveInput = {
    where: fileScalarWhereInput
    data: XOR<fileUpdateManyMutationInput, fileUncheckedUpdateManyWithoutFilesInput>
  }

  export type fileScalarWhereInput = {
    AND?: Enumerable<fileScalarWhereInput>
    OR?: Enumerable<fileScalarWhereInput>
    NOT?: Enumerable<fileScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    file_id?: StringFilter | string
    name?: StringFilter | string
    parent_file_id?: StringFilter | string
    parent_paths?: StringFilter | string
    type?: IntFilter | number
    size?: FloatNullableFilter | number | null
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type tmp_fileUpsertWithWhereUniqueWithoutDriveInput = {
    where: tmp_fileWhereUniqueInput
    update: XOR<tmp_fileUpdateWithoutDriveInput, tmp_fileUncheckedUpdateWithoutDriveInput>
    create: XOR<tmp_fileCreateWithoutDriveInput, tmp_fileUncheckedCreateWithoutDriveInput>
  }

  export type tmp_fileUpdateWithWhereUniqueWithoutDriveInput = {
    where: tmp_fileWhereUniqueInput
    data: XOR<tmp_fileUpdateWithoutDriveInput, tmp_fileUncheckedUpdateWithoutDriveInput>
  }

  export type tmp_fileUpdateManyWithWhereWithoutDriveInput = {
    where: tmp_fileScalarWhereInput
    data: XOR<tmp_fileUpdateManyMutationInput, tmp_fileUncheckedUpdateManyWithoutTmp_filesInput>
  }

  export type tmp_fileScalarWhereInput = {
    AND?: Enumerable<tmp_fileScalarWhereInput>
    OR?: Enumerable<tmp_fileScalarWhereInput>
    NOT?: Enumerable<tmp_fileScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    name?: StringFilter | string
    type?: FloatNullableFilter | number | null
    parent_paths?: StringFilter | string
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type parsed_movieUpsertWithWhereUniqueWithoutDriveInput = {
    where: parsed_movieWhereUniqueInput
    update: XOR<parsed_movieUpdateWithoutDriveInput, parsed_movieUncheckedUpdateWithoutDriveInput>
    create: XOR<parsed_movieCreateWithoutDriveInput, parsed_movieUncheckedCreateWithoutDriveInput>
  }

  export type parsed_movieUpdateWithWhereUniqueWithoutDriveInput = {
    where: parsed_movieWhereUniqueInput
    data: XOR<parsed_movieUpdateWithoutDriveInput, parsed_movieUncheckedUpdateWithoutDriveInput>
  }

  export type parsed_movieUpdateManyWithWhereWithoutDriveInput = {
    where: parsed_movieScalarWhereInput
    data: XOR<parsed_movieUpdateManyMutationInput, parsed_movieUncheckedUpdateManyWithoutParsed_moviesInput>
  }

  export type parsed_movieScalarWhereInput = {
    AND?: Enumerable<parsed_movieScalarWhereInput>
    OR?: Enumerable<parsed_movieScalarWhereInput>
    NOT?: Enumerable<parsed_movieScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    name?: StringFilter | string
    original_name?: StringNullableFilter | string | null
    correct_name?: StringNullableFilter | string | null
    file_id?: StringFilter | string
    file_name?: StringFilter | string
    parent_file_id?: StringFilter | string
    parent_paths?: StringFilter | string
    type?: IntFilter | number
    size?: FloatNullableFilter | number | null
    can_search?: IntNullableFilter | number | null
    movie_id?: StringNullableFilter | string | null
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type shared_file_in_progressUpsertWithWhereUniqueWithoutDriveInput = {
    where: shared_file_in_progressWhereUniqueInput
    update: XOR<shared_file_in_progressUpdateWithoutDriveInput, shared_file_in_progressUncheckedUpdateWithoutDriveInput>
    create: XOR<shared_file_in_progressCreateWithoutDriveInput, shared_file_in_progressUncheckedCreateWithoutDriveInput>
  }

  export type shared_file_in_progressUpdateWithWhereUniqueWithoutDriveInput = {
    where: shared_file_in_progressWhereUniqueInput
    data: XOR<shared_file_in_progressUpdateWithoutDriveInput, shared_file_in_progressUncheckedUpdateWithoutDriveInput>
  }

  export type shared_file_in_progressUpdateManyWithWhereWithoutDriveInput = {
    where: shared_file_in_progressScalarWhereInput
    data: XOR<shared_file_in_progressUpdateManyMutationInput, shared_file_in_progressUncheckedUpdateManyWithoutShared_file_in_progressInput>
  }

  export type shared_file_in_progressScalarWhereInput = {
    AND?: Enumerable<shared_file_in_progressScalarWhereInput>
    OR?: Enumerable<shared_file_in_progressScalarWhereInput>
    NOT?: Enumerable<shared_file_in_progressScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    url?: StringFilter | string
    file_id?: StringFilter | string
    name?: StringFilter | string
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type subtitleUpsertWithWhereUniqueWithoutDriveInput = {
    where: subtitleWhereUniqueInput
    update: XOR<subtitleUpdateWithoutDriveInput, subtitleUncheckedUpdateWithoutDriveInput>
    create: XOR<subtitleCreateWithoutDriveInput, subtitleUncheckedCreateWithoutDriveInput>
  }

  export type subtitleUpdateWithWhereUniqueWithoutDriveInput = {
    where: subtitleWhereUniqueInput
    data: XOR<subtitleUpdateWithoutDriveInput, subtitleUncheckedUpdateWithoutDriveInput>
  }

  export type subtitleUpdateManyWithWhereWithoutDriveInput = {
    where: subtitleScalarWhereInput
    data: XOR<subtitleUpdateManyMutationInput, subtitleUncheckedUpdateManyWithoutSubtitlesInput>
  }

  export type subtitleScalarWhereInput = {
    AND?: Enumerable<subtitleScalarWhereInput>
    OR?: Enumerable<subtitleScalarWhereInput>
    NOT?: Enumerable<subtitleScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    file_id?: StringFilter | string
    name?: StringFilter | string
    language?: StringFilter | string
    movie_id?: StringNullableFilter | string | null
    episode_id?: StringNullableFilter | string | null
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type bind_for_parsed_tvUpsertWithWhereUniqueWithoutDriveInput = {
    where: bind_for_parsed_tvWhereUniqueInput
    update: XOR<bind_for_parsed_tvUpdateWithoutDriveInput, bind_for_parsed_tvUncheckedUpdateWithoutDriveInput>
    create: XOR<bind_for_parsed_tvCreateWithoutDriveInput, bind_for_parsed_tvUncheckedCreateWithoutDriveInput>
  }

  export type bind_for_parsed_tvUpdateWithWhereUniqueWithoutDriveInput = {
    where: bind_for_parsed_tvWhereUniqueInput
    data: XOR<bind_for_parsed_tvUpdateWithoutDriveInput, bind_for_parsed_tvUncheckedUpdateWithoutDriveInput>
  }

  export type bind_for_parsed_tvUpdateManyWithWhereWithoutDriveInput = {
    where: bind_for_parsed_tvScalarWhereInput
    data: XOR<bind_for_parsed_tvUpdateManyMutationInput, bind_for_parsed_tvUncheckedUpdateManyWithoutSync_tasksInput>
  }

  export type bind_for_parsed_tvScalarWhereInput = {
    AND?: Enumerable<bind_for_parsed_tvScalarWhereInput>
    OR?: Enumerable<bind_for_parsed_tvScalarWhereInput>
    NOT?: Enumerable<bind_for_parsed_tvScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    url?: StringFilter | string
    file_id?: StringFilter | string
    name?: StringFilter | string
    file_id_link_resource?: StringFilter | string
    file_name_link_resource?: StringFilter | string
    in_production?: IntNullableFilter | number | null
    invalid?: IntNullableFilter | number | null
    season_id?: StringNullableFilter | string | null
    drive_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type driveCreateWithoutDrive_tokenInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    user: userCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutDrive_tokenInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    user_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutDrive_tokenInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutDrive_tokenInput, driveUncheckedCreateWithoutDrive_tokenInput>
  }

  export type driveUpsertWithWhereUniqueWithoutDrive_tokenInput = {
    where: driveWhereUniqueInput
    update: XOR<driveUpdateWithoutDrive_tokenInput, driveUncheckedUpdateWithoutDrive_tokenInput>
    create: XOR<driveCreateWithoutDrive_tokenInput, driveUncheckedCreateWithoutDrive_tokenInput>
  }

  export type driveUpdateWithWhereUniqueWithoutDrive_tokenInput = {
    where: driveWhereUniqueInput
    data: XOR<driveUpdateWithoutDrive_tokenInput, driveUncheckedUpdateWithoutDrive_tokenInput>
  }

  export type driveUpdateManyWithWhereWithoutDrive_tokenInput = {
    where: driveScalarWhereInput
    data: XOR<driveUpdateManyMutationInput, driveUncheckedUpdateManyWithoutDrivesInput>
  }

  export type driveScalarWhereInput = {
    AND?: Enumerable<driveScalarWhereInput>
    OR?: Enumerable<driveScalarWhereInput>
    NOT?: Enumerable<driveScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    type?: IntNullableFilter | number | null
    name?: StringFilter | string
    remark?: StringNullableFilter | string | null
    avatar?: StringFilter | string
    profile?: StringFilter | string
    total_size?: FloatNullableFilter | number | null
    used_size?: FloatNullableFilter | number | null
    invalid?: IntNullableFilter | number | null
    latest_analysis?: DateTimeNullableFilter | Date | string | null
    root_folder_name?: StringNullableFilter | string | null
    root_folder_id?: StringNullableFilter | string | null
    drive_token_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type tvCreateWithoutProfileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    collection?: collectionCreateNestedOneWithoutTvsInput
    user: userCreateNestedOneWithoutTvInput
    seasons?: seasonCreateNestedManyWithoutTvInput
    episodes?: episodeCreateNestedManyWithoutTvInput
    play_histories?: play_historyCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutTvInput
    reports?: reportCreateNestedManyWithoutTvInput
  }

  export type tvUncheckedCreateWithoutProfileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    collection_id?: string | null
    user_id: string
    seasons?: seasonUncheckedCreateNestedManyWithoutTvInput
    episodes?: episodeUncheckedCreateNestedManyWithoutTvInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutTvInput
    reports?: reportUncheckedCreateNestedManyWithoutTvInput
  }

  export type tvCreateOrConnectWithoutProfileInput = {
    where: tvWhereUniqueInput
    create: XOR<tvCreateWithoutProfileInput, tvUncheckedCreateWithoutProfileInput>
  }

  export type tv_profile_quickCreateWithoutTv_profileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
  }

  export type tv_profile_quickUncheckedCreateWithoutTv_profileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
  }

  export type tv_profile_quickCreateOrConnectWithoutTv_profileInput = {
    where: tv_profile_quickWhereUniqueInput
    create: XOR<tv_profile_quickCreateWithoutTv_profileInput, tv_profile_quickUncheckedCreateWithoutTv_profileInput>
  }

  export type tvUpsertWithWhereUniqueWithoutProfileInput = {
    where: tvWhereUniqueInput
    update: XOR<tvUpdateWithoutProfileInput, tvUncheckedUpdateWithoutProfileInput>
    create: XOR<tvCreateWithoutProfileInput, tvUncheckedCreateWithoutProfileInput>
  }

  export type tvUpdateWithWhereUniqueWithoutProfileInput = {
    where: tvWhereUniqueInput
    data: XOR<tvUpdateWithoutProfileInput, tvUncheckedUpdateWithoutProfileInput>
  }

  export type tvUpdateManyWithWhereWithoutProfileInput = {
    where: tvScalarWhereInput
    data: XOR<tvUpdateManyMutationInput, tvUncheckedUpdateManyWithoutTvsInput>
  }

  export type tvScalarWhereInput = {
    AND?: Enumerable<tvScalarWhereInput>
    OR?: Enumerable<tvScalarWhereInput>
    NOT?: Enumerable<tvScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    hidden?: IntNullableFilter | number | null
    profile_id?: StringFilter | string
    collection_id?: StringNullableFilter | string | null
    user_id?: StringFilter | string
  }

  export type tv_profile_quickUpsertWithWhereUniqueWithoutTv_profileInput = {
    where: tv_profile_quickWhereUniqueInput
    update: XOR<tv_profile_quickUpdateWithoutTv_profileInput, tv_profile_quickUncheckedUpdateWithoutTv_profileInput>
    create: XOR<tv_profile_quickCreateWithoutTv_profileInput, tv_profile_quickUncheckedCreateWithoutTv_profileInput>
  }

  export type tv_profile_quickUpdateWithWhereUniqueWithoutTv_profileInput = {
    where: tv_profile_quickWhereUniqueInput
    data: XOR<tv_profile_quickUpdateWithoutTv_profileInput, tv_profile_quickUncheckedUpdateWithoutTv_profileInput>
  }

  export type tv_profile_quickUpdateManyWithWhereWithoutTv_profileInput = {
    where: tv_profile_quickScalarWhereInput
    data: XOR<tv_profile_quickUpdateManyMutationInput, tv_profile_quickUncheckedUpdateManyWithoutSnapshotsInput>
  }

  export type tv_profile_quickScalarWhereInput = {
    AND?: Enumerable<tv_profile_quickScalarWhereInput>
    OR?: Enumerable<tv_profile_quickScalarWhereInput>
    NOT?: Enumerable<tv_profile_quickScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    name?: StringFilter | string
    tv_profile_id?: StringFilter | string
  }

  export type seasonCreateWithoutProfileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    collection?: collectionCreateNestedOneWithoutSeasonsInput
    tv: tvCreateNestedOneWithoutSeasonsInput
    user: userCreateNestedOneWithoutSeasonsInput
    parsed_season?: parsed_seasonCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyCreateNestedManyWithoutSeasonInput
    episodes?: episodeCreateNestedManyWithoutSeasonInput
    reports?: reportCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutSeasonInput
  }

  export type seasonUncheckedCreateWithoutProfileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    collection_id?: string | null
    tv_id: string
    user_id: string
    parsed_season?: parsed_seasonUncheckedCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutSeasonInput
    episodes?: episodeUncheckedCreateNestedManyWithoutSeasonInput
    reports?: reportUncheckedCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonCreateOrConnectWithoutProfileInput = {
    where: seasonWhereUniqueInput
    create: XOR<seasonCreateWithoutProfileInput, seasonUncheckedCreateWithoutProfileInput>
  }

  export type seasonUpsertWithWhereUniqueWithoutProfileInput = {
    where: seasonWhereUniqueInput
    update: XOR<seasonUpdateWithoutProfileInput, seasonUncheckedUpdateWithoutProfileInput>
    create: XOR<seasonCreateWithoutProfileInput, seasonUncheckedCreateWithoutProfileInput>
  }

  export type seasonUpdateWithWhereUniqueWithoutProfileInput = {
    where: seasonWhereUniqueInput
    data: XOR<seasonUpdateWithoutProfileInput, seasonUncheckedUpdateWithoutProfileInput>
  }

  export type seasonUpdateManyWithWhereWithoutProfileInput = {
    where: seasonScalarWhereInput
    data: XOR<seasonUpdateManyMutationInput, seasonUncheckedUpdateManyWithoutSeasonsInput>
  }

  export type seasonScalarWhereInput = {
    AND?: Enumerable<seasonScalarWhereInput>
    OR?: Enumerable<seasonScalarWhereInput>
    NOT?: Enumerable<seasonScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    season_text?: StringFilter | string
    season_number?: IntFilter | number
    profile_id?: StringFilter | string
    collection_id?: StringNullableFilter | string | null
    tv_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type episodeCreateWithoutProfileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    tv: tvCreateNestedOneWithoutEpisodesInput
    season: seasonCreateNestedOneWithoutEpisodesInput
    user: userCreateNestedOneWithoutEpisodeInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyCreateNestedManyWithoutEpisodeInput
    reports?: reportCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleCreateNestedManyWithoutEpisodeInput
  }

  export type episodeUncheckedCreateWithoutProfileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    tv_id: string
    season_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutEpisodeInput
    reports?: reportUncheckedCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type episodeCreateOrConnectWithoutProfileInput = {
    where: episodeWhereUniqueInput
    create: XOR<episodeCreateWithoutProfileInput, episodeUncheckedCreateWithoutProfileInput>
  }

  export type episodeUpsertWithWhereUniqueWithoutProfileInput = {
    where: episodeWhereUniqueInput
    update: XOR<episodeUpdateWithoutProfileInput, episodeUncheckedUpdateWithoutProfileInput>
    create: XOR<episodeCreateWithoutProfileInput, episodeUncheckedCreateWithoutProfileInput>
  }

  export type episodeUpdateWithWhereUniqueWithoutProfileInput = {
    where: episodeWhereUniqueInput
    data: XOR<episodeUpdateWithoutProfileInput, episodeUncheckedUpdateWithoutProfileInput>
  }

  export type episodeUpdateManyWithWhereWithoutProfileInput = {
    where: episodeScalarWhereInput
    data: XOR<episodeUpdateManyMutationInput, episodeUncheckedUpdateManyWithoutEpisodesInput>
  }

  export type episodeScalarWhereInput = {
    AND?: Enumerable<episodeScalarWhereInput>
    OR?: Enumerable<episodeScalarWhereInput>
    NOT?: Enumerable<episodeScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    episode_text?: StringFilter | string
    season_text?: StringFilter | string
    episode_number?: IntFilter | number
    profile_id?: StringFilter | string
    tv_id?: StringFilter | string
    season_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type movieCreateWithoutProfileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    user: userCreateNestedOneWithoutMovieInput
    collection?: collectionCreateNestedOneWithoutMoviesInput
    play_histories?: play_historyCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutMovieInput
    reports?: reportCreateNestedManyWithoutMovieInput
    subtitles?: subtitleCreateNestedManyWithoutMovieInput
  }

  export type movieUncheckedCreateWithoutProfileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    user_id: string
    collection_id?: string | null
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutMovieInput
    reports?: reportUncheckedCreateNestedManyWithoutMovieInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutMovieInput
  }

  export type movieCreateOrConnectWithoutProfileInput = {
    where: movieWhereUniqueInput
    create: XOR<movieCreateWithoutProfileInput, movieUncheckedCreateWithoutProfileInput>
  }

  export type movieUpsertWithWhereUniqueWithoutProfileInput = {
    where: movieWhereUniqueInput
    update: XOR<movieUpdateWithoutProfileInput, movieUncheckedUpdateWithoutProfileInput>
    create: XOR<movieCreateWithoutProfileInput, movieUncheckedCreateWithoutProfileInput>
  }

  export type movieUpdateWithWhereUniqueWithoutProfileInput = {
    where: movieWhereUniqueInput
    data: XOR<movieUpdateWithoutProfileInput, movieUncheckedUpdateWithoutProfileInput>
  }

  export type movieUpdateManyWithWhereWithoutProfileInput = {
    where: movieScalarWhereInput
    data: XOR<movieUpdateManyMutationInput, movieUncheckedUpdateManyWithoutMoviesInput>
  }

  export type movieScalarWhereInput = {
    AND?: Enumerable<movieScalarWhereInput>
    OR?: Enumerable<movieScalarWhereInput>
    NOT?: Enumerable<movieScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    profile_id?: StringFilter | string
    user_id?: StringFilter | string
    collection_id?: StringNullableFilter | string | null
  }

  export type movieCreateWithoutSubtitlesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile: movie_profileCreateNestedOneWithoutMoviesInput
    user: userCreateNestedOneWithoutMovieInput
    collection?: collectionCreateNestedOneWithoutMoviesInput
    play_histories?: play_historyCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutMovieInput
    reports?: reportCreateNestedManyWithoutMovieInput
  }

  export type movieUncheckedCreateWithoutSubtitlesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile_id: string
    user_id: string
    collection_id?: string | null
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutMovieInput
    reports?: reportUncheckedCreateNestedManyWithoutMovieInput
  }

  export type movieCreateOrConnectWithoutSubtitlesInput = {
    where: movieWhereUniqueInput
    create: XOR<movieCreateWithoutSubtitlesInput, movieUncheckedCreateWithoutSubtitlesInput>
  }

  export type episodeCreateWithoutSubtitlesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile: episode_profileCreateNestedOneWithoutEpisodesInput
    tv: tvCreateNestedOneWithoutEpisodesInput
    season: seasonCreateNestedOneWithoutEpisodesInput
    user: userCreateNestedOneWithoutEpisodeInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyCreateNestedManyWithoutEpisodeInput
    reports?: reportCreateNestedManyWithoutEpisodeInput
  }

  export type episodeUncheckedCreateWithoutSubtitlesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile_id: string
    tv_id: string
    season_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutEpisodeInput
    reports?: reportUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type episodeCreateOrConnectWithoutSubtitlesInput = {
    where: episodeWhereUniqueInput
    create: XOR<episodeCreateWithoutSubtitlesInput, episodeUncheckedCreateWithoutSubtitlesInput>
  }

  export type driveCreateWithoutSubtitlesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    user: userCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutSubtitlesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    user_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutSubtitlesInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutSubtitlesInput, driveUncheckedCreateWithoutSubtitlesInput>
  }

  export type userCreateWithoutSubtitlesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSubtitlesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSubtitlesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSubtitlesInput, userUncheckedCreateWithoutSubtitlesInput>
  }

  export type movieUpsertWithoutSubtitlesInput = {
    update: XOR<movieUpdateWithoutSubtitlesInput, movieUncheckedUpdateWithoutSubtitlesInput>
    create: XOR<movieCreateWithoutSubtitlesInput, movieUncheckedCreateWithoutSubtitlesInput>
  }

  export type movieUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: movie_profileUpdateOneRequiredWithoutMoviesNestedInput
    user?: userUpdateOneRequiredWithoutMovieNestedInput
    collection?: collectionUpdateOneWithoutMoviesNestedInput
    play_histories?: play_historyUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutMovieNestedInput
    reports?: reportUpdateManyWithoutMovieNestedInput
  }

  export type movieUncheckedUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    play_histories?: play_historyUncheckedUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutMovieNestedInput
    reports?: reportUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type episodeUpsertWithoutSubtitlesInput = {
    update: XOR<episodeUpdateWithoutSubtitlesInput, episodeUncheckedUpdateWithoutSubtitlesInput>
    create: XOR<episodeCreateWithoutSubtitlesInput, episodeUncheckedCreateWithoutSubtitlesInput>
  }

  export type episodeUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile?: episode_profileUpdateOneRequiredWithoutEpisodesNestedInput
    tv?: tvUpdateOneRequiredWithoutEpisodesNestedInput
    season?: seasonUpdateOneRequiredWithoutEpisodesNestedInput
    user?: userUpdateOneRequiredWithoutEpisodeNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUpdateManyWithoutEpisodeNestedInput
    reports?: reportUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUncheckedUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    tv_id?: StringFieldUpdateOperationsInput | string
    season_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutEpisodeNestedInput
    reports?: reportUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type driveUpsertWithoutSubtitlesInput = {
    update: XOR<driveUpdateWithoutSubtitlesInput, driveUncheckedUpdateWithoutSubtitlesInput>
    create: XOR<driveCreateWithoutSubtitlesInput, driveUncheckedCreateWithoutSubtitlesInput>
  }

  export type driveUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type userUpsertWithoutSubtitlesInput = {
    update: XOR<userUpdateWithoutSubtitlesInput, userUncheckedUpdateWithoutSubtitlesInput>
    create: XOR<userCreateWithoutSubtitlesInput, userUncheckedCreateWithoutSubtitlesInput>
  }

  export type userUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type tvCreateWithoutParsed_tvsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile: tv_profileCreateNestedOneWithoutTvsInput
    collection?: collectionCreateNestedOneWithoutTvsInput
    user: userCreateNestedOneWithoutTvInput
    seasons?: seasonCreateNestedManyWithoutTvInput
    episodes?: episodeCreateNestedManyWithoutTvInput
    play_histories?: play_historyCreateNestedManyWithoutTvInput
    reports?: reportCreateNestedManyWithoutTvInput
  }

  export type tvUncheckedCreateWithoutParsed_tvsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile_id: string
    collection_id?: string | null
    user_id: string
    seasons?: seasonUncheckedCreateNestedManyWithoutTvInput
    episodes?: episodeUncheckedCreateNestedManyWithoutTvInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutTvInput
    reports?: reportUncheckedCreateNestedManyWithoutTvInput
  }

  export type tvCreateOrConnectWithoutParsed_tvsInput = {
    where: tvWhereUniqueInput
    create: XOR<tvCreateWithoutParsed_tvsInput, tvUncheckedCreateWithoutParsed_tvsInput>
  }

  export type driveCreateWithoutParsed_tvsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    user: userCreateNestedOneWithoutDrivesInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutParsed_tvsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    user_id: string
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutParsed_tvsInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutParsed_tvsInput, driveUncheckedCreateWithoutParsed_tvsInput>
  }

  export type userCreateWithoutParsed_tvsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutParsed_tvsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutParsed_tvsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutParsed_tvsInput, userUncheckedCreateWithoutParsed_tvsInput>
  }

  export type parsed_episodeCreateWithoutParsed_tvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    episode?: episodeCreateNestedOneWithoutParsed_episodesInput
    parsed_season: parsed_seasonCreateNestedOneWithoutParsed_episodesInput
    drive: driveCreateNestedOneWithoutParsed_episodesInput
    user: userCreateNestedOneWithoutParsed_episodesInput
  }

  export type parsed_episodeUncheckedCreateWithoutParsed_tvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    episode_id?: string | null
    parsed_season_id: string
    drive_id: string
    user_id: string
  }

  export type parsed_episodeCreateOrConnectWithoutParsed_tvInput = {
    where: parsed_episodeWhereUniqueInput
    create: XOR<parsed_episodeCreateWithoutParsed_tvInput, parsed_episodeUncheckedCreateWithoutParsed_tvInput>
  }

  export type parsed_seasonCreateWithoutParsed_tvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    season?: seasonCreateNestedOneWithoutParsed_seasonInput
    drive: driveCreateNestedOneWithoutParsed_seasonsInput
    user: userCreateNestedOneWithoutParsed_seasonsInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutParsed_seasonInput
  }

  export type parsed_seasonUncheckedCreateWithoutParsed_tvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    season_id?: string | null
    drive_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutParsed_seasonInput
  }

  export type parsed_seasonCreateOrConnectWithoutParsed_tvInput = {
    where: parsed_seasonWhereUniqueInput
    create: XOR<parsed_seasonCreateWithoutParsed_tvInput, parsed_seasonUncheckedCreateWithoutParsed_tvInput>
  }

  export type tvUpsertWithoutParsed_tvsInput = {
    update: XOR<tvUpdateWithoutParsed_tvsInput, tvUncheckedUpdateWithoutParsed_tvsInput>
    create: XOR<tvCreateWithoutParsed_tvsInput, tvUncheckedCreateWithoutParsed_tvsInput>
  }

  export type tvUpdateWithoutParsed_tvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: tv_profileUpdateOneRequiredWithoutTvsNestedInput
    collection?: collectionUpdateOneWithoutTvsNestedInput
    user?: userUpdateOneRequiredWithoutTvNestedInput
    seasons?: seasonUpdateManyWithoutTvNestedInput
    episodes?: episodeUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUpdateManyWithoutTvNestedInput
    reports?: reportUpdateManyWithoutTvNestedInput
  }

  export type tvUncheckedUpdateWithoutParsed_tvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    seasons?: seasonUncheckedUpdateManyWithoutTvNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutTvNestedInput
    reports?: reportUncheckedUpdateManyWithoutTvNestedInput
  }

  export type driveUpsertWithoutParsed_tvsInput = {
    update: XOR<driveUpdateWithoutParsed_tvsInput, driveUncheckedUpdateWithoutParsed_tvsInput>
    create: XOR<driveCreateWithoutParsed_tvsInput, driveUncheckedCreateWithoutParsed_tvsInput>
  }

  export type driveUpdateWithoutParsed_tvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutParsed_tvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type userUpsertWithoutParsed_tvsInput = {
    update: XOR<userUpdateWithoutParsed_tvsInput, userUncheckedUpdateWithoutParsed_tvsInput>
    create: XOR<userCreateWithoutParsed_tvsInput, userUncheckedCreateWithoutParsed_tvsInput>
  }

  export type userUpdateWithoutParsed_tvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutParsed_tvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type parsed_episodeUpsertWithWhereUniqueWithoutParsed_tvInput = {
    where: parsed_episodeWhereUniqueInput
    update: XOR<parsed_episodeUpdateWithoutParsed_tvInput, parsed_episodeUncheckedUpdateWithoutParsed_tvInput>
    create: XOR<parsed_episodeCreateWithoutParsed_tvInput, parsed_episodeUncheckedCreateWithoutParsed_tvInput>
  }

  export type parsed_episodeUpdateWithWhereUniqueWithoutParsed_tvInput = {
    where: parsed_episodeWhereUniqueInput
    data: XOR<parsed_episodeUpdateWithoutParsed_tvInput, parsed_episodeUncheckedUpdateWithoutParsed_tvInput>
  }

  export type parsed_episodeUpdateManyWithWhereWithoutParsed_tvInput = {
    where: parsed_episodeScalarWhereInput
    data: XOR<parsed_episodeUpdateManyMutationInput, parsed_episodeUncheckedUpdateManyWithoutParsed_episodesInput>
  }

  export type parsed_seasonUpsertWithWhereUniqueWithoutParsed_tvInput = {
    where: parsed_seasonWhereUniqueInput
    update: XOR<parsed_seasonUpdateWithoutParsed_tvInput, parsed_seasonUncheckedUpdateWithoutParsed_tvInput>
    create: XOR<parsed_seasonCreateWithoutParsed_tvInput, parsed_seasonUncheckedCreateWithoutParsed_tvInput>
  }

  export type parsed_seasonUpdateWithWhereUniqueWithoutParsed_tvInput = {
    where: parsed_seasonWhereUniqueInput
    data: XOR<parsed_seasonUpdateWithoutParsed_tvInput, parsed_seasonUncheckedUpdateWithoutParsed_tvInput>
  }

  export type parsed_seasonUpdateManyWithWhereWithoutParsed_tvInput = {
    where: parsed_seasonScalarWhereInput
    data: XOR<parsed_seasonUpdateManyMutationInput, parsed_seasonUncheckedUpdateManyWithoutParsed_seasonsInput>
  }

  export type seasonCreateWithoutParsed_seasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile: season_profileCreateNestedOneWithoutSeasonsInput
    collection?: collectionCreateNestedOneWithoutSeasonsInput
    tv: tvCreateNestedOneWithoutSeasonsInput
    user: userCreateNestedOneWithoutSeasonsInput
    play_histories?: play_historyCreateNestedManyWithoutSeasonInput
    episodes?: episodeCreateNestedManyWithoutSeasonInput
    reports?: reportCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutSeasonInput
  }

  export type seasonUncheckedCreateWithoutParsed_seasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile_id: string
    collection_id?: string | null
    tv_id: string
    user_id: string
    play_histories?: play_historyUncheckedCreateNestedManyWithoutSeasonInput
    episodes?: episodeUncheckedCreateNestedManyWithoutSeasonInput
    reports?: reportUncheckedCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonCreateOrConnectWithoutParsed_seasonInput = {
    where: seasonWhereUniqueInput
    create: XOR<seasonCreateWithoutParsed_seasonInput, seasonUncheckedCreateWithoutParsed_seasonInput>
  }

  export type parsed_tvCreateWithoutParsed_seasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    tv?: tvCreateNestedOneWithoutParsed_tvsInput
    drive: driveCreateNestedOneWithoutParsed_tvsInput
    user: userCreateNestedOneWithoutParsed_tvsInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvUncheckedCreateWithoutParsed_seasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    tv_id?: string | null
    drive_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvCreateOrConnectWithoutParsed_seasonsInput = {
    where: parsed_tvWhereUniqueInput
    create: XOR<parsed_tvCreateWithoutParsed_seasonsInput, parsed_tvUncheckedCreateWithoutParsed_seasonsInput>
  }

  export type driveCreateWithoutParsed_seasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    user: userCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutParsed_seasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    user_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutParsed_seasonsInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutParsed_seasonsInput, driveUncheckedCreateWithoutParsed_seasonsInput>
  }

  export type userCreateWithoutParsed_seasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutParsed_seasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutParsed_seasonsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutParsed_seasonsInput, userUncheckedCreateWithoutParsed_seasonsInput>
  }

  export type parsed_episodeCreateWithoutParsed_seasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    episode?: episodeCreateNestedOneWithoutParsed_episodesInput
    parsed_tv: parsed_tvCreateNestedOneWithoutParsed_episodesInput
    drive: driveCreateNestedOneWithoutParsed_episodesInput
    user: userCreateNestedOneWithoutParsed_episodesInput
  }

  export type parsed_episodeUncheckedCreateWithoutParsed_seasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    episode_id?: string | null
    parsed_tv_id: string
    drive_id: string
    user_id: string
  }

  export type parsed_episodeCreateOrConnectWithoutParsed_seasonInput = {
    where: parsed_episodeWhereUniqueInput
    create: XOR<parsed_episodeCreateWithoutParsed_seasonInput, parsed_episodeUncheckedCreateWithoutParsed_seasonInput>
  }

  export type seasonUpsertWithoutParsed_seasonInput = {
    update: XOR<seasonUpdateWithoutParsed_seasonInput, seasonUncheckedUpdateWithoutParsed_seasonInput>
    create: XOR<seasonCreateWithoutParsed_seasonInput, seasonUncheckedCreateWithoutParsed_seasonInput>
  }

  export type seasonUpdateWithoutParsed_seasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile?: season_profileUpdateOneRequiredWithoutSeasonsNestedInput
    collection?: collectionUpdateOneWithoutSeasonsNestedInput
    tv?: tvUpdateOneRequiredWithoutSeasonsNestedInput
    user?: userUpdateOneRequiredWithoutSeasonsNestedInput
    play_histories?: play_historyUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUpdateManyWithoutSeasonNestedInput
    reports?: reportUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUncheckedUpdateWithoutParsed_seasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    play_histories?: play_historyUncheckedUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutSeasonNestedInput
    reports?: reportUncheckedUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type parsed_tvUpsertWithoutParsed_seasonsInput = {
    update: XOR<parsed_tvUpdateWithoutParsed_seasonsInput, parsed_tvUncheckedUpdateWithoutParsed_seasonsInput>
    create: XOR<parsed_tvCreateWithoutParsed_seasonsInput, parsed_tvUncheckedCreateWithoutParsed_seasonsInput>
  }

  export type parsed_tvUpdateWithoutParsed_seasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv?: tvUpdateOneWithoutParsed_tvsNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_tvsNestedInput
    user?: userUpdateOneRequiredWithoutParsed_tvsNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutParsed_tvNestedInput
  }

  export type parsed_tvUncheckedUpdateWithoutParsed_seasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutParsed_tvNestedInput
  }

  export type driveUpsertWithoutParsed_seasonsInput = {
    update: XOR<driveUpdateWithoutParsed_seasonsInput, driveUncheckedUpdateWithoutParsed_seasonsInput>
    create: XOR<driveCreateWithoutParsed_seasonsInput, driveUncheckedCreateWithoutParsed_seasonsInput>
  }

  export type driveUpdateWithoutParsed_seasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutParsed_seasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type userUpsertWithoutParsed_seasonsInput = {
    update: XOR<userUpdateWithoutParsed_seasonsInput, userUncheckedUpdateWithoutParsed_seasonsInput>
    create: XOR<userCreateWithoutParsed_seasonsInput, userUncheckedCreateWithoutParsed_seasonsInput>
  }

  export type userUpdateWithoutParsed_seasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutParsed_seasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type parsed_episodeUpsertWithWhereUniqueWithoutParsed_seasonInput = {
    where: parsed_episodeWhereUniqueInput
    update: XOR<parsed_episodeUpdateWithoutParsed_seasonInput, parsed_episodeUncheckedUpdateWithoutParsed_seasonInput>
    create: XOR<parsed_episodeCreateWithoutParsed_seasonInput, parsed_episodeUncheckedCreateWithoutParsed_seasonInput>
  }

  export type parsed_episodeUpdateWithWhereUniqueWithoutParsed_seasonInput = {
    where: parsed_episodeWhereUniqueInput
    data: XOR<parsed_episodeUpdateWithoutParsed_seasonInput, parsed_episodeUncheckedUpdateWithoutParsed_seasonInput>
  }

  export type parsed_episodeUpdateManyWithWhereWithoutParsed_seasonInput = {
    where: parsed_episodeScalarWhereInput
    data: XOR<parsed_episodeUpdateManyMutationInput, parsed_episodeUncheckedUpdateManyWithoutParsed_episodesInput>
  }

  export type episodeCreateWithoutParsed_episodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile: episode_profileCreateNestedOneWithoutEpisodesInput
    tv: tvCreateNestedOneWithoutEpisodesInput
    season: seasonCreateNestedOneWithoutEpisodesInput
    user: userCreateNestedOneWithoutEpisodeInput
    play_histories?: play_historyCreateNestedManyWithoutEpisodeInput
    reports?: reportCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleCreateNestedManyWithoutEpisodeInput
  }

  export type episodeUncheckedCreateWithoutParsed_episodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile_id: string
    tv_id: string
    season_id: string
    user_id: string
    play_histories?: play_historyUncheckedCreateNestedManyWithoutEpisodeInput
    reports?: reportUncheckedCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type episodeCreateOrConnectWithoutParsed_episodesInput = {
    where: episodeWhereUniqueInput
    create: XOR<episodeCreateWithoutParsed_episodesInput, episodeUncheckedCreateWithoutParsed_episodesInput>
  }

  export type parsed_tvCreateWithoutParsed_episodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    tv?: tvCreateNestedOneWithoutParsed_tvsInput
    drive: driveCreateNestedOneWithoutParsed_tvsInput
    user: userCreateNestedOneWithoutParsed_tvsInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvUncheckedCreateWithoutParsed_episodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    tv_id?: string | null
    drive_id: string
    user_id: string
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvCreateOrConnectWithoutParsed_episodesInput = {
    where: parsed_tvWhereUniqueInput
    create: XOR<parsed_tvCreateWithoutParsed_episodesInput, parsed_tvUncheckedCreateWithoutParsed_episodesInput>
  }

  export type parsed_seasonCreateWithoutParsed_episodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    season?: seasonCreateNestedOneWithoutParsed_seasonInput
    parsed_tv: parsed_tvCreateNestedOneWithoutParsed_seasonsInput
    drive: driveCreateNestedOneWithoutParsed_seasonsInput
    user: userCreateNestedOneWithoutParsed_seasonsInput
  }

  export type parsed_seasonUncheckedCreateWithoutParsed_episodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    season_id?: string | null
    parsed_tv_id: string
    drive_id: string
    user_id: string
  }

  export type parsed_seasonCreateOrConnectWithoutParsed_episodesInput = {
    where: parsed_seasonWhereUniqueInput
    create: XOR<parsed_seasonCreateWithoutParsed_episodesInput, parsed_seasonUncheckedCreateWithoutParsed_episodesInput>
  }

  export type driveCreateWithoutParsed_episodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    user: userCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutParsed_episodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    user_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutParsed_episodesInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutParsed_episodesInput, driveUncheckedCreateWithoutParsed_episodesInput>
  }

  export type userCreateWithoutParsed_episodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutParsed_episodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutParsed_episodesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutParsed_episodesInput, userUncheckedCreateWithoutParsed_episodesInput>
  }

  export type episodeUpsertWithoutParsed_episodesInput = {
    update: XOR<episodeUpdateWithoutParsed_episodesInput, episodeUncheckedUpdateWithoutParsed_episodesInput>
    create: XOR<episodeCreateWithoutParsed_episodesInput, episodeUncheckedCreateWithoutParsed_episodesInput>
  }

  export type episodeUpdateWithoutParsed_episodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile?: episode_profileUpdateOneRequiredWithoutEpisodesNestedInput
    tv?: tvUpdateOneRequiredWithoutEpisodesNestedInput
    season?: seasonUpdateOneRequiredWithoutEpisodesNestedInput
    user?: userUpdateOneRequiredWithoutEpisodeNestedInput
    play_histories?: play_historyUpdateManyWithoutEpisodeNestedInput
    reports?: reportUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUncheckedUpdateWithoutParsed_episodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    tv_id?: StringFieldUpdateOperationsInput | string
    season_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    play_histories?: play_historyUncheckedUpdateManyWithoutEpisodeNestedInput
    reports?: reportUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type parsed_tvUpsertWithoutParsed_episodesInput = {
    update: XOR<parsed_tvUpdateWithoutParsed_episodesInput, parsed_tvUncheckedUpdateWithoutParsed_episodesInput>
    create: XOR<parsed_tvCreateWithoutParsed_episodesInput, parsed_tvUncheckedCreateWithoutParsed_episodesInput>
  }

  export type parsed_tvUpdateWithoutParsed_episodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv?: tvUpdateOneWithoutParsed_tvsNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_tvsNestedInput
    user?: userUpdateOneRequiredWithoutParsed_tvsNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutParsed_tvNestedInput
  }

  export type parsed_tvUncheckedUpdateWithoutParsed_episodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutParsed_tvNestedInput
  }

  export type parsed_seasonUpsertWithoutParsed_episodesInput = {
    update: XOR<parsed_seasonUpdateWithoutParsed_episodesInput, parsed_seasonUncheckedUpdateWithoutParsed_episodesInput>
    create: XOR<parsed_seasonCreateWithoutParsed_episodesInput, parsed_seasonUncheckedCreateWithoutParsed_episodesInput>
  }

  export type parsed_seasonUpdateWithoutParsed_episodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season?: seasonUpdateOneWithoutParsed_seasonNestedInput
    parsed_tv?: parsed_tvUpdateOneRequiredWithoutParsed_seasonsNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_seasonsNestedInput
    user?: userUpdateOneRequiredWithoutParsed_seasonsNestedInput
  }

  export type parsed_seasonUncheckedUpdateWithoutParsed_episodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type driveUpsertWithoutParsed_episodesInput = {
    update: XOR<driveUpdateWithoutParsed_episodesInput, driveUncheckedUpdateWithoutParsed_episodesInput>
    create: XOR<driveCreateWithoutParsed_episodesInput, driveUncheckedCreateWithoutParsed_episodesInput>
  }

  export type driveUpdateWithoutParsed_episodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutParsed_episodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type userUpsertWithoutParsed_episodesInput = {
    update: XOR<userUpdateWithoutParsed_episodesInput, userUncheckedUpdateWithoutParsed_episodesInput>
    create: XOR<userCreateWithoutParsed_episodesInput, userUncheckedCreateWithoutParsed_episodesInput>
  }

  export type userUpdateWithoutParsed_episodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutParsed_episodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type movieCreateWithoutParsed_moviesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile: movie_profileCreateNestedOneWithoutMoviesInput
    user: userCreateNestedOneWithoutMovieInput
    collection?: collectionCreateNestedOneWithoutMoviesInput
    play_histories?: play_historyCreateNestedManyWithoutMovieInput
    reports?: reportCreateNestedManyWithoutMovieInput
    subtitles?: subtitleCreateNestedManyWithoutMovieInput
  }

  export type movieUncheckedCreateWithoutParsed_moviesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile_id: string
    user_id: string
    collection_id?: string | null
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMovieInput
    reports?: reportUncheckedCreateNestedManyWithoutMovieInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutMovieInput
  }

  export type movieCreateOrConnectWithoutParsed_moviesInput = {
    where: movieWhereUniqueInput
    create: XOR<movieCreateWithoutParsed_moviesInput, movieUncheckedCreateWithoutParsed_moviesInput>
  }

  export type driveCreateWithoutParsed_moviesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    user: userCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutParsed_moviesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    user_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutParsed_moviesInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutParsed_moviesInput, driveUncheckedCreateWithoutParsed_moviesInput>
  }

  export type userCreateWithoutParsed_moviesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutParsed_moviesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutParsed_moviesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutParsed_moviesInput, userUncheckedCreateWithoutParsed_moviesInput>
  }

  export type movieUpsertWithoutParsed_moviesInput = {
    update: XOR<movieUpdateWithoutParsed_moviesInput, movieUncheckedUpdateWithoutParsed_moviesInput>
    create: XOR<movieCreateWithoutParsed_moviesInput, movieUncheckedCreateWithoutParsed_moviesInput>
  }

  export type movieUpdateWithoutParsed_moviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: movie_profileUpdateOneRequiredWithoutMoviesNestedInput
    user?: userUpdateOneRequiredWithoutMovieNestedInput
    collection?: collectionUpdateOneWithoutMoviesNestedInput
    play_histories?: play_historyUpdateManyWithoutMovieNestedInput
    reports?: reportUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUpdateManyWithoutMovieNestedInput
  }

  export type movieUncheckedUpdateWithoutParsed_moviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    play_histories?: play_historyUncheckedUpdateManyWithoutMovieNestedInput
    reports?: reportUncheckedUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type driveUpsertWithoutParsed_moviesInput = {
    update: XOR<driveUpdateWithoutParsed_moviesInput, driveUncheckedUpdateWithoutParsed_moviesInput>
    create: XOR<driveCreateWithoutParsed_moviesInput, driveUncheckedCreateWithoutParsed_moviesInput>
  }

  export type driveUpdateWithoutParsed_moviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutParsed_moviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type userUpsertWithoutParsed_moviesInput = {
    update: XOR<userUpdateWithoutParsed_moviesInput, userUncheckedUpdateWithoutParsed_moviesInput>
    create: XOR<userCreateWithoutParsed_moviesInput, userUncheckedCreateWithoutParsed_moviesInput>
  }

  export type userUpdateWithoutParsed_moviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutParsed_moviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type tv_profileCreateWithoutTvsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    original_name?: string | null
    overview?: string | null
    poster_path?: string | null
    backdrop_path?: string | null
    first_air_date?: string | null
    original_language?: string | null
    origin_country?: string | null
    genres?: string | null
    popularity?: number | null
    vote_average?: number | null
    vote_count?: number | null
    episode_count?: number | null
    season_count?: number | null
    status?: string | null
    in_production?: number | null
    snapshots?: tv_profile_quickCreateNestedManyWithoutTv_profileInput
  }

  export type tv_profileUncheckedCreateWithoutTvsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    original_name?: string | null
    overview?: string | null
    poster_path?: string | null
    backdrop_path?: string | null
    first_air_date?: string | null
    original_language?: string | null
    origin_country?: string | null
    genres?: string | null
    popularity?: number | null
    vote_average?: number | null
    vote_count?: number | null
    episode_count?: number | null
    season_count?: number | null
    status?: string | null
    in_production?: number | null
    snapshots?: tv_profile_quickUncheckedCreateNestedManyWithoutTv_profileInput
  }

  export type tv_profileCreateOrConnectWithoutTvsInput = {
    where: tv_profileWhereUniqueInput
    create: XOR<tv_profileCreateWithoutTvsInput, tv_profileUncheckedCreateWithoutTvsInput>
  }

  export type collectionCreateWithoutTvsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
    desc?: string | null
    type?: number
    rules?: string | null
    sort?: number
    styles?: string | null
    seasons?: seasonCreateNestedManyWithoutCollectionInput
    movies?: movieCreateNestedManyWithoutCollectionInput
    user: userCreateNestedOneWithoutCollectionsInput
  }

  export type collectionUncheckedCreateWithoutTvsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
    desc?: string | null
    type?: number
    rules?: string | null
    sort?: number
    styles?: string | null
    user_id: string
    seasons?: seasonUncheckedCreateNestedManyWithoutCollectionInput
    movies?: movieUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutTvsInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutTvsInput, collectionUncheckedCreateWithoutTvsInput>
  }

  export type userCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTvInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTvInput, userUncheckedCreateWithoutTvInput>
  }

  export type seasonCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile: season_profileCreateNestedOneWithoutSeasonsInput
    collection?: collectionCreateNestedOneWithoutSeasonsInput
    user: userCreateNestedOneWithoutSeasonsInput
    parsed_season?: parsed_seasonCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyCreateNestedManyWithoutSeasonInput
    episodes?: episodeCreateNestedManyWithoutSeasonInput
    reports?: reportCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutSeasonInput
  }

  export type seasonUncheckedCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile_id: string
    collection_id?: string | null
    user_id: string
    parsed_season?: parsed_seasonUncheckedCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutSeasonInput
    episodes?: episodeUncheckedCreateNestedManyWithoutSeasonInput
    reports?: reportUncheckedCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonCreateOrConnectWithoutTvInput = {
    where: seasonWhereUniqueInput
    create: XOR<seasonCreateWithoutTvInput, seasonUncheckedCreateWithoutTvInput>
  }

  export type episodeCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile: episode_profileCreateNestedOneWithoutEpisodesInput
    season: seasonCreateNestedOneWithoutEpisodesInput
    user: userCreateNestedOneWithoutEpisodeInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyCreateNestedManyWithoutEpisodeInput
    reports?: reportCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleCreateNestedManyWithoutEpisodeInput
  }

  export type episodeUncheckedCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile_id: string
    season_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutEpisodeInput
    reports?: reportUncheckedCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type episodeCreateOrConnectWithoutTvInput = {
    where: episodeWhereUniqueInput
    create: XOR<episodeCreateWithoutTvInput, episodeUncheckedCreateWithoutTvInput>
  }

  export type play_historyCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    season?: seasonCreateNestedOneWithoutPlay_historiesInput
    episode?: episodeCreateNestedOneWithoutPlay_historiesInput
    movie?: movieCreateNestedOneWithoutPlay_historiesInput
    member: memberCreateNestedOneWithoutPlay_historiesInput
  }

  export type play_historyUncheckedCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    season_id?: string | null
    episode_id?: string | null
    movie_id?: string | null
    member_id: string
  }

  export type play_historyCreateOrConnectWithoutTvInput = {
    where: play_historyWhereUniqueInput
    create: XOR<play_historyCreateWithoutTvInput, play_historyUncheckedCreateWithoutTvInput>
  }

  export type parsed_tvCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    drive: driveCreateNestedOneWithoutParsed_tvsInput
    user: userCreateNestedOneWithoutParsed_tvsInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutParsed_tvInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvUncheckedCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    drive_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutParsed_tvInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvCreateOrConnectWithoutTvInput = {
    where: parsed_tvWhereUniqueInput
    create: XOR<parsed_tvCreateWithoutTvInput, parsed_tvUncheckedCreateWithoutTvInput>
  }

  export type reportCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    season?: seasonCreateNestedOneWithoutReportsInput
    episode?: episodeCreateNestedOneWithoutReportsInput
    movie?: movieCreateNestedOneWithoutReportsInput
    member: memberCreateNestedOneWithoutReportsInput
    user: userCreateNestedOneWithoutReportsInput
  }

  export type reportUncheckedCreateWithoutTvInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    season_id?: string | null
    episode_id?: string | null
    movie_id?: string | null
    member_id: string
    user_id: string
  }

  export type reportCreateOrConnectWithoutTvInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutTvInput, reportUncheckedCreateWithoutTvInput>
  }

  export type tv_profileUpsertWithoutTvsInput = {
    update: XOR<tv_profileUpdateWithoutTvsInput, tv_profileUncheckedUpdateWithoutTvsInput>
    create: XOR<tv_profileCreateWithoutTvsInput, tv_profileUncheckedCreateWithoutTvsInput>
  }

  export type tv_profileUpdateWithoutTvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    first_air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    season_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    snapshots?: tv_profile_quickUpdateManyWithoutTv_profileNestedInput
  }

  export type tv_profileUncheckedUpdateWithoutTvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    first_air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    season_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    snapshots?: tv_profile_quickUncheckedUpdateManyWithoutTv_profileNestedInput
  }

  export type collectionUpsertWithoutTvsInput = {
    update: XOR<collectionUpdateWithoutTvsInput, collectionUncheckedUpdateWithoutTvsInput>
    create: XOR<collectionCreateWithoutTvsInput, collectionUncheckedCreateWithoutTvsInput>
  }

  export type collectionUpdateWithoutTvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
    seasons?: seasonUpdateManyWithoutCollectionNestedInput
    movies?: movieUpdateManyWithoutCollectionNestedInput
    user?: userUpdateOneRequiredWithoutCollectionsNestedInput
  }

  export type collectionUncheckedUpdateWithoutTvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    seasons?: seasonUncheckedUpdateManyWithoutCollectionNestedInput
    movies?: movieUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type userUpsertWithoutTvInput = {
    update: XOR<userUpdateWithoutTvInput, userUncheckedUpdateWithoutTvInput>
    create: XOR<userCreateWithoutTvInput, userUncheckedCreateWithoutTvInput>
  }

  export type userUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type seasonUpsertWithWhereUniqueWithoutTvInput = {
    where: seasonWhereUniqueInput
    update: XOR<seasonUpdateWithoutTvInput, seasonUncheckedUpdateWithoutTvInput>
    create: XOR<seasonCreateWithoutTvInput, seasonUncheckedCreateWithoutTvInput>
  }

  export type seasonUpdateWithWhereUniqueWithoutTvInput = {
    where: seasonWhereUniqueInput
    data: XOR<seasonUpdateWithoutTvInput, seasonUncheckedUpdateWithoutTvInput>
  }

  export type seasonUpdateManyWithWhereWithoutTvInput = {
    where: seasonScalarWhereInput
    data: XOR<seasonUpdateManyMutationInput, seasonUncheckedUpdateManyWithoutSeasonsInput>
  }

  export type episodeUpsertWithWhereUniqueWithoutTvInput = {
    where: episodeWhereUniqueInput
    update: XOR<episodeUpdateWithoutTvInput, episodeUncheckedUpdateWithoutTvInput>
    create: XOR<episodeCreateWithoutTvInput, episodeUncheckedCreateWithoutTvInput>
  }

  export type episodeUpdateWithWhereUniqueWithoutTvInput = {
    where: episodeWhereUniqueInput
    data: XOR<episodeUpdateWithoutTvInput, episodeUncheckedUpdateWithoutTvInput>
  }

  export type episodeUpdateManyWithWhereWithoutTvInput = {
    where: episodeScalarWhereInput
    data: XOR<episodeUpdateManyMutationInput, episodeUncheckedUpdateManyWithoutEpisodesInput>
  }

  export type play_historyUpsertWithWhereUniqueWithoutTvInput = {
    where: play_historyWhereUniqueInput
    update: XOR<play_historyUpdateWithoutTvInput, play_historyUncheckedUpdateWithoutTvInput>
    create: XOR<play_historyCreateWithoutTvInput, play_historyUncheckedCreateWithoutTvInput>
  }

  export type play_historyUpdateWithWhereUniqueWithoutTvInput = {
    where: play_historyWhereUniqueInput
    data: XOR<play_historyUpdateWithoutTvInput, play_historyUncheckedUpdateWithoutTvInput>
  }

  export type play_historyUpdateManyWithWhereWithoutTvInput = {
    where: play_historyScalarWhereInput
    data: XOR<play_historyUpdateManyMutationInput, play_historyUncheckedUpdateManyWithoutPlay_historiesInput>
  }

  export type play_historyScalarWhereInput = {
    AND?: Enumerable<play_historyScalarWhereInput>
    OR?: Enumerable<play_historyScalarWhereInput>
    NOT?: Enumerable<play_historyScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    duration?: FloatNullableFilter | number | null
    current_time?: FloatNullableFilter | number | null
    thumbnail?: StringNullableFilter | string | null
    file_id?: StringNullableFilter | string | null
    tv_id?: StringNullableFilter | string | null
    season_id?: StringNullableFilter | string | null
    episode_id?: StringNullableFilter | string | null
    movie_id?: StringNullableFilter | string | null
    member_id?: StringFilter | string
  }

  export type parsed_tvUpsertWithWhereUniqueWithoutTvInput = {
    where: parsed_tvWhereUniqueInput
    update: XOR<parsed_tvUpdateWithoutTvInput, parsed_tvUncheckedUpdateWithoutTvInput>
    create: XOR<parsed_tvCreateWithoutTvInput, parsed_tvUncheckedCreateWithoutTvInput>
  }

  export type parsed_tvUpdateWithWhereUniqueWithoutTvInput = {
    where: parsed_tvWhereUniqueInput
    data: XOR<parsed_tvUpdateWithoutTvInput, parsed_tvUncheckedUpdateWithoutTvInput>
  }

  export type parsed_tvUpdateManyWithWhereWithoutTvInput = {
    where: parsed_tvScalarWhereInput
    data: XOR<parsed_tvUpdateManyMutationInput, parsed_tvUncheckedUpdateManyWithoutParsed_tvsInput>
  }

  export type reportUpsertWithWhereUniqueWithoutTvInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutTvInput, reportUncheckedUpdateWithoutTvInput>
    create: XOR<reportCreateWithoutTvInput, reportUncheckedCreateWithoutTvInput>
  }

  export type reportUpdateWithWhereUniqueWithoutTvInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutTvInput, reportUncheckedUpdateWithoutTvInput>
  }

  export type reportUpdateManyWithWhereWithoutTvInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReportsInput>
  }

  export type reportScalarWhereInput = {
    AND?: Enumerable<reportScalarWhereInput>
    OR?: Enumerable<reportScalarWhereInput>
    NOT?: Enumerable<reportScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    type?: IntFilter | number
    data?: StringFilter | string
    answer?: StringFilter | string
    tv_id?: StringNullableFilter | string | null
    season_id?: StringNullableFilter | string | null
    episode_id?: StringNullableFilter | string | null
    movie_id?: StringNullableFilter | string | null
    member_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type season_profileCreateWithoutSeasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    overview?: string | null
    poster_path?: string | null
    season_number?: number | null
    air_date?: string | null
    episode_count?: number | null
    vote_average?: number | null
  }

  export type season_profileUncheckedCreateWithoutSeasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    overview?: string | null
    poster_path?: string | null
    season_number?: number | null
    air_date?: string | null
    episode_count?: number | null
    vote_average?: number | null
  }

  export type season_profileCreateOrConnectWithoutSeasonsInput = {
    where: season_profileWhereUniqueInput
    create: XOR<season_profileCreateWithoutSeasonsInput, season_profileUncheckedCreateWithoutSeasonsInput>
  }

  export type collectionCreateWithoutSeasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
    desc?: string | null
    type?: number
    rules?: string | null
    sort?: number
    styles?: string | null
    tvs?: tvCreateNestedManyWithoutCollectionInput
    movies?: movieCreateNestedManyWithoutCollectionInput
    user: userCreateNestedOneWithoutCollectionsInput
  }

  export type collectionUncheckedCreateWithoutSeasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
    desc?: string | null
    type?: number
    rules?: string | null
    sort?: number
    styles?: string | null
    user_id: string
    tvs?: tvUncheckedCreateNestedManyWithoutCollectionInput
    movies?: movieUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutSeasonsInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutSeasonsInput, collectionUncheckedCreateWithoutSeasonsInput>
  }

  export type tvCreateWithoutSeasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile: tv_profileCreateNestedOneWithoutTvsInput
    collection?: collectionCreateNestedOneWithoutTvsInput
    user: userCreateNestedOneWithoutTvInput
    episodes?: episodeCreateNestedManyWithoutTvInput
    play_histories?: play_historyCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutTvInput
    reports?: reportCreateNestedManyWithoutTvInput
  }

  export type tvUncheckedCreateWithoutSeasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile_id: string
    collection_id?: string | null
    user_id: string
    episodes?: episodeUncheckedCreateNestedManyWithoutTvInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutTvInput
    reports?: reportUncheckedCreateNestedManyWithoutTvInput
  }

  export type tvCreateOrConnectWithoutSeasonsInput = {
    where: tvWhereUniqueInput
    create: XOR<tvCreateWithoutSeasonsInput, tvUncheckedCreateWithoutSeasonsInput>
  }

  export type userCreateWithoutSeasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSeasonsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSeasonsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSeasonsInput, userUncheckedCreateWithoutSeasonsInput>
  }

  export type parsed_seasonCreateWithoutSeasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    parsed_tv: parsed_tvCreateNestedOneWithoutParsed_seasonsInput
    drive: driveCreateNestedOneWithoutParsed_seasonsInput
    user: userCreateNestedOneWithoutParsed_seasonsInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutParsed_seasonInput
  }

  export type parsed_seasonUncheckedCreateWithoutSeasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    parsed_tv_id: string
    drive_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutParsed_seasonInput
  }

  export type parsed_seasonCreateOrConnectWithoutSeasonInput = {
    where: parsed_seasonWhereUniqueInput
    create: XOR<parsed_seasonCreateWithoutSeasonInput, parsed_seasonUncheckedCreateWithoutSeasonInput>
  }

  export type play_historyCreateWithoutSeasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    tv?: tvCreateNestedOneWithoutPlay_historiesInput
    episode?: episodeCreateNestedOneWithoutPlay_historiesInput
    movie?: movieCreateNestedOneWithoutPlay_historiesInput
    member: memberCreateNestedOneWithoutPlay_historiesInput
  }

  export type play_historyUncheckedCreateWithoutSeasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    tv_id?: string | null
    episode_id?: string | null
    movie_id?: string | null
    member_id: string
  }

  export type play_historyCreateOrConnectWithoutSeasonInput = {
    where: play_historyWhereUniqueInput
    create: XOR<play_historyCreateWithoutSeasonInput, play_historyUncheckedCreateWithoutSeasonInput>
  }

  export type episodeCreateWithoutSeasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile: episode_profileCreateNestedOneWithoutEpisodesInput
    tv: tvCreateNestedOneWithoutEpisodesInput
    user: userCreateNestedOneWithoutEpisodeInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyCreateNestedManyWithoutEpisodeInput
    reports?: reportCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleCreateNestedManyWithoutEpisodeInput
  }

  export type episodeUncheckedCreateWithoutSeasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile_id: string
    tv_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutEpisodeInput
    reports?: reportUncheckedCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type episodeCreateOrConnectWithoutSeasonInput = {
    where: episodeWhereUniqueInput
    create: XOR<episodeCreateWithoutSeasonInput, episodeUncheckedCreateWithoutSeasonInput>
  }

  export type reportCreateWithoutSeasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv?: tvCreateNestedOneWithoutReportsInput
    episode?: episodeCreateNestedOneWithoutReportsInput
    movie?: movieCreateNestedOneWithoutReportsInput
    member: memberCreateNestedOneWithoutReportsInput
    user: userCreateNestedOneWithoutReportsInput
  }

  export type reportUncheckedCreateWithoutSeasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv_id?: string | null
    episode_id?: string | null
    movie_id?: string | null
    member_id: string
    user_id: string
  }

  export type reportCreateOrConnectWithoutSeasonInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutSeasonInput, reportUncheckedCreateWithoutSeasonInput>
  }

  export type bind_for_parsed_tvCreateWithoutSeasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    file_id_link_resource: string
    file_name_link_resource: string
    in_production?: number | null
    invalid?: number | null
    drive: driveCreateNestedOneWithoutSync_tasksInput
    user: userCreateNestedOneWithoutSync_tasksInput
  }

  export type bind_for_parsed_tvUncheckedCreateWithoutSeasonInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    file_id_link_resource: string
    file_name_link_resource: string
    in_production?: number | null
    invalid?: number | null
    drive_id: string
    user_id: string
  }

  export type bind_for_parsed_tvCreateOrConnectWithoutSeasonInput = {
    where: bind_for_parsed_tvWhereUniqueInput
    create: XOR<bind_for_parsed_tvCreateWithoutSeasonInput, bind_for_parsed_tvUncheckedCreateWithoutSeasonInput>
  }

  export type season_profileUpsertWithoutSeasonsInput = {
    update: XOR<season_profileUpdateWithoutSeasonsInput, season_profileUncheckedUpdateWithoutSeasonsInput>
    create: XOR<season_profileCreateWithoutSeasonsInput, season_profileUncheckedCreateWithoutSeasonsInput>
  }

  export type season_profileUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type season_profileUncheckedUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type collectionUpsertWithoutSeasonsInput = {
    update: XOR<collectionUpdateWithoutSeasonsInput, collectionUncheckedUpdateWithoutSeasonsInput>
    create: XOR<collectionCreateWithoutSeasonsInput, collectionUncheckedCreateWithoutSeasonsInput>
  }

  export type collectionUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
    tvs?: tvUpdateManyWithoutCollectionNestedInput
    movies?: movieUpdateManyWithoutCollectionNestedInput
    user?: userUpdateOneRequiredWithoutCollectionsNestedInput
  }

  export type collectionUncheckedUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    tvs?: tvUncheckedUpdateManyWithoutCollectionNestedInput
    movies?: movieUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type tvUpsertWithoutSeasonsInput = {
    update: XOR<tvUpdateWithoutSeasonsInput, tvUncheckedUpdateWithoutSeasonsInput>
    create: XOR<tvCreateWithoutSeasonsInput, tvUncheckedCreateWithoutSeasonsInput>
  }

  export type tvUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: tv_profileUpdateOneRequiredWithoutTvsNestedInput
    collection?: collectionUpdateOneWithoutTvsNestedInput
    user?: userUpdateOneRequiredWithoutTvNestedInput
    episodes?: episodeUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutTvNestedInput
    reports?: reportUpdateManyWithoutTvNestedInput
  }

  export type tvUncheckedUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    episodes?: episodeUncheckedUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutTvNestedInput
    reports?: reportUncheckedUpdateManyWithoutTvNestedInput
  }

  export type userUpsertWithoutSeasonsInput = {
    update: XOR<userUpdateWithoutSeasonsInput, userUncheckedUpdateWithoutSeasonsInput>
    create: XOR<userCreateWithoutSeasonsInput, userUncheckedCreateWithoutSeasonsInput>
  }

  export type userUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type parsed_seasonUpsertWithWhereUniqueWithoutSeasonInput = {
    where: parsed_seasonWhereUniqueInput
    update: XOR<parsed_seasonUpdateWithoutSeasonInput, parsed_seasonUncheckedUpdateWithoutSeasonInput>
    create: XOR<parsed_seasonCreateWithoutSeasonInput, parsed_seasonUncheckedCreateWithoutSeasonInput>
  }

  export type parsed_seasonUpdateWithWhereUniqueWithoutSeasonInput = {
    where: parsed_seasonWhereUniqueInput
    data: XOR<parsed_seasonUpdateWithoutSeasonInput, parsed_seasonUncheckedUpdateWithoutSeasonInput>
  }

  export type parsed_seasonUpdateManyWithWhereWithoutSeasonInput = {
    where: parsed_seasonScalarWhereInput
    data: XOR<parsed_seasonUpdateManyMutationInput, parsed_seasonUncheckedUpdateManyWithoutParsed_seasonInput>
  }

  export type play_historyUpsertWithWhereUniqueWithoutSeasonInput = {
    where: play_historyWhereUniqueInput
    update: XOR<play_historyUpdateWithoutSeasonInput, play_historyUncheckedUpdateWithoutSeasonInput>
    create: XOR<play_historyCreateWithoutSeasonInput, play_historyUncheckedCreateWithoutSeasonInput>
  }

  export type play_historyUpdateWithWhereUniqueWithoutSeasonInput = {
    where: play_historyWhereUniqueInput
    data: XOR<play_historyUpdateWithoutSeasonInput, play_historyUncheckedUpdateWithoutSeasonInput>
  }

  export type play_historyUpdateManyWithWhereWithoutSeasonInput = {
    where: play_historyScalarWhereInput
    data: XOR<play_historyUpdateManyMutationInput, play_historyUncheckedUpdateManyWithoutPlay_historiesInput>
  }

  export type episodeUpsertWithWhereUniqueWithoutSeasonInput = {
    where: episodeWhereUniqueInput
    update: XOR<episodeUpdateWithoutSeasonInput, episodeUncheckedUpdateWithoutSeasonInput>
    create: XOR<episodeCreateWithoutSeasonInput, episodeUncheckedCreateWithoutSeasonInput>
  }

  export type episodeUpdateWithWhereUniqueWithoutSeasonInput = {
    where: episodeWhereUniqueInput
    data: XOR<episodeUpdateWithoutSeasonInput, episodeUncheckedUpdateWithoutSeasonInput>
  }

  export type episodeUpdateManyWithWhereWithoutSeasonInput = {
    where: episodeScalarWhereInput
    data: XOR<episodeUpdateManyMutationInput, episodeUncheckedUpdateManyWithoutEpisodesInput>
  }

  export type reportUpsertWithWhereUniqueWithoutSeasonInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutSeasonInput, reportUncheckedUpdateWithoutSeasonInput>
    create: XOR<reportCreateWithoutSeasonInput, reportUncheckedCreateWithoutSeasonInput>
  }

  export type reportUpdateWithWhereUniqueWithoutSeasonInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutSeasonInput, reportUncheckedUpdateWithoutSeasonInput>
  }

  export type reportUpdateManyWithWhereWithoutSeasonInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReportsInput>
  }

  export type bind_for_parsed_tvUpsertWithWhereUniqueWithoutSeasonInput = {
    where: bind_for_parsed_tvWhereUniqueInput
    update: XOR<bind_for_parsed_tvUpdateWithoutSeasonInput, bind_for_parsed_tvUncheckedUpdateWithoutSeasonInput>
    create: XOR<bind_for_parsed_tvCreateWithoutSeasonInput, bind_for_parsed_tvUncheckedCreateWithoutSeasonInput>
  }

  export type bind_for_parsed_tvUpdateWithWhereUniqueWithoutSeasonInput = {
    where: bind_for_parsed_tvWhereUniqueInput
    data: XOR<bind_for_parsed_tvUpdateWithoutSeasonInput, bind_for_parsed_tvUncheckedUpdateWithoutSeasonInput>
  }

  export type bind_for_parsed_tvUpdateManyWithWhereWithoutSeasonInput = {
    where: bind_for_parsed_tvScalarWhereInput
    data: XOR<bind_for_parsed_tvUpdateManyMutationInput, bind_for_parsed_tvUncheckedUpdateManyWithoutSync_tasksInput>
  }

  export type episode_profileCreateWithoutEpisodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    overview?: string | null
    air_date?: string | null
    runtime?: number | null
    episode_number?: number | null
    season_number?: number | null
  }

  export type episode_profileUncheckedCreateWithoutEpisodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    overview?: string | null
    air_date?: string | null
    runtime?: number | null
    episode_number?: number | null
    season_number?: number | null
  }

  export type episode_profileCreateOrConnectWithoutEpisodesInput = {
    where: episode_profileWhereUniqueInput
    create: XOR<episode_profileCreateWithoutEpisodesInput, episode_profileUncheckedCreateWithoutEpisodesInput>
  }

  export type tvCreateWithoutEpisodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile: tv_profileCreateNestedOneWithoutTvsInput
    collection?: collectionCreateNestedOneWithoutTvsInput
    user: userCreateNestedOneWithoutTvInput
    seasons?: seasonCreateNestedManyWithoutTvInput
    play_histories?: play_historyCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutTvInput
    reports?: reportCreateNestedManyWithoutTvInput
  }

  export type tvUncheckedCreateWithoutEpisodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile_id: string
    collection_id?: string | null
    user_id: string
    seasons?: seasonUncheckedCreateNestedManyWithoutTvInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutTvInput
    reports?: reportUncheckedCreateNestedManyWithoutTvInput
  }

  export type tvCreateOrConnectWithoutEpisodesInput = {
    where: tvWhereUniqueInput
    create: XOR<tvCreateWithoutEpisodesInput, tvUncheckedCreateWithoutEpisodesInput>
  }

  export type seasonCreateWithoutEpisodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile: season_profileCreateNestedOneWithoutSeasonsInput
    collection?: collectionCreateNestedOneWithoutSeasonsInput
    tv: tvCreateNestedOneWithoutSeasonsInput
    user: userCreateNestedOneWithoutSeasonsInput
    parsed_season?: parsed_seasonCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyCreateNestedManyWithoutSeasonInput
    reports?: reportCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutSeasonInput
  }

  export type seasonUncheckedCreateWithoutEpisodesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile_id: string
    collection_id?: string | null
    tv_id: string
    user_id: string
    parsed_season?: parsed_seasonUncheckedCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutSeasonInput
    reports?: reportUncheckedCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonCreateOrConnectWithoutEpisodesInput = {
    where: seasonWhereUniqueInput
    create: XOR<seasonCreateWithoutEpisodesInput, seasonUncheckedCreateWithoutEpisodesInput>
  }

  export type userCreateWithoutEpisodeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutEpisodeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutEpisodeInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutEpisodeInput, userUncheckedCreateWithoutEpisodeInput>
  }

  export type parsed_episodeCreateWithoutEpisodeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    parsed_tv: parsed_tvCreateNestedOneWithoutParsed_episodesInput
    parsed_season: parsed_seasonCreateNestedOneWithoutParsed_episodesInput
    drive: driveCreateNestedOneWithoutParsed_episodesInput
    user: userCreateNestedOneWithoutParsed_episodesInput
  }

  export type parsed_episodeUncheckedCreateWithoutEpisodeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    parsed_tv_id: string
    parsed_season_id: string
    drive_id: string
    user_id: string
  }

  export type parsed_episodeCreateOrConnectWithoutEpisodeInput = {
    where: parsed_episodeWhereUniqueInput
    create: XOR<parsed_episodeCreateWithoutEpisodeInput, parsed_episodeUncheckedCreateWithoutEpisodeInput>
  }

  export type play_historyCreateWithoutEpisodeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    tv?: tvCreateNestedOneWithoutPlay_historiesInput
    season?: seasonCreateNestedOneWithoutPlay_historiesInput
    movie?: movieCreateNestedOneWithoutPlay_historiesInput
    member: memberCreateNestedOneWithoutPlay_historiesInput
  }

  export type play_historyUncheckedCreateWithoutEpisodeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    tv_id?: string | null
    season_id?: string | null
    movie_id?: string | null
    member_id: string
  }

  export type play_historyCreateOrConnectWithoutEpisodeInput = {
    where: play_historyWhereUniqueInput
    create: XOR<play_historyCreateWithoutEpisodeInput, play_historyUncheckedCreateWithoutEpisodeInput>
  }

  export type reportCreateWithoutEpisodeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv?: tvCreateNestedOneWithoutReportsInput
    season?: seasonCreateNestedOneWithoutReportsInput
    movie?: movieCreateNestedOneWithoutReportsInput
    member: memberCreateNestedOneWithoutReportsInput
    user: userCreateNestedOneWithoutReportsInput
  }

  export type reportUncheckedCreateWithoutEpisodeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv_id?: string | null
    season_id?: string | null
    movie_id?: string | null
    member_id: string
    user_id: string
  }

  export type reportCreateOrConnectWithoutEpisodeInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutEpisodeInput, reportUncheckedCreateWithoutEpisodeInput>
  }

  export type subtitleCreateWithoutEpisodeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    language: string
    movie?: movieCreateNestedOneWithoutSubtitlesInput
    drive: driveCreateNestedOneWithoutSubtitlesInput
    user: userCreateNestedOneWithoutSubtitlesInput
  }

  export type subtitleUncheckedCreateWithoutEpisodeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    language: string
    movie_id?: string | null
    drive_id: string
    user_id: string
  }

  export type subtitleCreateOrConnectWithoutEpisodeInput = {
    where: subtitleWhereUniqueInput
    create: XOR<subtitleCreateWithoutEpisodeInput, subtitleUncheckedCreateWithoutEpisodeInput>
  }

  export type episode_profileUpsertWithoutEpisodesInput = {
    update: XOR<episode_profileUpdateWithoutEpisodesInput, episode_profileUncheckedUpdateWithoutEpisodesInput>
    create: XOR<episode_profileCreateWithoutEpisodesInput, episode_profileUncheckedCreateWithoutEpisodesInput>
  }

  export type episode_profileUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    episode_number?: NullableIntFieldUpdateOperationsInput | number | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type episode_profileUncheckedUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
    episode_number?: NullableIntFieldUpdateOperationsInput | number | null
    season_number?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type tvUpsertWithoutEpisodesInput = {
    update: XOR<tvUpdateWithoutEpisodesInput, tvUncheckedUpdateWithoutEpisodesInput>
    create: XOR<tvCreateWithoutEpisodesInput, tvUncheckedCreateWithoutEpisodesInput>
  }

  export type tvUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: tv_profileUpdateOneRequiredWithoutTvsNestedInput
    collection?: collectionUpdateOneWithoutTvsNestedInput
    user?: userUpdateOneRequiredWithoutTvNestedInput
    seasons?: seasonUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutTvNestedInput
    reports?: reportUpdateManyWithoutTvNestedInput
  }

  export type tvUncheckedUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    seasons?: seasonUncheckedUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutTvNestedInput
    reports?: reportUncheckedUpdateManyWithoutTvNestedInput
  }

  export type seasonUpsertWithoutEpisodesInput = {
    update: XOR<seasonUpdateWithoutEpisodesInput, seasonUncheckedUpdateWithoutEpisodesInput>
    create: XOR<seasonCreateWithoutEpisodesInput, seasonUncheckedCreateWithoutEpisodesInput>
  }

  export type seasonUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile?: season_profileUpdateOneRequiredWithoutSeasonsNestedInput
    collection?: collectionUpdateOneWithoutSeasonsNestedInput
    tv?: tvUpdateOneRequiredWithoutSeasonsNestedInput
    user?: userUpdateOneRequiredWithoutSeasonsNestedInput
    parsed_season?: parsed_seasonUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUpdateManyWithoutSeasonNestedInput
    reports?: reportUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUncheckedUpdateWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_season?: parsed_seasonUncheckedUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutSeasonNestedInput
    reports?: reportUncheckedUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type userUpsertWithoutEpisodeInput = {
    update: XOR<userUpdateWithoutEpisodeInput, userUncheckedUpdateWithoutEpisodeInput>
    create: XOR<userCreateWithoutEpisodeInput, userUncheckedCreateWithoutEpisodeInput>
  }

  export type userUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type parsed_episodeUpsertWithWhereUniqueWithoutEpisodeInput = {
    where: parsed_episodeWhereUniqueInput
    update: XOR<parsed_episodeUpdateWithoutEpisodeInput, parsed_episodeUncheckedUpdateWithoutEpisodeInput>
    create: XOR<parsed_episodeCreateWithoutEpisodeInput, parsed_episodeUncheckedCreateWithoutEpisodeInput>
  }

  export type parsed_episodeUpdateWithWhereUniqueWithoutEpisodeInput = {
    where: parsed_episodeWhereUniqueInput
    data: XOR<parsed_episodeUpdateWithoutEpisodeInput, parsed_episodeUncheckedUpdateWithoutEpisodeInput>
  }

  export type parsed_episodeUpdateManyWithWhereWithoutEpisodeInput = {
    where: parsed_episodeScalarWhereInput
    data: XOR<parsed_episodeUpdateManyMutationInput, parsed_episodeUncheckedUpdateManyWithoutParsed_episodesInput>
  }

  export type play_historyUpsertWithWhereUniqueWithoutEpisodeInput = {
    where: play_historyWhereUniqueInput
    update: XOR<play_historyUpdateWithoutEpisodeInput, play_historyUncheckedUpdateWithoutEpisodeInput>
    create: XOR<play_historyCreateWithoutEpisodeInput, play_historyUncheckedCreateWithoutEpisodeInput>
  }

  export type play_historyUpdateWithWhereUniqueWithoutEpisodeInput = {
    where: play_historyWhereUniqueInput
    data: XOR<play_historyUpdateWithoutEpisodeInput, play_historyUncheckedUpdateWithoutEpisodeInput>
  }

  export type play_historyUpdateManyWithWhereWithoutEpisodeInput = {
    where: play_historyScalarWhereInput
    data: XOR<play_historyUpdateManyMutationInput, play_historyUncheckedUpdateManyWithoutPlay_historiesInput>
  }

  export type reportUpsertWithWhereUniqueWithoutEpisodeInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutEpisodeInput, reportUncheckedUpdateWithoutEpisodeInput>
    create: XOR<reportCreateWithoutEpisodeInput, reportUncheckedCreateWithoutEpisodeInput>
  }

  export type reportUpdateWithWhereUniqueWithoutEpisodeInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutEpisodeInput, reportUncheckedUpdateWithoutEpisodeInput>
  }

  export type reportUpdateManyWithWhereWithoutEpisodeInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReportsInput>
  }

  export type subtitleUpsertWithWhereUniqueWithoutEpisodeInput = {
    where: subtitleWhereUniqueInput
    update: XOR<subtitleUpdateWithoutEpisodeInput, subtitleUncheckedUpdateWithoutEpisodeInput>
    create: XOR<subtitleCreateWithoutEpisodeInput, subtitleUncheckedCreateWithoutEpisodeInput>
  }

  export type subtitleUpdateWithWhereUniqueWithoutEpisodeInput = {
    where: subtitleWhereUniqueInput
    data: XOR<subtitleUpdateWithoutEpisodeInput, subtitleUncheckedUpdateWithoutEpisodeInput>
  }

  export type subtitleUpdateManyWithWhereWithoutEpisodeInput = {
    where: subtitleScalarWhereInput
    data: XOR<subtitleUpdateManyMutationInput, subtitleUncheckedUpdateManyWithoutSubtitlesInput>
  }

  export type movie_profileCreateWithoutMoviesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    original_name?: string | null
    overview?: string | null
    poster_path?: string | null
    backdrop_path?: string | null
    air_date?: string | null
    original_language?: string | null
    popularity?: number | null
    vote_average?: number | null
    vote_count?: number | null
    origin_country?: string | null
    genres?: string | null
    runtime?: number | null
  }

  export type movie_profileUncheckedCreateWithoutMoviesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    original_name?: string | null
    overview?: string | null
    poster_path?: string | null
    backdrop_path?: string | null
    air_date?: string | null
    original_language?: string | null
    popularity?: number | null
    vote_average?: number | null
    vote_count?: number | null
    origin_country?: string | null
    genres?: string | null
    runtime?: number | null
  }

  export type movie_profileCreateOrConnectWithoutMoviesInput = {
    where: movie_profileWhereUniqueInput
    create: XOR<movie_profileCreateWithoutMoviesInput, movie_profileUncheckedCreateWithoutMoviesInput>
  }

  export type userCreateWithoutMovieInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutMovieInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMovieInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMovieInput, userUncheckedCreateWithoutMovieInput>
  }

  export type collectionCreateWithoutMoviesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
    desc?: string | null
    type?: number
    rules?: string | null
    sort?: number
    styles?: string | null
    tvs?: tvCreateNestedManyWithoutCollectionInput
    seasons?: seasonCreateNestedManyWithoutCollectionInput
    user: userCreateNestedOneWithoutCollectionsInput
  }

  export type collectionUncheckedCreateWithoutMoviesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
    desc?: string | null
    type?: number
    rules?: string | null
    sort?: number
    styles?: string | null
    user_id: string
    tvs?: tvUncheckedCreateNestedManyWithoutCollectionInput
    seasons?: seasonUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutMoviesInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutMoviesInput, collectionUncheckedCreateWithoutMoviesInput>
  }

  export type play_historyCreateWithoutMovieInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    tv?: tvCreateNestedOneWithoutPlay_historiesInput
    season?: seasonCreateNestedOneWithoutPlay_historiesInput
    episode?: episodeCreateNestedOneWithoutPlay_historiesInput
    member: memberCreateNestedOneWithoutPlay_historiesInput
  }

  export type play_historyUncheckedCreateWithoutMovieInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    tv_id?: string | null
    season_id?: string | null
    episode_id?: string | null
    member_id: string
  }

  export type play_historyCreateOrConnectWithoutMovieInput = {
    where: play_historyWhereUniqueInput
    create: XOR<play_historyCreateWithoutMovieInput, play_historyUncheckedCreateWithoutMovieInput>
  }

  export type parsed_movieCreateWithoutMovieInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    original_name?: string | null
    correct_name?: string | null
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    drive: driveCreateNestedOneWithoutParsed_moviesInput
    user: userCreateNestedOneWithoutParsed_moviesInput
  }

  export type parsed_movieUncheckedCreateWithoutMovieInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    original_name?: string | null
    correct_name?: string | null
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    drive_id: string
    user_id: string
  }

  export type parsed_movieCreateOrConnectWithoutMovieInput = {
    where: parsed_movieWhereUniqueInput
    create: XOR<parsed_movieCreateWithoutMovieInput, parsed_movieUncheckedCreateWithoutMovieInput>
  }

  export type reportCreateWithoutMovieInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv?: tvCreateNestedOneWithoutReportsInput
    season?: seasonCreateNestedOneWithoutReportsInput
    episode?: episodeCreateNestedOneWithoutReportsInput
    member: memberCreateNestedOneWithoutReportsInput
    user: userCreateNestedOneWithoutReportsInput
  }

  export type reportUncheckedCreateWithoutMovieInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv_id?: string | null
    season_id?: string | null
    episode_id?: string | null
    member_id: string
    user_id: string
  }

  export type reportCreateOrConnectWithoutMovieInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutMovieInput, reportUncheckedCreateWithoutMovieInput>
  }

  export type subtitleCreateWithoutMovieInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    language: string
    episode?: episodeCreateNestedOneWithoutSubtitlesInput
    drive: driveCreateNestedOneWithoutSubtitlesInput
    user: userCreateNestedOneWithoutSubtitlesInput
  }

  export type subtitleUncheckedCreateWithoutMovieInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    language: string
    episode_id?: string | null
    drive_id: string
    user_id: string
  }

  export type subtitleCreateOrConnectWithoutMovieInput = {
    where: subtitleWhereUniqueInput
    create: XOR<subtitleCreateWithoutMovieInput, subtitleUncheckedCreateWithoutMovieInput>
  }

  export type movie_profileUpsertWithoutMoviesInput = {
    update: XOR<movie_profileUpdateWithoutMoviesInput, movie_profileUncheckedUpdateWithoutMoviesInput>
    create: XOR<movie_profileCreateWithoutMoviesInput, movie_profileUncheckedCreateWithoutMoviesInput>
  }

  export type movie_profileUpdateWithoutMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type movie_profileUncheckedUpdateWithoutMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    runtime?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type userUpsertWithoutMovieInput = {
    update: XOR<userUpdateWithoutMovieInput, userUncheckedUpdateWithoutMovieInput>
    create: XOR<userCreateWithoutMovieInput, userUncheckedCreateWithoutMovieInput>
  }

  export type userUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type collectionUpsertWithoutMoviesInput = {
    update: XOR<collectionUpdateWithoutMoviesInput, collectionUncheckedUpdateWithoutMoviesInput>
    create: XOR<collectionCreateWithoutMoviesInput, collectionUncheckedCreateWithoutMoviesInput>
  }

  export type collectionUpdateWithoutMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
    tvs?: tvUpdateManyWithoutCollectionNestedInput
    seasons?: seasonUpdateManyWithoutCollectionNestedInput
    user?: userUpdateOneRequiredWithoutCollectionsNestedInput
  }

  export type collectionUncheckedUpdateWithoutMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    tvs?: tvUncheckedUpdateManyWithoutCollectionNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type play_historyUpsertWithWhereUniqueWithoutMovieInput = {
    where: play_historyWhereUniqueInput
    update: XOR<play_historyUpdateWithoutMovieInput, play_historyUncheckedUpdateWithoutMovieInput>
    create: XOR<play_historyCreateWithoutMovieInput, play_historyUncheckedCreateWithoutMovieInput>
  }

  export type play_historyUpdateWithWhereUniqueWithoutMovieInput = {
    where: play_historyWhereUniqueInput
    data: XOR<play_historyUpdateWithoutMovieInput, play_historyUncheckedUpdateWithoutMovieInput>
  }

  export type play_historyUpdateManyWithWhereWithoutMovieInput = {
    where: play_historyScalarWhereInput
    data: XOR<play_historyUpdateManyMutationInput, play_historyUncheckedUpdateManyWithoutPlay_historiesInput>
  }

  export type parsed_movieUpsertWithWhereUniqueWithoutMovieInput = {
    where: parsed_movieWhereUniqueInput
    update: XOR<parsed_movieUpdateWithoutMovieInput, parsed_movieUncheckedUpdateWithoutMovieInput>
    create: XOR<parsed_movieCreateWithoutMovieInput, parsed_movieUncheckedCreateWithoutMovieInput>
  }

  export type parsed_movieUpdateWithWhereUniqueWithoutMovieInput = {
    where: parsed_movieWhereUniqueInput
    data: XOR<parsed_movieUpdateWithoutMovieInput, parsed_movieUncheckedUpdateWithoutMovieInput>
  }

  export type parsed_movieUpdateManyWithWhereWithoutMovieInput = {
    where: parsed_movieScalarWhereInput
    data: XOR<parsed_movieUpdateManyMutationInput, parsed_movieUncheckedUpdateManyWithoutParsed_moviesInput>
  }

  export type reportUpsertWithWhereUniqueWithoutMovieInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutMovieInput, reportUncheckedUpdateWithoutMovieInput>
    create: XOR<reportCreateWithoutMovieInput, reportUncheckedCreateWithoutMovieInput>
  }

  export type reportUpdateWithWhereUniqueWithoutMovieInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutMovieInput, reportUncheckedUpdateWithoutMovieInput>
  }

  export type reportUpdateManyWithWhereWithoutMovieInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReportsInput>
  }

  export type subtitleUpsertWithWhereUniqueWithoutMovieInput = {
    where: subtitleWhereUniqueInput
    update: XOR<subtitleUpdateWithoutMovieInput, subtitleUncheckedUpdateWithoutMovieInput>
    create: XOR<subtitleCreateWithoutMovieInput, subtitleUncheckedCreateWithoutMovieInput>
  }

  export type subtitleUpdateWithWhereUniqueWithoutMovieInput = {
    where: subtitleWhereUniqueInput
    data: XOR<subtitleUpdateWithoutMovieInput, subtitleUncheckedUpdateWithoutMovieInput>
  }

  export type subtitleUpdateManyWithWhereWithoutMovieInput = {
    where: subtitleScalarWhereInput
    data: XOR<subtitleUpdateManyMutationInput, subtitleUncheckedUpdateManyWithoutSubtitlesInput>
  }

  export type tvCreateWithoutCollectionInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile: tv_profileCreateNestedOneWithoutTvsInput
    user: userCreateNestedOneWithoutTvInput
    seasons?: seasonCreateNestedManyWithoutTvInput
    episodes?: episodeCreateNestedManyWithoutTvInput
    play_histories?: play_historyCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutTvInput
    reports?: reportCreateNestedManyWithoutTvInput
  }

  export type tvUncheckedCreateWithoutCollectionInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile_id: string
    user_id: string
    seasons?: seasonUncheckedCreateNestedManyWithoutTvInput
    episodes?: episodeUncheckedCreateNestedManyWithoutTvInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutTvInput
    reports?: reportUncheckedCreateNestedManyWithoutTvInput
  }

  export type tvCreateOrConnectWithoutCollectionInput = {
    where: tvWhereUniqueInput
    create: XOR<tvCreateWithoutCollectionInput, tvUncheckedCreateWithoutCollectionInput>
  }

  export type seasonCreateWithoutCollectionInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile: season_profileCreateNestedOneWithoutSeasonsInput
    tv: tvCreateNestedOneWithoutSeasonsInput
    user: userCreateNestedOneWithoutSeasonsInput
    parsed_season?: parsed_seasonCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyCreateNestedManyWithoutSeasonInput
    episodes?: episodeCreateNestedManyWithoutSeasonInput
    reports?: reportCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutSeasonInput
  }

  export type seasonUncheckedCreateWithoutCollectionInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile_id: string
    tv_id: string
    user_id: string
    parsed_season?: parsed_seasonUncheckedCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutSeasonInput
    episodes?: episodeUncheckedCreateNestedManyWithoutSeasonInput
    reports?: reportUncheckedCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonCreateOrConnectWithoutCollectionInput = {
    where: seasonWhereUniqueInput
    create: XOR<seasonCreateWithoutCollectionInput, seasonUncheckedCreateWithoutCollectionInput>
  }

  export type movieCreateWithoutCollectionInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile: movie_profileCreateNestedOneWithoutMoviesInput
    user: userCreateNestedOneWithoutMovieInput
    play_histories?: play_historyCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutMovieInput
    reports?: reportCreateNestedManyWithoutMovieInput
    subtitles?: subtitleCreateNestedManyWithoutMovieInput
  }

  export type movieUncheckedCreateWithoutCollectionInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile_id: string
    user_id: string
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutMovieInput
    reports?: reportUncheckedCreateNestedManyWithoutMovieInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutMovieInput
  }

  export type movieCreateOrConnectWithoutCollectionInput = {
    where: movieWhereUniqueInput
    create: XOR<movieCreateWithoutCollectionInput, movieUncheckedCreateWithoutCollectionInput>
  }

  export type userCreateWithoutCollectionsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCollectionsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCollectionsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCollectionsInput, userUncheckedCreateWithoutCollectionsInput>
  }

  export type tvUpsertWithWhereUniqueWithoutCollectionInput = {
    where: tvWhereUniqueInput
    update: XOR<tvUpdateWithoutCollectionInput, tvUncheckedUpdateWithoutCollectionInput>
    create: XOR<tvCreateWithoutCollectionInput, tvUncheckedCreateWithoutCollectionInput>
  }

  export type tvUpdateWithWhereUniqueWithoutCollectionInput = {
    where: tvWhereUniqueInput
    data: XOR<tvUpdateWithoutCollectionInput, tvUncheckedUpdateWithoutCollectionInput>
  }

  export type tvUpdateManyWithWhereWithoutCollectionInput = {
    where: tvScalarWhereInput
    data: XOR<tvUpdateManyMutationInput, tvUncheckedUpdateManyWithoutTvsInput>
  }

  export type seasonUpsertWithWhereUniqueWithoutCollectionInput = {
    where: seasonWhereUniqueInput
    update: XOR<seasonUpdateWithoutCollectionInput, seasonUncheckedUpdateWithoutCollectionInput>
    create: XOR<seasonCreateWithoutCollectionInput, seasonUncheckedCreateWithoutCollectionInput>
  }

  export type seasonUpdateWithWhereUniqueWithoutCollectionInput = {
    where: seasonWhereUniqueInput
    data: XOR<seasonUpdateWithoutCollectionInput, seasonUncheckedUpdateWithoutCollectionInput>
  }

  export type seasonUpdateManyWithWhereWithoutCollectionInput = {
    where: seasonScalarWhereInput
    data: XOR<seasonUpdateManyMutationInput, seasonUncheckedUpdateManyWithoutSeasonsInput>
  }

  export type movieUpsertWithWhereUniqueWithoutCollectionInput = {
    where: movieWhereUniqueInput
    update: XOR<movieUpdateWithoutCollectionInput, movieUncheckedUpdateWithoutCollectionInput>
    create: XOR<movieCreateWithoutCollectionInput, movieUncheckedCreateWithoutCollectionInput>
  }

  export type movieUpdateWithWhereUniqueWithoutCollectionInput = {
    where: movieWhereUniqueInput
    data: XOR<movieUpdateWithoutCollectionInput, movieUncheckedUpdateWithoutCollectionInput>
  }

  export type movieUpdateManyWithWhereWithoutCollectionInput = {
    where: movieScalarWhereInput
    data: XOR<movieUpdateManyMutationInput, movieUncheckedUpdateManyWithoutMoviesInput>
  }

  export type userUpsertWithoutCollectionsInput = {
    update: XOR<userUpdateWithoutCollectionsInput, userUncheckedUpdateWithoutCollectionsInput>
    create: XOR<userCreateWithoutCollectionsInput, userUncheckedCreateWithoutCollectionsInput>
  }

  export type userUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type outputCreateWithoutAsync_taskInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    lines?: output_lineCreateNestedManyWithoutOutputInput
    user: userCreateNestedOneWithoutOutputsInput
  }

  export type outputUncheckedCreateWithoutAsync_taskInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    user_id: string
    lines?: output_lineUncheckedCreateNestedManyWithoutOutputInput
  }

  export type outputCreateOrConnectWithoutAsync_taskInput = {
    where: outputWhereUniqueInput
    create: XOR<outputCreateWithoutAsync_taskInput, outputUncheckedCreateWithoutAsync_taskInput>
  }

  export type userCreateWithoutAsync_taskInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAsync_taskInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAsync_taskInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAsync_taskInput, userUncheckedCreateWithoutAsync_taskInput>
  }

  export type outputUpsertWithoutAsync_taskInput = {
    update: XOR<outputUpdateWithoutAsync_taskInput, outputUncheckedUpdateWithoutAsync_taskInput>
    create: XOR<outputCreateWithoutAsync_taskInput, outputUncheckedCreateWithoutAsync_taskInput>
  }

  export type outputUpdateWithoutAsync_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: output_lineUpdateManyWithoutOutputNestedInput
    user?: userUpdateOneRequiredWithoutOutputsNestedInput
  }

  export type outputUncheckedUpdateWithoutAsync_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    lines?: output_lineUncheckedUpdateManyWithoutOutputNestedInput
  }

  export type userUpsertWithoutAsync_taskInput = {
    update: XOR<userUpdateWithoutAsync_taskInput, userUncheckedUpdateWithoutAsync_taskInput>
    create: XOR<userCreateWithoutAsync_taskInput, userUncheckedCreateWithoutAsync_taskInput>
  }

  export type userUpdateWithoutAsync_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAsync_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type output_lineCreateWithoutOutputInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    content: string
  }

  export type output_lineUncheckedCreateWithoutOutputInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    content: string
  }

  export type output_lineCreateOrConnectWithoutOutputInput = {
    where: output_lineWhereUniqueInput
    create: XOR<output_lineCreateWithoutOutputInput, output_lineUncheckedCreateWithoutOutputInput>
  }

  export type userCreateWithoutOutputsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutOutputsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutOutputsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutOutputsInput, userUncheckedCreateWithoutOutputsInput>
  }

  export type async_taskCreateWithoutOutputInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    desc?: string | null
    status?: number | null
    need_stop?: number | null
    error?: string | null
    user: userCreateNestedOneWithoutAsync_taskInput
  }

  export type async_taskUncheckedCreateWithoutOutputInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    desc?: string | null
    status?: number | null
    need_stop?: number | null
    error?: string | null
    user_id: string
  }

  export type async_taskCreateOrConnectWithoutOutputInput = {
    where: async_taskWhereUniqueInput
    create: XOR<async_taskCreateWithoutOutputInput, async_taskUncheckedCreateWithoutOutputInput>
  }

  export type output_lineUpsertWithWhereUniqueWithoutOutputInput = {
    where: output_lineWhereUniqueInput
    update: XOR<output_lineUpdateWithoutOutputInput, output_lineUncheckedUpdateWithoutOutputInput>
    create: XOR<output_lineCreateWithoutOutputInput, output_lineUncheckedCreateWithoutOutputInput>
  }

  export type output_lineUpdateWithWhereUniqueWithoutOutputInput = {
    where: output_lineWhereUniqueInput
    data: XOR<output_lineUpdateWithoutOutputInput, output_lineUncheckedUpdateWithoutOutputInput>
  }

  export type output_lineUpdateManyWithWhereWithoutOutputInput = {
    where: output_lineScalarWhereInput
    data: XOR<output_lineUpdateManyMutationInput, output_lineUncheckedUpdateManyWithoutLinesInput>
  }

  export type output_lineScalarWhereInput = {
    AND?: Enumerable<output_lineScalarWhereInput>
    OR?: Enumerable<output_lineScalarWhereInput>
    NOT?: Enumerable<output_lineScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    content?: StringFilter | string
    output_id?: StringNullableFilter | string | null
  }

  export type userUpsertWithoutOutputsInput = {
    update: XOR<userUpdateWithoutOutputsInput, userUncheckedUpdateWithoutOutputsInput>
    create: XOR<userCreateWithoutOutputsInput, userUncheckedCreateWithoutOutputsInput>
  }

  export type userUpdateWithoutOutputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutOutputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type async_taskUpsertWithoutOutputInput = {
    update: XOR<async_taskUpdateWithoutOutputInput, async_taskUncheckedUpdateWithoutOutputInput>
    create: XOR<async_taskCreateWithoutOutputInput, async_taskUncheckedCreateWithoutOutputInput>
  }

  export type async_taskUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    need_stop?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutAsync_taskNestedInput
  }

  export type async_taskUncheckedUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    need_stop?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type outputCreateWithoutLinesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    user: userCreateNestedOneWithoutOutputsInput
    async_task?: async_taskCreateNestedOneWithoutOutputInput
  }

  export type outputUncheckedCreateWithoutLinesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    user_id: string
    async_task?: async_taskUncheckedCreateNestedOneWithoutOutputInput
  }

  export type outputCreateOrConnectWithoutLinesInput = {
    where: outputWhereUniqueInput
    create: XOR<outputCreateWithoutLinesInput, outputUncheckedCreateWithoutLinesInput>
  }

  export type outputUpsertWithoutLinesInput = {
    update: XOR<outputUpdateWithoutLinesInput, outputUncheckedUpdateWithoutLinesInput>
    create: XOR<outputCreateWithoutLinesInput, outputUncheckedCreateWithoutLinesInput>
  }

  export type outputUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutOutputsNestedInput
    async_task?: async_taskUpdateOneWithoutOutputNestedInput
  }

  export type outputUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    async_task?: async_taskUncheckedUpdateOneWithoutOutputNestedInput
  }

  export type tvCreateWithoutPlay_historiesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile: tv_profileCreateNestedOneWithoutTvsInput
    collection?: collectionCreateNestedOneWithoutTvsInput
    user: userCreateNestedOneWithoutTvInput
    seasons?: seasonCreateNestedManyWithoutTvInput
    episodes?: episodeCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutTvInput
    reports?: reportCreateNestedManyWithoutTvInput
  }

  export type tvUncheckedCreateWithoutPlay_historiesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile_id: string
    collection_id?: string | null
    user_id: string
    seasons?: seasonUncheckedCreateNestedManyWithoutTvInput
    episodes?: episodeUncheckedCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutTvInput
    reports?: reportUncheckedCreateNestedManyWithoutTvInput
  }

  export type tvCreateOrConnectWithoutPlay_historiesInput = {
    where: tvWhereUniqueInput
    create: XOR<tvCreateWithoutPlay_historiesInput, tvUncheckedCreateWithoutPlay_historiesInput>
  }

  export type seasonCreateWithoutPlay_historiesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile: season_profileCreateNestedOneWithoutSeasonsInput
    collection?: collectionCreateNestedOneWithoutSeasonsInput
    tv: tvCreateNestedOneWithoutSeasonsInput
    user: userCreateNestedOneWithoutSeasonsInput
    parsed_season?: parsed_seasonCreateNestedManyWithoutSeasonInput
    episodes?: episodeCreateNestedManyWithoutSeasonInput
    reports?: reportCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutSeasonInput
  }

  export type seasonUncheckedCreateWithoutPlay_historiesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile_id: string
    collection_id?: string | null
    tv_id: string
    user_id: string
    parsed_season?: parsed_seasonUncheckedCreateNestedManyWithoutSeasonInput
    episodes?: episodeUncheckedCreateNestedManyWithoutSeasonInput
    reports?: reportUncheckedCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonCreateOrConnectWithoutPlay_historiesInput = {
    where: seasonWhereUniqueInput
    create: XOR<seasonCreateWithoutPlay_historiesInput, seasonUncheckedCreateWithoutPlay_historiesInput>
  }

  export type episodeCreateWithoutPlay_historiesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile: episode_profileCreateNestedOneWithoutEpisodesInput
    tv: tvCreateNestedOneWithoutEpisodesInput
    season: seasonCreateNestedOneWithoutEpisodesInput
    user: userCreateNestedOneWithoutEpisodeInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutEpisodeInput
    reports?: reportCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleCreateNestedManyWithoutEpisodeInput
  }

  export type episodeUncheckedCreateWithoutPlay_historiesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile_id: string
    tv_id: string
    season_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutEpisodeInput
    reports?: reportUncheckedCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type episodeCreateOrConnectWithoutPlay_historiesInput = {
    where: episodeWhereUniqueInput
    create: XOR<episodeCreateWithoutPlay_historiesInput, episodeUncheckedCreateWithoutPlay_historiesInput>
  }

  export type movieCreateWithoutPlay_historiesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile: movie_profileCreateNestedOneWithoutMoviesInput
    user: userCreateNestedOneWithoutMovieInput
    collection?: collectionCreateNestedOneWithoutMoviesInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutMovieInput
    reports?: reportCreateNestedManyWithoutMovieInput
    subtitles?: subtitleCreateNestedManyWithoutMovieInput
  }

  export type movieUncheckedCreateWithoutPlay_historiesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile_id: string
    user_id: string
    collection_id?: string | null
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutMovieInput
    reports?: reportUncheckedCreateNestedManyWithoutMovieInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutMovieInput
  }

  export type movieCreateOrConnectWithoutPlay_historiesInput = {
    where: movieWhereUniqueInput
    create: XOR<movieCreateWithoutPlay_historiesInput, movieUncheckedCreateWithoutPlay_historiesInput>
  }

  export type memberCreateWithoutPlay_historiesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter?: memberCreateNestedOneWithoutInviteesInput
    user: userCreateNestedOneWithoutMembersInput
    member_setting?: member_settingCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenCreateNestedManyWithoutMemberInput
    reports?: reportCreateNestedManyWithoutMemberInput
    invitees?: memberCreateNestedManyWithoutInviterInput
    notifications?: member_notificationCreateNestedManyWithoutMemberInput
  }

  export type memberUncheckedCreateWithoutPlay_historiesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter_id?: string | null
    user_id: string
    member_setting?: member_settingUncheckedCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenUncheckedCreateNestedManyWithoutMemberInput
    reports?: reportUncheckedCreateNestedManyWithoutMemberInput
    invitees?: memberUncheckedCreateNestedManyWithoutInviterInput
    notifications?: member_notificationUncheckedCreateNestedManyWithoutMemberInput
  }

  export type memberCreateOrConnectWithoutPlay_historiesInput = {
    where: memberWhereUniqueInput
    create: XOR<memberCreateWithoutPlay_historiesInput, memberUncheckedCreateWithoutPlay_historiesInput>
  }

  export type tvUpsertWithoutPlay_historiesInput = {
    update: XOR<tvUpdateWithoutPlay_historiesInput, tvUncheckedUpdateWithoutPlay_historiesInput>
    create: XOR<tvCreateWithoutPlay_historiesInput, tvUncheckedCreateWithoutPlay_historiesInput>
  }

  export type tvUpdateWithoutPlay_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: tv_profileUpdateOneRequiredWithoutTvsNestedInput
    collection?: collectionUpdateOneWithoutTvsNestedInput
    user?: userUpdateOneRequiredWithoutTvNestedInput
    seasons?: seasonUpdateManyWithoutTvNestedInput
    episodes?: episodeUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutTvNestedInput
    reports?: reportUpdateManyWithoutTvNestedInput
  }

  export type tvUncheckedUpdateWithoutPlay_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    seasons?: seasonUncheckedUpdateManyWithoutTvNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutTvNestedInput
    reports?: reportUncheckedUpdateManyWithoutTvNestedInput
  }

  export type seasonUpsertWithoutPlay_historiesInput = {
    update: XOR<seasonUpdateWithoutPlay_historiesInput, seasonUncheckedUpdateWithoutPlay_historiesInput>
    create: XOR<seasonCreateWithoutPlay_historiesInput, seasonUncheckedCreateWithoutPlay_historiesInput>
  }

  export type seasonUpdateWithoutPlay_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile?: season_profileUpdateOneRequiredWithoutSeasonsNestedInput
    collection?: collectionUpdateOneWithoutSeasonsNestedInput
    tv?: tvUpdateOneRequiredWithoutSeasonsNestedInput
    user?: userUpdateOneRequiredWithoutSeasonsNestedInput
    parsed_season?: parsed_seasonUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUpdateManyWithoutSeasonNestedInput
    reports?: reportUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUncheckedUpdateWithoutPlay_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_season?: parsed_seasonUncheckedUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutSeasonNestedInput
    reports?: reportUncheckedUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type episodeUpsertWithoutPlay_historiesInput = {
    update: XOR<episodeUpdateWithoutPlay_historiesInput, episodeUncheckedUpdateWithoutPlay_historiesInput>
    create: XOR<episodeCreateWithoutPlay_historiesInput, episodeUncheckedCreateWithoutPlay_historiesInput>
  }

  export type episodeUpdateWithoutPlay_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile?: episode_profileUpdateOneRequiredWithoutEpisodesNestedInput
    tv?: tvUpdateOneRequiredWithoutEpisodesNestedInput
    season?: seasonUpdateOneRequiredWithoutEpisodesNestedInput
    user?: userUpdateOneRequiredWithoutEpisodeNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutEpisodeNestedInput
    reports?: reportUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUncheckedUpdateWithoutPlay_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    tv_id?: StringFieldUpdateOperationsInput | string
    season_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutEpisodeNestedInput
    reports?: reportUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type movieUpsertWithoutPlay_historiesInput = {
    update: XOR<movieUpdateWithoutPlay_historiesInput, movieUncheckedUpdateWithoutPlay_historiesInput>
    create: XOR<movieCreateWithoutPlay_historiesInput, movieUncheckedCreateWithoutPlay_historiesInput>
  }

  export type movieUpdateWithoutPlay_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: movie_profileUpdateOneRequiredWithoutMoviesNestedInput
    user?: userUpdateOneRequiredWithoutMovieNestedInput
    collection?: collectionUpdateOneWithoutMoviesNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutMovieNestedInput
    reports?: reportUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUpdateManyWithoutMovieNestedInput
  }

  export type movieUncheckedUpdateWithoutPlay_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutMovieNestedInput
    reports?: reportUncheckedUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type memberUpsertWithoutPlay_historiesInput = {
    update: XOR<memberUpdateWithoutPlay_historiesInput, memberUncheckedUpdateWithoutPlay_historiesInput>
    create: XOR<memberCreateWithoutPlay_historiesInput, memberUncheckedCreateWithoutPlay_historiesInput>
  }

  export type memberUpdateWithoutPlay_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter?: memberUpdateOneWithoutInviteesNestedInput
    user?: userUpdateOneRequiredWithoutMembersNestedInput
    member_setting?: member_settingUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUpdateManyWithoutMemberNestedInput
    reports?: reportUpdateManyWithoutMemberNestedInput
    invitees?: memberUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUpdateManyWithoutMemberNestedInput
  }

  export type memberUncheckedUpdateWithoutPlay_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    member_setting?: member_settingUncheckedUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUncheckedUpdateManyWithoutMemberNestedInput
    reports?: reportUncheckedUpdateManyWithoutMemberNestedInput
    invitees?: memberUncheckedUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type tv_profileCreateWithoutSnapshotsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    original_name?: string | null
    overview?: string | null
    poster_path?: string | null
    backdrop_path?: string | null
    first_air_date?: string | null
    original_language?: string | null
    origin_country?: string | null
    genres?: string | null
    popularity?: number | null
    vote_average?: number | null
    vote_count?: number | null
    episode_count?: number | null
    season_count?: number | null
    status?: string | null
    in_production?: number | null
    tvs?: tvCreateNestedManyWithoutProfileInput
  }

  export type tv_profileUncheckedCreateWithoutSnapshotsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    source?: number | null
    sources?: string | null
    name?: string | null
    original_name?: string | null
    overview?: string | null
    poster_path?: string | null
    backdrop_path?: string | null
    first_air_date?: string | null
    original_language?: string | null
    origin_country?: string | null
    genres?: string | null
    popularity?: number | null
    vote_average?: number | null
    vote_count?: number | null
    episode_count?: number | null
    season_count?: number | null
    status?: string | null
    in_production?: number | null
    tvs?: tvUncheckedCreateNestedManyWithoutProfileInput
  }

  export type tv_profileCreateOrConnectWithoutSnapshotsInput = {
    where: tv_profileWhereUniqueInput
    create: XOR<tv_profileCreateWithoutSnapshotsInput, tv_profileUncheckedCreateWithoutSnapshotsInput>
  }

  export type tv_profileUpsertWithoutSnapshotsInput = {
    update: XOR<tv_profileUpdateWithoutSnapshotsInput, tv_profileUncheckedUpdateWithoutSnapshotsInput>
    create: XOR<tv_profileCreateWithoutSnapshotsInput, tv_profileUncheckedCreateWithoutSnapshotsInput>
  }

  export type tv_profileUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    first_air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    season_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    tvs?: tvUpdateManyWithoutProfileNestedInput
  }

  export type tv_profileUncheckedUpdateWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    source?: NullableIntFieldUpdateOperationsInput | number | null
    sources?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    overview?: NullableStringFieldUpdateOperationsInput | string | null
    poster_path?: NullableStringFieldUpdateOperationsInput | string | null
    backdrop_path?: NullableStringFieldUpdateOperationsInput | string | null
    first_air_date?: NullableStringFieldUpdateOperationsInput | string | null
    original_language?: NullableStringFieldUpdateOperationsInput | string | null
    origin_country?: NullableStringFieldUpdateOperationsInput | string | null
    genres?: NullableStringFieldUpdateOperationsInput | string | null
    popularity?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_average?: NullableFloatFieldUpdateOperationsInput | number | null
    vote_count?: NullableFloatFieldUpdateOperationsInput | number | null
    episode_count?: NullableIntFieldUpdateOperationsInput | number | null
    season_count?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableStringFieldUpdateOperationsInput | string | null
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    tvs?: tvUncheckedUpdateManyWithoutProfileNestedInput
  }

  export type userCreateWithoutShared_filesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutShared_filesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutShared_filesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutShared_filesInput, userUncheckedCreateWithoutShared_filesInput>
  }

  export type userUpsertWithoutShared_filesInput = {
    update: XOR<userUpdateWithoutShared_filesInput, userUncheckedUpdateWithoutShared_filesInput>
    create: XOR<userCreateWithoutShared_filesInput, userUncheckedCreateWithoutShared_filesInput>
  }

  export type userUpdateWithoutShared_filesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutShared_filesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type driveCreateWithoutShared_file_in_progressInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    user: userCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutShared_file_in_progressInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    user_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutShared_file_in_progressInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutShared_file_in_progressInput, driveUncheckedCreateWithoutShared_file_in_progressInput>
  }

  export type userCreateWithoutShared_file_in_progressInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutShared_file_in_progressInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutShared_file_in_progressInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutShared_file_in_progressInput, userUncheckedCreateWithoutShared_file_in_progressInput>
  }

  export type driveUpsertWithoutShared_file_in_progressInput = {
    update: XOR<driveUpdateWithoutShared_file_in_progressInput, driveUncheckedUpdateWithoutShared_file_in_progressInput>
    create: XOR<driveCreateWithoutShared_file_in_progressInput, driveUncheckedCreateWithoutShared_file_in_progressInput>
  }

  export type driveUpdateWithoutShared_file_in_progressInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutShared_file_in_progressInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type userUpsertWithoutShared_file_in_progressInput = {
    update: XOR<userUpdateWithoutShared_file_in_progressInput, userUncheckedUpdateWithoutShared_file_in_progressInput>
    create: XOR<userCreateWithoutShared_file_in_progressInput, userUncheckedCreateWithoutShared_file_in_progressInput>
  }

  export type userUpdateWithoutShared_file_in_progressInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutShared_file_in_progressInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type seasonCreateWithoutSync_tasksInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile: season_profileCreateNestedOneWithoutSeasonsInput
    collection?: collectionCreateNestedOneWithoutSeasonsInput
    tv: tvCreateNestedOneWithoutSeasonsInput
    user: userCreateNestedOneWithoutSeasonsInput
    parsed_season?: parsed_seasonCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyCreateNestedManyWithoutSeasonInput
    episodes?: episodeCreateNestedManyWithoutSeasonInput
    reports?: reportCreateNestedManyWithoutSeasonInput
  }

  export type seasonUncheckedCreateWithoutSync_tasksInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile_id: string
    collection_id?: string | null
    tv_id: string
    user_id: string
    parsed_season?: parsed_seasonUncheckedCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutSeasonInput
    episodes?: episodeUncheckedCreateNestedManyWithoutSeasonInput
    reports?: reportUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonCreateOrConnectWithoutSync_tasksInput = {
    where: seasonWhereUniqueInput
    create: XOR<seasonCreateWithoutSync_tasksInput, seasonUncheckedCreateWithoutSync_tasksInput>
  }

  export type driveCreateWithoutSync_tasksInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    user: userCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutSync_tasksInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    user_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutSync_tasksInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutSync_tasksInput, driveUncheckedCreateWithoutSync_tasksInput>
  }

  export type userCreateWithoutSync_tasksInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSync_tasksInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSync_tasksInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSync_tasksInput, userUncheckedCreateWithoutSync_tasksInput>
  }

  export type seasonUpsertWithoutSync_tasksInput = {
    update: XOR<seasonUpdateWithoutSync_tasksInput, seasonUncheckedUpdateWithoutSync_tasksInput>
    create: XOR<seasonCreateWithoutSync_tasksInput, seasonUncheckedCreateWithoutSync_tasksInput>
  }

  export type seasonUpdateWithoutSync_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile?: season_profileUpdateOneRequiredWithoutSeasonsNestedInput
    collection?: collectionUpdateOneWithoutSeasonsNestedInput
    tv?: tvUpdateOneRequiredWithoutSeasonsNestedInput
    user?: userUpdateOneRequiredWithoutSeasonsNestedInput
    parsed_season?: parsed_seasonUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUpdateManyWithoutSeasonNestedInput
    reports?: reportUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUncheckedUpdateWithoutSync_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_season?: parsed_seasonUncheckedUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutSeasonNestedInput
    reports?: reportUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type driveUpsertWithoutSync_tasksInput = {
    update: XOR<driveUpdateWithoutSync_tasksInput, driveUncheckedUpdateWithoutSync_tasksInput>
    create: XOR<driveCreateWithoutSync_tasksInput, driveUncheckedCreateWithoutSync_tasksInput>
  }

  export type driveUpdateWithoutSync_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutSync_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type userUpsertWithoutSync_tasksInput = {
    update: XOR<userUpdateWithoutSync_tasksInput, userUncheckedUpdateWithoutSync_tasksInput>
    create: XOR<userCreateWithoutSync_tasksInput, userUncheckedCreateWithoutSync_tasksInput>
  }

  export type userUpdateWithoutSync_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSync_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type driveCreateWithoutDrive_check_inInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    user: userCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutDrive_check_inInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    user_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutDrive_check_inInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutDrive_check_inInput, driveUncheckedCreateWithoutDrive_check_inInput>
  }

  export type driveUpsertWithoutDrive_check_inInput = {
    update: XOR<driveUpdateWithoutDrive_check_inInput, driveUncheckedUpdateWithoutDrive_check_inInput>
    create: XOR<driveCreateWithoutDrive_check_inInput, driveUncheckedCreateWithoutDrive_check_inInput>
  }

  export type driveUpdateWithoutDrive_check_inInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutDrive_check_inInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type driveCreateWithoutTmp_filesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    user: userCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutTmp_filesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    user_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutTmp_filesInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutTmp_filesInput, driveUncheckedCreateWithoutTmp_filesInput>
  }

  export type userCreateWithoutTmp_filesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTmp_filesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTmp_filesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTmp_filesInput, userUncheckedCreateWithoutTmp_filesInput>
  }

  export type driveUpsertWithoutTmp_filesInput = {
    update: XOR<driveUpdateWithoutTmp_filesInput, driveUncheckedUpdateWithoutTmp_filesInput>
    create: XOR<driveCreateWithoutTmp_filesInput, driveUncheckedCreateWithoutTmp_filesInput>
  }

  export type driveUpdateWithoutTmp_filesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutTmp_filesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type userUpsertWithoutTmp_filesInput = {
    update: XOR<userUpdateWithoutTmp_filesInput, userUncheckedUpdateWithoutTmp_filesInput>
    create: XOR<userCreateWithoutTmp_filesInput, userUncheckedCreateWithoutTmp_filesInput>
  }

  export type userUpdateWithoutTmp_filesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTmp_filesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutTv_need_completeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutTv_need_completeInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutTv_need_completeInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutTv_need_completeInput, userUncheckedCreateWithoutTv_need_completeInput>
  }

  export type userUpsertWithoutTv_need_completeInput = {
    update: XOR<userUpdateWithoutTv_need_completeInput, userUncheckedUpdateWithoutTv_need_completeInput>
    create: XOR<userCreateWithoutTv_need_completeInput, userUncheckedCreateWithoutTv_need_completeInput>
  }

  export type userUpdateWithoutTv_need_completeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutTv_need_completeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type driveCreateWithoutFilesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    user: userCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutFilesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    user_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutFilesInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutFilesInput, driveUncheckedCreateWithoutFilesInput>
  }

  export type userCreateWithoutFilesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutFilesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutFilesInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutFilesInput, userUncheckedCreateWithoutFilesInput>
  }

  export type driveUpsertWithoutFilesInput = {
    update: XOR<driveUpdateWithoutFilesInput, driveUncheckedUpdateWithoutFilesInput>
    create: XOR<driveCreateWithoutFilesInput, driveUncheckedCreateWithoutFilesInput>
  }

  export type driveUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type userUpsertWithoutFilesInput = {
    update: XOR<userUpdateWithoutFilesInput, userUncheckedUpdateWithoutFilesInput>
    create: XOR<userCreateWithoutFilesInput, userUncheckedCreateWithoutFilesInput>
  }

  export type userUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type memberCreateWithoutInviteesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter?: memberCreateNestedOneWithoutInviteesInput
    user: userCreateNestedOneWithoutMembersInput
    member_setting?: member_settingCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenCreateNestedManyWithoutMemberInput
    play_histories?: play_historyCreateNestedManyWithoutMemberInput
    reports?: reportCreateNestedManyWithoutMemberInput
    notifications?: member_notificationCreateNestedManyWithoutMemberInput
  }

  export type memberUncheckedCreateWithoutInviteesInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter_id?: string | null
    user_id: string
    member_setting?: member_settingUncheckedCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenUncheckedCreateNestedManyWithoutMemberInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMemberInput
    reports?: reportUncheckedCreateNestedManyWithoutMemberInput
    notifications?: member_notificationUncheckedCreateNestedManyWithoutMemberInput
  }

  export type memberCreateOrConnectWithoutInviteesInput = {
    where: memberWhereUniqueInput
    create: XOR<memberCreateWithoutInviteesInput, memberUncheckedCreateWithoutInviteesInput>
  }

  export type userCreateWithoutMembersInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutMembersInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutMembersInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutMembersInput, userUncheckedCreateWithoutMembersInput>
  }

  export type member_settingCreateWithoutMemberInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    data: string
  }

  export type member_settingUncheckedCreateWithoutMemberInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    data: string
  }

  export type member_settingCreateOrConnectWithoutMemberInput = {
    where: member_settingWhereUniqueInput
    create: XOR<member_settingCreateWithoutMemberInput, member_settingUncheckedCreateWithoutMemberInput>
  }

  export type member_tokenCreateWithoutMemberInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    token: string
    used?: number | null
    expired_at?: string | null
  }

  export type member_tokenUncheckedCreateWithoutMemberInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    token: string
    used?: number | null
    expired_at?: string | null
  }

  export type member_tokenCreateOrConnectWithoutMemberInput = {
    where: member_tokenWhereUniqueInput
    create: XOR<member_tokenCreateWithoutMemberInput, member_tokenUncheckedCreateWithoutMemberInput>
  }

  export type play_historyCreateWithoutMemberInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    tv?: tvCreateNestedOneWithoutPlay_historiesInput
    season?: seasonCreateNestedOneWithoutPlay_historiesInput
    episode?: episodeCreateNestedOneWithoutPlay_historiesInput
    movie?: movieCreateNestedOneWithoutPlay_historiesInput
  }

  export type play_historyUncheckedCreateWithoutMemberInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    duration?: number | null
    current_time?: number | null
    thumbnail?: string | null
    file_id?: string | null
    tv_id?: string | null
    season_id?: string | null
    episode_id?: string | null
    movie_id?: string | null
  }

  export type play_historyCreateOrConnectWithoutMemberInput = {
    where: play_historyWhereUniqueInput
    create: XOR<play_historyCreateWithoutMemberInput, play_historyUncheckedCreateWithoutMemberInput>
  }

  export type reportCreateWithoutMemberInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv?: tvCreateNestedOneWithoutReportsInput
    season?: seasonCreateNestedOneWithoutReportsInput
    episode?: episodeCreateNestedOneWithoutReportsInput
    movie?: movieCreateNestedOneWithoutReportsInput
    user: userCreateNestedOneWithoutReportsInput
  }

  export type reportUncheckedCreateWithoutMemberInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv_id?: string | null
    season_id?: string | null
    episode_id?: string | null
    movie_id?: string | null
    user_id: string
  }

  export type reportCreateOrConnectWithoutMemberInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutMemberInput, reportUncheckedCreateWithoutMemberInput>
  }

  export type memberCreateWithoutInviterInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    user: userCreateNestedOneWithoutMembersInput
    member_setting?: member_settingCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenCreateNestedManyWithoutMemberInput
    play_histories?: play_historyCreateNestedManyWithoutMemberInput
    reports?: reportCreateNestedManyWithoutMemberInput
    invitees?: memberCreateNestedManyWithoutInviterInput
    notifications?: member_notificationCreateNestedManyWithoutMemberInput
  }

  export type memberUncheckedCreateWithoutInviterInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    user_id: string
    member_setting?: member_settingUncheckedCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenUncheckedCreateNestedManyWithoutMemberInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMemberInput
    reports?: reportUncheckedCreateNestedManyWithoutMemberInput
    invitees?: memberUncheckedCreateNestedManyWithoutInviterInput
    notifications?: member_notificationUncheckedCreateNestedManyWithoutMemberInput
  }

  export type memberCreateOrConnectWithoutInviterInput = {
    where: memberWhereUniqueInput
    create: XOR<memberCreateWithoutInviterInput, memberUncheckedCreateWithoutInviterInput>
  }

  export type member_notificationCreateWithoutMemberInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    content?: string | null
    type?: number | null
    status?: number | null
    is_delete?: number | null
  }

  export type member_notificationUncheckedCreateWithoutMemberInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    content?: string | null
    type?: number | null
    status?: number | null
    is_delete?: number | null
  }

  export type member_notificationCreateOrConnectWithoutMemberInput = {
    where: member_notificationWhereUniqueInput
    create: XOR<member_notificationCreateWithoutMemberInput, member_notificationUncheckedCreateWithoutMemberInput>
  }

  export type memberUpsertWithoutInviteesInput = {
    update: XOR<memberUpdateWithoutInviteesInput, memberUncheckedUpdateWithoutInviteesInput>
    create: XOR<memberCreateWithoutInviteesInput, memberUncheckedCreateWithoutInviteesInput>
  }

  export type memberUpdateWithoutInviteesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter?: memberUpdateOneWithoutInviteesNestedInput
    user?: userUpdateOneRequiredWithoutMembersNestedInput
    member_setting?: member_settingUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUpdateManyWithoutMemberNestedInput
    reports?: reportUpdateManyWithoutMemberNestedInput
    notifications?: member_notificationUpdateManyWithoutMemberNestedInput
  }

  export type memberUncheckedUpdateWithoutInviteesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    member_setting?: member_settingUncheckedUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUncheckedUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutMemberNestedInput
    reports?: reportUncheckedUpdateManyWithoutMemberNestedInput
    notifications?: member_notificationUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type userUpsertWithoutMembersInput = {
    update: XOR<userUpdateWithoutMembersInput, userUncheckedUpdateWithoutMembersInput>
    create: XOR<userCreateWithoutMembersInput, userUncheckedCreateWithoutMembersInput>
  }

  export type userUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type member_settingUpsertWithoutMemberInput = {
    update: XOR<member_settingUpdateWithoutMemberInput, member_settingUncheckedUpdateWithoutMemberInput>
    create: XOR<member_settingCreateWithoutMemberInput, member_settingUncheckedCreateWithoutMemberInput>
  }

  export type member_settingUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
  }

  export type member_settingUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    data?: StringFieldUpdateOperationsInput | string
  }

  export type member_tokenUpsertWithWhereUniqueWithoutMemberInput = {
    where: member_tokenWhereUniqueInput
    update: XOR<member_tokenUpdateWithoutMemberInput, member_tokenUncheckedUpdateWithoutMemberInput>
    create: XOR<member_tokenCreateWithoutMemberInput, member_tokenUncheckedCreateWithoutMemberInput>
  }

  export type member_tokenUpdateWithWhereUniqueWithoutMemberInput = {
    where: member_tokenWhereUniqueInput
    data: XOR<member_tokenUpdateWithoutMemberInput, member_tokenUncheckedUpdateWithoutMemberInput>
  }

  export type member_tokenUpdateManyWithWhereWithoutMemberInput = {
    where: member_tokenScalarWhereInput
    data: XOR<member_tokenUpdateManyMutationInput, member_tokenUncheckedUpdateManyWithoutMember_tokensInput>
  }

  export type member_tokenScalarWhereInput = {
    AND?: Enumerable<member_tokenScalarWhereInput>
    OR?: Enumerable<member_tokenScalarWhereInput>
    NOT?: Enumerable<member_tokenScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    token?: StringFilter | string
    used?: FloatNullableFilter | number | null
    expired_at?: StringNullableFilter | string | null
    member_id?: StringFilter | string
  }

  export type play_historyUpsertWithWhereUniqueWithoutMemberInput = {
    where: play_historyWhereUniqueInput
    update: XOR<play_historyUpdateWithoutMemberInput, play_historyUncheckedUpdateWithoutMemberInput>
    create: XOR<play_historyCreateWithoutMemberInput, play_historyUncheckedCreateWithoutMemberInput>
  }

  export type play_historyUpdateWithWhereUniqueWithoutMemberInput = {
    where: play_historyWhereUniqueInput
    data: XOR<play_historyUpdateWithoutMemberInput, play_historyUncheckedUpdateWithoutMemberInput>
  }

  export type play_historyUpdateManyWithWhereWithoutMemberInput = {
    where: play_historyScalarWhereInput
    data: XOR<play_historyUpdateManyMutationInput, play_historyUncheckedUpdateManyWithoutPlay_historiesInput>
  }

  export type reportUpsertWithWhereUniqueWithoutMemberInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutMemberInput, reportUncheckedUpdateWithoutMemberInput>
    create: XOR<reportCreateWithoutMemberInput, reportUncheckedCreateWithoutMemberInput>
  }

  export type reportUpdateWithWhereUniqueWithoutMemberInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutMemberInput, reportUncheckedUpdateWithoutMemberInput>
  }

  export type reportUpdateManyWithWhereWithoutMemberInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReportsInput>
  }

  export type memberUpsertWithWhereUniqueWithoutInviterInput = {
    where: memberWhereUniqueInput
    update: XOR<memberUpdateWithoutInviterInput, memberUncheckedUpdateWithoutInviterInput>
    create: XOR<memberCreateWithoutInviterInput, memberUncheckedCreateWithoutInviterInput>
  }

  export type memberUpdateWithWhereUniqueWithoutInviterInput = {
    where: memberWhereUniqueInput
    data: XOR<memberUpdateWithoutInviterInput, memberUncheckedUpdateWithoutInviterInput>
  }

  export type memberUpdateManyWithWhereWithoutInviterInput = {
    where: memberScalarWhereInput
    data: XOR<memberUpdateManyMutationInput, memberUncheckedUpdateManyWithoutInviteesInput>
  }

  export type memberScalarWhereInput = {
    AND?: Enumerable<memberScalarWhereInput>
    OR?: Enumerable<memberScalarWhereInput>
    NOT?: Enumerable<memberScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    email?: StringNullableFilter | string | null
    name?: StringNullableFilter | string | null
    avatar?: StringNullableFilter | string | null
    remark?: StringFilter | string
    permission?: StringNullableFilter | string | null
    disabled?: IntNullableFilter | number | null
    delete?: IntNullableFilter | number | null
    inviter_id?: StringNullableFilter | string | null
    user_id?: StringFilter | string
  }

  export type member_notificationUpsertWithWhereUniqueWithoutMemberInput = {
    where: member_notificationWhereUniqueInput
    update: XOR<member_notificationUpdateWithoutMemberInput, member_notificationUncheckedUpdateWithoutMemberInput>
    create: XOR<member_notificationCreateWithoutMemberInput, member_notificationUncheckedCreateWithoutMemberInput>
  }

  export type member_notificationUpdateWithWhereUniqueWithoutMemberInput = {
    where: member_notificationWhereUniqueInput
    data: XOR<member_notificationUpdateWithoutMemberInput, member_notificationUncheckedUpdateWithoutMemberInput>
  }

  export type member_notificationUpdateManyWithWhereWithoutMemberInput = {
    where: member_notificationScalarWhereInput
    data: XOR<member_notificationUpdateManyMutationInput, member_notificationUncheckedUpdateManyWithoutNotificationsInput>
  }

  export type member_notificationScalarWhereInput = {
    AND?: Enumerable<member_notificationScalarWhereInput>
    OR?: Enumerable<member_notificationScalarWhereInput>
    NOT?: Enumerable<member_notificationScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    content?: StringNullableFilter | string | null
    type?: IntNullableFilter | number | null
    status?: IntNullableFilter | number | null
    is_delete?: IntNullableFilter | number | null
    member_id?: StringFilter | string
  }

  export type memberCreateWithoutMember_tokensInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter?: memberCreateNestedOneWithoutInviteesInput
    user: userCreateNestedOneWithoutMembersInput
    member_setting?: member_settingCreateNestedOneWithoutMemberInput
    play_histories?: play_historyCreateNestedManyWithoutMemberInput
    reports?: reportCreateNestedManyWithoutMemberInput
    invitees?: memberCreateNestedManyWithoutInviterInput
    notifications?: member_notificationCreateNestedManyWithoutMemberInput
  }

  export type memberUncheckedCreateWithoutMember_tokensInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter_id?: string | null
    user_id: string
    member_setting?: member_settingUncheckedCreateNestedOneWithoutMemberInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMemberInput
    reports?: reportUncheckedCreateNestedManyWithoutMemberInput
    invitees?: memberUncheckedCreateNestedManyWithoutInviterInput
    notifications?: member_notificationUncheckedCreateNestedManyWithoutMemberInput
  }

  export type memberCreateOrConnectWithoutMember_tokensInput = {
    where: memberWhereUniqueInput
    create: XOR<memberCreateWithoutMember_tokensInput, memberUncheckedCreateWithoutMember_tokensInput>
  }

  export type memberUpsertWithoutMember_tokensInput = {
    update: XOR<memberUpdateWithoutMember_tokensInput, memberUncheckedUpdateWithoutMember_tokensInput>
    create: XOR<memberCreateWithoutMember_tokensInput, memberUncheckedCreateWithoutMember_tokensInput>
  }

  export type memberUpdateWithoutMember_tokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter?: memberUpdateOneWithoutInviteesNestedInput
    user?: userUpdateOneRequiredWithoutMembersNestedInput
    member_setting?: member_settingUpdateOneWithoutMemberNestedInput
    play_histories?: play_historyUpdateManyWithoutMemberNestedInput
    reports?: reportUpdateManyWithoutMemberNestedInput
    invitees?: memberUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUpdateManyWithoutMemberNestedInput
  }

  export type memberUncheckedUpdateWithoutMember_tokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    member_setting?: member_settingUncheckedUpdateOneWithoutMemberNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutMemberNestedInput
    reports?: reportUncheckedUpdateManyWithoutMemberNestedInput
    invitees?: memberUncheckedUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type memberCreateWithoutMember_settingInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter?: memberCreateNestedOneWithoutInviteesInput
    user: userCreateNestedOneWithoutMembersInput
    member_tokens?: member_tokenCreateNestedManyWithoutMemberInput
    play_histories?: play_historyCreateNestedManyWithoutMemberInput
    reports?: reportCreateNestedManyWithoutMemberInput
    invitees?: memberCreateNestedManyWithoutInviterInput
    notifications?: member_notificationCreateNestedManyWithoutMemberInput
  }

  export type memberUncheckedCreateWithoutMember_settingInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter_id?: string | null
    user_id: string
    member_tokens?: member_tokenUncheckedCreateNestedManyWithoutMemberInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMemberInput
    reports?: reportUncheckedCreateNestedManyWithoutMemberInput
    invitees?: memberUncheckedCreateNestedManyWithoutInviterInput
    notifications?: member_notificationUncheckedCreateNestedManyWithoutMemberInput
  }

  export type memberCreateOrConnectWithoutMember_settingInput = {
    where: memberWhereUniqueInput
    create: XOR<memberCreateWithoutMember_settingInput, memberUncheckedCreateWithoutMember_settingInput>
  }

  export type memberUpsertWithoutMember_settingInput = {
    update: XOR<memberUpdateWithoutMember_settingInput, memberUncheckedUpdateWithoutMember_settingInput>
    create: XOR<memberCreateWithoutMember_settingInput, memberUncheckedCreateWithoutMember_settingInput>
  }

  export type memberUpdateWithoutMember_settingInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter?: memberUpdateOneWithoutInviteesNestedInput
    user?: userUpdateOneRequiredWithoutMembersNestedInput
    member_tokens?: member_tokenUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUpdateManyWithoutMemberNestedInput
    reports?: reportUpdateManyWithoutMemberNestedInput
    invitees?: memberUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUpdateManyWithoutMemberNestedInput
  }

  export type memberUncheckedUpdateWithoutMember_settingInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    member_tokens?: member_tokenUncheckedUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutMemberNestedInput
    reports?: reportUncheckedUpdateManyWithoutMemberNestedInput
    invitees?: memberUncheckedUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type userCreateWithoutPermissionInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutPermissionInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutPermissionInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutPermissionInput, userUncheckedCreateWithoutPermissionInput>
  }

  export type userUpsertWithoutPermissionInput = {
    update: XOR<userUpdateWithoutPermissionInput, userUncheckedUpdateWithoutPermissionInput>
    create: XOR<userCreateWithoutPermissionInput, userUncheckedCreateWithoutPermissionInput>
  }

  export type userUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
  }

  export type memberCreateWithoutNotificationsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter?: memberCreateNestedOneWithoutInviteesInput
    user: userCreateNestedOneWithoutMembersInput
    member_setting?: member_settingCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenCreateNestedManyWithoutMemberInput
    play_histories?: play_historyCreateNestedManyWithoutMemberInput
    reports?: reportCreateNestedManyWithoutMemberInput
    invitees?: memberCreateNestedManyWithoutInviterInput
  }

  export type memberUncheckedCreateWithoutNotificationsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter_id?: string | null
    user_id: string
    member_setting?: member_settingUncheckedCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenUncheckedCreateNestedManyWithoutMemberInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMemberInput
    reports?: reportUncheckedCreateNestedManyWithoutMemberInput
    invitees?: memberUncheckedCreateNestedManyWithoutInviterInput
  }

  export type memberCreateOrConnectWithoutNotificationsInput = {
    where: memberWhereUniqueInput
    create: XOR<memberCreateWithoutNotificationsInput, memberUncheckedCreateWithoutNotificationsInput>
  }

  export type memberUpsertWithoutNotificationsInput = {
    update: XOR<memberUpdateWithoutNotificationsInput, memberUncheckedUpdateWithoutNotificationsInput>
    create: XOR<memberCreateWithoutNotificationsInput, memberUncheckedCreateWithoutNotificationsInput>
  }

  export type memberUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter?: memberUpdateOneWithoutInviteesNestedInput
    user?: userUpdateOneRequiredWithoutMembersNestedInput
    member_setting?: member_settingUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUpdateManyWithoutMemberNestedInput
    reports?: reportUpdateManyWithoutMemberNestedInput
    invitees?: memberUpdateManyWithoutInviterNestedInput
  }

  export type memberUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    member_setting?: member_settingUncheckedUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUncheckedUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutMemberNestedInput
    reports?: reportUncheckedUpdateManyWithoutMemberNestedInput
    invitees?: memberUncheckedUpdateManyWithoutInviterNestedInput
  }

  export type userCreateWithoutNotificationsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutNotificationsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutNotificationsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutNotificationsInput, userUncheckedCreateWithoutNotificationsInput>
  }

  export type userUpsertWithoutNotificationsInput = {
    update: XOR<userUpdateWithoutNotificationsInput, userUncheckedUpdateWithoutNotificationsInput>
    create: XOR<userCreateWithoutNotificationsInput, userUncheckedCreateWithoutNotificationsInput>
  }

  export type userUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type tvCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile: tv_profileCreateNestedOneWithoutTvsInput
    collection?: collectionCreateNestedOneWithoutTvsInput
    user: userCreateNestedOneWithoutTvInput
    seasons?: seasonCreateNestedManyWithoutTvInput
    episodes?: episodeCreateNestedManyWithoutTvInput
    play_histories?: play_historyCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutTvInput
  }

  export type tvUncheckedCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile_id: string
    collection_id?: string | null
    user_id: string
    seasons?: seasonUncheckedCreateNestedManyWithoutTvInput
    episodes?: episodeUncheckedCreateNestedManyWithoutTvInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutTvInput
  }

  export type tvCreateOrConnectWithoutReportsInput = {
    where: tvWhereUniqueInput
    create: XOR<tvCreateWithoutReportsInput, tvUncheckedCreateWithoutReportsInput>
  }

  export type seasonCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile: season_profileCreateNestedOneWithoutSeasonsInput
    collection?: collectionCreateNestedOneWithoutSeasonsInput
    tv: tvCreateNestedOneWithoutSeasonsInput
    user: userCreateNestedOneWithoutSeasonsInput
    parsed_season?: parsed_seasonCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyCreateNestedManyWithoutSeasonInput
    episodes?: episodeCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutSeasonInput
  }

  export type seasonUncheckedCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile_id: string
    collection_id?: string | null
    tv_id: string
    user_id: string
    parsed_season?: parsed_seasonUncheckedCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutSeasonInput
    episodes?: episodeUncheckedCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonCreateOrConnectWithoutReportsInput = {
    where: seasonWhereUniqueInput
    create: XOR<seasonCreateWithoutReportsInput, seasonUncheckedCreateWithoutReportsInput>
  }

  export type episodeCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile: episode_profileCreateNestedOneWithoutEpisodesInput
    tv: tvCreateNestedOneWithoutEpisodesInput
    season: seasonCreateNestedOneWithoutEpisodesInput
    user: userCreateNestedOneWithoutEpisodeInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleCreateNestedManyWithoutEpisodeInput
  }

  export type episodeUncheckedCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile_id: string
    tv_id: string
    season_id: string
    user_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type episodeCreateOrConnectWithoutReportsInput = {
    where: episodeWhereUniqueInput
    create: XOR<episodeCreateWithoutReportsInput, episodeUncheckedCreateWithoutReportsInput>
  }

  export type movieCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile: movie_profileCreateNestedOneWithoutMoviesInput
    user: userCreateNestedOneWithoutMovieInput
    collection?: collectionCreateNestedOneWithoutMoviesInput
    play_histories?: play_historyCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutMovieInput
    subtitles?: subtitleCreateNestedManyWithoutMovieInput
  }

  export type movieUncheckedCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile_id: string
    user_id: string
    collection_id?: string | null
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutMovieInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutMovieInput
  }

  export type movieCreateOrConnectWithoutReportsInput = {
    where: movieWhereUniqueInput
    create: XOR<movieCreateWithoutReportsInput, movieUncheckedCreateWithoutReportsInput>
  }

  export type memberCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter?: memberCreateNestedOneWithoutInviteesInput
    user: userCreateNestedOneWithoutMembersInput
    member_setting?: member_settingCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenCreateNestedManyWithoutMemberInput
    play_histories?: play_historyCreateNestedManyWithoutMemberInput
    invitees?: memberCreateNestedManyWithoutInviterInput
    notifications?: member_notificationCreateNestedManyWithoutMemberInput
  }

  export type memberUncheckedCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter_id?: string | null
    user_id: string
    member_setting?: member_settingUncheckedCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenUncheckedCreateNestedManyWithoutMemberInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMemberInput
    invitees?: memberUncheckedCreateNestedManyWithoutInviterInput
    notifications?: member_notificationUncheckedCreateNestedManyWithoutMemberInput
  }

  export type memberCreateOrConnectWithoutReportsInput = {
    where: memberWhereUniqueInput
    create: XOR<memberCreateWithoutReportsInput, memberUncheckedCreateWithoutReportsInput>
  }

  export type userCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutReportsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutReportsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutReportsInput, userUncheckedCreateWithoutReportsInput>
  }

  export type tvUpsertWithoutReportsInput = {
    update: XOR<tvUpdateWithoutReportsInput, tvUncheckedUpdateWithoutReportsInput>
    create: XOR<tvCreateWithoutReportsInput, tvUncheckedCreateWithoutReportsInput>
  }

  export type tvUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: tv_profileUpdateOneRequiredWithoutTvsNestedInput
    collection?: collectionUpdateOneWithoutTvsNestedInput
    user?: userUpdateOneRequiredWithoutTvNestedInput
    seasons?: seasonUpdateManyWithoutTvNestedInput
    episodes?: episodeUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutTvNestedInput
  }

  export type tvUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    seasons?: seasonUncheckedUpdateManyWithoutTvNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutTvNestedInput
  }

  export type seasonUpsertWithoutReportsInput = {
    update: XOR<seasonUpdateWithoutReportsInput, seasonUncheckedUpdateWithoutReportsInput>
    create: XOR<seasonCreateWithoutReportsInput, seasonUncheckedCreateWithoutReportsInput>
  }

  export type seasonUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile?: season_profileUpdateOneRequiredWithoutSeasonsNestedInput
    collection?: collectionUpdateOneWithoutSeasonsNestedInput
    tv?: tvUpdateOneRequiredWithoutSeasonsNestedInput
    user?: userUpdateOneRequiredWithoutSeasonsNestedInput
    parsed_season?: parsed_seasonUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_season?: parsed_seasonUncheckedUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type episodeUpsertWithoutReportsInput = {
    update: XOR<episodeUpdateWithoutReportsInput, episodeUncheckedUpdateWithoutReportsInput>
    create: XOR<episodeCreateWithoutReportsInput, episodeUncheckedCreateWithoutReportsInput>
  }

  export type episodeUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile?: episode_profileUpdateOneRequiredWithoutEpisodesNestedInput
    tv?: tvUpdateOneRequiredWithoutEpisodesNestedInput
    season?: seasonUpdateOneRequiredWithoutEpisodesNestedInput
    user?: userUpdateOneRequiredWithoutEpisodeNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    tv_id?: StringFieldUpdateOperationsInput | string
    season_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type movieUpsertWithoutReportsInput = {
    update: XOR<movieUpdateWithoutReportsInput, movieUncheckedUpdateWithoutReportsInput>
    create: XOR<movieCreateWithoutReportsInput, movieUncheckedCreateWithoutReportsInput>
  }

  export type movieUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: movie_profileUpdateOneRequiredWithoutMoviesNestedInput
    user?: userUpdateOneRequiredWithoutMovieNestedInput
    collection?: collectionUpdateOneWithoutMoviesNestedInput
    play_histories?: play_historyUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUpdateManyWithoutMovieNestedInput
  }

  export type movieUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    play_histories?: play_historyUncheckedUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type memberUpsertWithoutReportsInput = {
    update: XOR<memberUpdateWithoutReportsInput, memberUncheckedUpdateWithoutReportsInput>
    create: XOR<memberCreateWithoutReportsInput, memberUncheckedCreateWithoutReportsInput>
  }

  export type memberUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter?: memberUpdateOneWithoutInviteesNestedInput
    user?: userUpdateOneRequiredWithoutMembersNestedInput
    member_setting?: member_settingUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUpdateManyWithoutMemberNestedInput
    invitees?: memberUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUpdateManyWithoutMemberNestedInput
  }

  export type memberUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    member_setting?: member_settingUncheckedUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUncheckedUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutMemberNestedInput
    invitees?: memberUncheckedUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type userUpsertWithoutReportsInput = {
    update: XOR<userUpdateWithoutReportsInput, userUncheckedUpdateWithoutReportsInput>
    create: XOR<userCreateWithoutReportsInput, userUncheckedCreateWithoutReportsInput>
  }

  export type userUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutAccountsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutAccountsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutAccountsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutAccountsInput, userUncheckedCreateWithoutAccountsInput>
  }

  export type userUpsertWithoutAccountsInput = {
    update: XOR<userUpdateWithoutAccountsInput, userUncheckedUpdateWithoutAccountsInput>
    create: XOR<userCreateWithoutAccountsInput, userUncheckedCreateWithoutAccountsInput>
  }

  export type userUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutCredentialInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile?: profileCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutCredentialInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutCredentialInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutCredentialInput, userUncheckedCreateWithoutCredentialInput>
  }

  export type userUpsertWithoutCredentialInput = {
    update: XOR<userUpdateWithoutCredentialInput, userUncheckedUpdateWithoutCredentialInput>
    create: XOR<userCreateWithoutCredentialInput, userUncheckedCreateWithoutCredentialInput>
  }

  export type userUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutCredentialInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutProfileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    settings?: settingsCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutProfileInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    settings?: settingsUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutProfileInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
  }

  export type userUpsertWithoutProfileInput = {
    update: XOR<userUpdateWithoutProfileInput, userUncheckedUpdateWithoutProfileInput>
    create: XOR<userCreateWithoutProfileInput, userUncheckedCreateWithoutProfileInput>
  }

  export type userUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    settings?: settingsUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    settings?: settingsUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type userCreateWithoutSettingsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialCreateNestedOneWithoutUserInput
    profile?: profileCreateNestedOneWithoutUserInput
    accounts?: accountCreateNestedManyWithoutUserInput
    drives?: driveCreateNestedManyWithoutUserInput
    tv?: tvCreateNestedManyWithoutUserInput
    seasons?: seasonCreateNestedManyWithoutUserInput
    episode?: episodeCreateNestedManyWithoutUserInput
    movie?: movieCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvCreateNestedManyWithoutUserInput
    async_task?: async_taskCreateNestedManyWithoutUserInput
    files?: fileCreateNestedManyWithoutUserInput
    members?: memberCreateNestedManyWithoutUserInput
    shared_files?: shared_fileCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutUserInput
    notifications?: notificationCreateNestedManyWithoutUserInput
    outputs?: outputCreateNestedManyWithoutUserInput
    reports?: reportCreateNestedManyWithoutUserInput
    collections?: collectionCreateNestedManyWithoutUserInput
    subtitles?: subtitleCreateNestedManyWithoutUserInput
    permission?: permissionCreateNestedManyWithoutUserInput
  }

  export type userUncheckedCreateWithoutSettingsInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    credential?: credentialUncheckedCreateNestedOneWithoutUserInput
    profile?: profileUncheckedCreateNestedOneWithoutUserInput
    accounts?: accountUncheckedCreateNestedManyWithoutUserInput
    drives?: driveUncheckedCreateNestedManyWithoutUserInput
    tv?: tvUncheckedCreateNestedManyWithoutUserInput
    seasons?: seasonUncheckedCreateNestedManyWithoutUserInput
    episode?: episodeUncheckedCreateNestedManyWithoutUserInput
    movie?: movieUncheckedCreateNestedManyWithoutUserInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutUserInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutUserInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutUserInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutUserInput
    tv_need_complete?: incomplete_tvUncheckedCreateNestedManyWithoutUserInput
    async_task?: async_taskUncheckedCreateNestedManyWithoutUserInput
    files?: fileUncheckedCreateNestedManyWithoutUserInput
    members?: memberUncheckedCreateNestedManyWithoutUserInput
    shared_files?: shared_fileUncheckedCreateNestedManyWithoutUserInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutUserInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutUserInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutUserInput
    notifications?: notificationUncheckedCreateNestedManyWithoutUserInput
    outputs?: outputUncheckedCreateNestedManyWithoutUserInput
    reports?: reportUncheckedCreateNestedManyWithoutUserInput
    collections?: collectionUncheckedCreateNestedManyWithoutUserInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutUserInput
    permission?: permissionUncheckedCreateNestedManyWithoutUserInput
  }

  export type userCreateOrConnectWithoutSettingsInput = {
    where: userWhereUniqueInput
    create: XOR<userCreateWithoutSettingsInput, userUncheckedCreateWithoutSettingsInput>
  }

  export type userUpsertWithoutSettingsInput = {
    update: XOR<userUpdateWithoutSettingsInput, userUncheckedUpdateWithoutSettingsInput>
    create: XOR<userCreateWithoutSettingsInput, userUncheckedCreateWithoutSettingsInput>
  }

  export type userUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUpdateOneWithoutUserNestedInput
    profile?: profileUpdateOneWithoutUserNestedInput
    accounts?: accountUpdateManyWithoutUserNestedInput
    drives?: driveUpdateManyWithoutUserNestedInput
    tv?: tvUpdateManyWithoutUserNestedInput
    seasons?: seasonUpdateManyWithoutUserNestedInput
    episode?: episodeUpdateManyWithoutUserNestedInput
    movie?: movieUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUpdateManyWithoutUserNestedInput
    async_task?: async_taskUpdateManyWithoutUserNestedInput
    files?: fileUpdateManyWithoutUserNestedInput
    members?: memberUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutUserNestedInput
    notifications?: notificationUpdateManyWithoutUserNestedInput
    outputs?: outputUpdateManyWithoutUserNestedInput
    reports?: reportUpdateManyWithoutUserNestedInput
    collections?: collectionUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUpdateManyWithoutUserNestedInput
    permission?: permissionUpdateManyWithoutUserNestedInput
  }

  export type userUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    credential?: credentialUncheckedUpdateOneWithoutUserNestedInput
    profile?: profileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: accountUncheckedUpdateManyWithoutUserNestedInput
    drives?: driveUncheckedUpdateManyWithoutUserNestedInput
    tv?: tvUncheckedUpdateManyWithoutUserNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutUserNestedInput
    episode?: episodeUncheckedUpdateManyWithoutUserNestedInput
    movie?: movieUncheckedUpdateManyWithoutUserNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutUserNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutUserNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutUserNestedInput
    tv_need_complete?: incomplete_tvUncheckedUpdateManyWithoutUserNestedInput
    async_task?: async_taskUncheckedUpdateManyWithoutUserNestedInput
    files?: fileUncheckedUpdateManyWithoutUserNestedInput
    members?: memberUncheckedUpdateManyWithoutUserNestedInput
    shared_files?: shared_fileUncheckedUpdateManyWithoutUserNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutUserNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutUserNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutUserNestedInput
    notifications?: notificationUncheckedUpdateManyWithoutUserNestedInput
    outputs?: outputUncheckedUpdateManyWithoutUserNestedInput
    reports?: reportUncheckedUpdateManyWithoutUserNestedInput
    collections?: collectionUncheckedUpdateManyWithoutUserNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutUserNestedInput
    permission?: permissionUncheckedUpdateManyWithoutUserNestedInput
  }

  export type credentialCreateWithoutUserInput = {
    id: string
    password: string
    salt: string
    verified?: boolean
    email: string
  }

  export type credentialUncheckedCreateWithoutUserInput = {
    id: string
    password: string
    salt: string
    verified?: boolean
    email: string
  }

  export type credentialCreateOrConnectWithoutUserInput = {
    where: credentialWhereUniqueInput
    create: XOR<credentialCreateWithoutUserInput, credentialUncheckedCreateWithoutUserInput>
  }

  export type profileCreateWithoutUserInput = {
    id: string
    nickname?: string | null
    avatar?: string | null
  }

  export type profileUncheckedCreateWithoutUserInput = {
    id: string
    nickname?: string | null
    avatar?: string | null
  }

  export type profileCreateOrConnectWithoutUserInput = {
    where: profileWhereUniqueInput
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
  }

  export type settingsCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    detail?: string | null
  }

  export type settingsUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    detail?: string | null
  }

  export type settingsCreateOrConnectWithoutUserInput = {
    where: settingsWhereUniqueInput
    create: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
  }

  export type accountCreateWithoutUserInput = {
    id: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type accountUncheckedCreateWithoutUserInput = {
    id: string
    type: string
    provider: string
    provider_account_id: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type accountCreateOrConnectWithoutUserInput = {
    where: accountWhereUniqueInput
    create: XOR<accountCreateWithoutUserInput, accountUncheckedCreateWithoutUserInput>
  }

  export type driveCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token: drive_tokenCreateNestedOneWithoutDrivesInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inCreateNestedManyWithoutDriveInput
    files?: fileCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressCreateNestedManyWithoutDriveInput
    subtitles?: subtitleCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutDriveInput
  }

  export type driveUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    name: string
    remark?: string | null
    avatar: string
    profile: string
    total_size?: number | null
    used_size?: number | null
    invalid?: number | null
    latest_analysis?: Date | string | null
    root_folder_name?: string | null
    root_folder_id?: string | null
    drive_token_id: string
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutDriveInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutDriveInput
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutDriveInput
    drive_check_in?: drive_check_inUncheckedCreateNestedManyWithoutDriveInput
    files?: fileUncheckedCreateNestedManyWithoutDriveInput
    tmp_files?: tmp_fileUncheckedCreateNestedManyWithoutDriveInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutDriveInput
    shared_file_in_progress?: shared_file_in_progressUncheckedCreateNestedManyWithoutDriveInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutDriveInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutDriveInput
  }

  export type driveCreateOrConnectWithoutUserInput = {
    where: driveWhereUniqueInput
    create: XOR<driveCreateWithoutUserInput, driveUncheckedCreateWithoutUserInput>
  }

  export type tvCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile: tv_profileCreateNestedOneWithoutTvsInput
    collection?: collectionCreateNestedOneWithoutTvsInput
    seasons?: seasonCreateNestedManyWithoutTvInput
    episodes?: episodeCreateNestedManyWithoutTvInput
    play_histories?: play_historyCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvCreateNestedManyWithoutTvInput
    reports?: reportCreateNestedManyWithoutTvInput
  }

  export type tvUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    hidden?: number | null
    profile_id: string
    collection_id?: string | null
    seasons?: seasonUncheckedCreateNestedManyWithoutTvInput
    episodes?: episodeUncheckedCreateNestedManyWithoutTvInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutTvInput
    parsed_tvs?: parsed_tvUncheckedCreateNestedManyWithoutTvInput
    reports?: reportUncheckedCreateNestedManyWithoutTvInput
  }

  export type tvCreateOrConnectWithoutUserInput = {
    where: tvWhereUniqueInput
    create: XOR<tvCreateWithoutUserInput, tvUncheckedCreateWithoutUserInput>
  }

  export type seasonCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile: season_profileCreateNestedOneWithoutSeasonsInput
    collection?: collectionCreateNestedOneWithoutSeasonsInput
    tv: tvCreateNestedOneWithoutSeasonsInput
    parsed_season?: parsed_seasonCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyCreateNestedManyWithoutSeasonInput
    episodes?: episodeCreateNestedManyWithoutSeasonInput
    reports?: reportCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvCreateNestedManyWithoutSeasonInput
  }

  export type seasonUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_text: string
    season_number: number
    profile_id: string
    collection_id?: string | null
    tv_id: string
    parsed_season?: parsed_seasonUncheckedCreateNestedManyWithoutSeasonInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutSeasonInput
    episodes?: episodeUncheckedCreateNestedManyWithoutSeasonInput
    reports?: reportUncheckedCreateNestedManyWithoutSeasonInput
    sync_tasks?: bind_for_parsed_tvUncheckedCreateNestedManyWithoutSeasonInput
  }

  export type seasonCreateOrConnectWithoutUserInput = {
    where: seasonWhereUniqueInput
    create: XOR<seasonCreateWithoutUserInput, seasonUncheckedCreateWithoutUserInput>
  }

  export type episodeCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile: episode_profileCreateNestedOneWithoutEpisodesInput
    tv: tvCreateNestedOneWithoutEpisodesInput
    season: seasonCreateNestedOneWithoutEpisodesInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyCreateNestedManyWithoutEpisodeInput
    reports?: reportCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleCreateNestedManyWithoutEpisodeInput
  }

  export type episodeUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_text: string
    season_text: string
    episode_number: number
    profile_id: string
    tv_id: string
    season_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutEpisodeInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutEpisodeInput
    reports?: reportUncheckedCreateNestedManyWithoutEpisodeInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutEpisodeInput
  }

  export type episodeCreateOrConnectWithoutUserInput = {
    where: episodeWhereUniqueInput
    create: XOR<episodeCreateWithoutUserInput, episodeUncheckedCreateWithoutUserInput>
  }

  export type movieCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile: movie_profileCreateNestedOneWithoutMoviesInput
    collection?: collectionCreateNestedOneWithoutMoviesInput
    play_histories?: play_historyCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieCreateNestedManyWithoutMovieInput
    reports?: reportCreateNestedManyWithoutMovieInput
    subtitles?: subtitleCreateNestedManyWithoutMovieInput
  }

  export type movieUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    profile_id: string
    collection_id?: string | null
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMovieInput
    parsed_movies?: parsed_movieUncheckedCreateNestedManyWithoutMovieInput
    reports?: reportUncheckedCreateNestedManyWithoutMovieInput
    subtitles?: subtitleUncheckedCreateNestedManyWithoutMovieInput
  }

  export type movieCreateOrConnectWithoutUserInput = {
    where: movieWhereUniqueInput
    create: XOR<movieCreateWithoutUserInput, movieUncheckedCreateWithoutUserInput>
  }

  export type parsed_tvCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    tv?: tvCreateNestedOneWithoutParsed_tvsInput
    drive: driveCreateNestedOneWithoutParsed_tvsInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutParsed_tvInput
    parsed_seasons?: parsed_seasonCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name?: string | null
    original_name?: string | null
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_name?: string | null
    tmdb_id?: number | null
    tv_id?: string | null
    drive_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutParsed_tvInput
    parsed_seasons?: parsed_seasonUncheckedCreateNestedManyWithoutParsed_tvInput
  }

  export type parsed_tvCreateOrConnectWithoutUserInput = {
    where: parsed_tvWhereUniqueInput
    create: XOR<parsed_tvCreateWithoutUserInput, parsed_tvUncheckedCreateWithoutUserInput>
  }

  export type parsed_seasonCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    season?: seasonCreateNestedOneWithoutParsed_seasonInput
    parsed_tv: parsed_tvCreateNestedOneWithoutParsed_seasonsInput
    drive: driveCreateNestedOneWithoutParsed_seasonsInput
    parsed_episodes?: parsed_episodeCreateNestedManyWithoutParsed_seasonInput
  }

  export type parsed_seasonUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    season_number: string
    file_id?: string | null
    file_name?: string | null
    can_search?: number | null
    correct_season_number?: string | null
    season_id?: string | null
    parsed_tv_id: string
    drive_id: string
    parsed_episodes?: parsed_episodeUncheckedCreateNestedManyWithoutParsed_seasonInput
  }

  export type parsed_seasonCreateOrConnectWithoutUserInput = {
    where: parsed_seasonWhereUniqueInput
    create: XOR<parsed_seasonCreateWithoutUserInput, parsed_seasonUncheckedCreateWithoutUserInput>
  }

  export type parsed_episodeCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    episode?: episodeCreateNestedOneWithoutParsed_episodesInput
    parsed_tv: parsed_tvCreateNestedOneWithoutParsed_episodesInput
    parsed_season: parsed_seasonCreateNestedOneWithoutParsed_episodesInput
    drive: driveCreateNestedOneWithoutParsed_episodesInput
  }

  export type parsed_episodeUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_number: string
    season_number: string
    name: string
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    episode_id?: string | null
    parsed_tv_id: string
    parsed_season_id: string
    drive_id: string
  }

  export type parsed_episodeCreateOrConnectWithoutUserInput = {
    where: parsed_episodeWhereUniqueInput
    create: XOR<parsed_episodeCreateWithoutUserInput, parsed_episodeUncheckedCreateWithoutUserInput>
  }

  export type parsed_movieCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    original_name?: string | null
    correct_name?: string | null
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    movie?: movieCreateNestedOneWithoutParsed_moviesInput
    drive: driveCreateNestedOneWithoutParsed_moviesInput
  }

  export type parsed_movieUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    original_name?: string | null
    correct_name?: string | null
    file_id: string
    file_name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    can_search?: number | null
    movie_id?: string | null
    drive_id: string
  }

  export type parsed_movieCreateOrConnectWithoutUserInput = {
    where: parsed_movieWhereUniqueInput
    create: XOR<parsed_movieCreateWithoutUserInput, parsed_movieUncheckedCreateWithoutUserInput>
  }

  export type incomplete_tvCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_count?: number | null
    cur_count?: number | null
  }

  export type incomplete_tvUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    episode_count?: number | null
    cur_count?: number | null
  }

  export type incomplete_tvCreateOrConnectWithoutUserInput = {
    where: incomplete_tvWhereUniqueInput
    create: XOR<incomplete_tvCreateWithoutUserInput, incomplete_tvUncheckedCreateWithoutUserInput>
  }

  export type async_taskCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    desc?: string | null
    status?: number | null
    need_stop?: number | null
    error?: string | null
    output: outputCreateNestedOneWithoutAsync_taskInput
  }

  export type async_taskUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    type?: number | null
    desc?: string | null
    status?: number | null
    need_stop?: number | null
    error?: string | null
    output_id: string
  }

  export type async_taskCreateOrConnectWithoutUserInput = {
    where: async_taskWhereUniqueInput
    create: XOR<async_taskCreateWithoutUserInput, async_taskUncheckedCreateWithoutUserInput>
  }

  export type fileCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    drive: driveCreateNestedOneWithoutFilesInput
  }

  export type fileUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    parent_file_id: string
    parent_paths: string
    type: number
    size?: number | null
    drive_id: string
  }

  export type fileCreateOrConnectWithoutUserInput = {
    where: fileWhereUniqueInput
    create: XOR<fileCreateWithoutUserInput, fileUncheckedCreateWithoutUserInput>
  }

  export type memberCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter?: memberCreateNestedOneWithoutInviteesInput
    member_setting?: member_settingCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenCreateNestedManyWithoutMemberInput
    play_histories?: play_historyCreateNestedManyWithoutMemberInput
    reports?: reportCreateNestedManyWithoutMemberInput
    invitees?: memberCreateNestedManyWithoutInviterInput
    notifications?: member_notificationCreateNestedManyWithoutMemberInput
  }

  export type memberUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    email?: string | null
    name?: string | null
    avatar?: string | null
    remark: string
    permission?: string | null
    disabled?: number | null
    delete?: number | null
    inviter_id?: string | null
    member_setting?: member_settingUncheckedCreateNestedOneWithoutMemberInput
    member_tokens?: member_tokenUncheckedCreateNestedManyWithoutMemberInput
    play_histories?: play_historyUncheckedCreateNestedManyWithoutMemberInput
    reports?: reportUncheckedCreateNestedManyWithoutMemberInput
    invitees?: memberUncheckedCreateNestedManyWithoutInviterInput
    notifications?: member_notificationUncheckedCreateNestedManyWithoutMemberInput
  }

  export type memberCreateOrConnectWithoutUserInput = {
    where: memberWhereUniqueInput
    create: XOR<memberCreateWithoutUserInput, memberUncheckedCreateWithoutUserInput>
  }

  export type shared_fileCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title?: string | null
    url: string
  }

  export type shared_fileUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title?: string | null
    url: string
  }

  export type shared_fileCreateOrConnectWithoutUserInput = {
    where: shared_fileWhereUniqueInput
    create: XOR<shared_fileCreateWithoutUserInput, shared_fileUncheckedCreateWithoutUserInput>
  }

  export type shared_file_in_progressCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    drive: driveCreateNestedOneWithoutShared_file_in_progressInput
  }

  export type shared_file_in_progressUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    drive_id: string
  }

  export type shared_file_in_progressCreateOrConnectWithoutUserInput = {
    where: shared_file_in_progressWhereUniqueInput
    create: XOR<shared_file_in_progressCreateWithoutUserInput, shared_file_in_progressUncheckedCreateWithoutUserInput>
  }

  export type tmp_fileCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    type?: number | null
    parent_paths: string
    drive: driveCreateNestedOneWithoutTmp_filesInput
  }

  export type tmp_fileUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    name: string
    type?: number | null
    parent_paths: string
    drive_id: string
  }

  export type tmp_fileCreateOrConnectWithoutUserInput = {
    where: tmp_fileWhereUniqueInput
    create: XOR<tmp_fileCreateWithoutUserInput, tmp_fileUncheckedCreateWithoutUserInput>
  }

  export type bind_for_parsed_tvCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    file_id_link_resource: string
    file_name_link_resource: string
    in_production?: number | null
    invalid?: number | null
    season?: seasonCreateNestedOneWithoutSync_tasksInput
    drive: driveCreateNestedOneWithoutSync_tasksInput
  }

  export type bind_for_parsed_tvUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    url: string
    file_id: string
    name: string
    file_id_link_resource: string
    file_name_link_resource: string
    in_production?: number | null
    invalid?: number | null
    season_id?: string | null
    drive_id: string
  }

  export type bind_for_parsed_tvCreateOrConnectWithoutUserInput = {
    where: bind_for_parsed_tvWhereUniqueInput
    create: XOR<bind_for_parsed_tvCreateWithoutUserInput, bind_for_parsed_tvUncheckedCreateWithoutUserInput>
  }

  export type notificationCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    content?: string | null
    type?: number | null
    status?: number | null
    is_delete?: number | null
  }

  export type notificationUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    unique_id: string
    content?: string | null
    type?: number | null
    status?: number | null
    is_delete?: number | null
  }

  export type notificationCreateOrConnectWithoutUserInput = {
    where: notificationWhereUniqueInput
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type outputCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    lines?: output_lineCreateNestedManyWithoutOutputInput
    async_task?: async_taskCreateNestedOneWithoutOutputInput
  }

  export type outputUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    lines?: output_lineUncheckedCreateNestedManyWithoutOutputInput
    async_task?: async_taskUncheckedCreateNestedOneWithoutOutputInput
  }

  export type outputCreateOrConnectWithoutUserInput = {
    where: outputWhereUniqueInput
    create: XOR<outputCreateWithoutUserInput, outputUncheckedCreateWithoutUserInput>
  }

  export type reportCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv?: tvCreateNestedOneWithoutReportsInput
    season?: seasonCreateNestedOneWithoutReportsInput
    episode?: episodeCreateNestedOneWithoutReportsInput
    movie?: movieCreateNestedOneWithoutReportsInput
    member: memberCreateNestedOneWithoutReportsInput
  }

  export type reportUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    type: number
    data: string
    answer: string
    tv_id?: string | null
    season_id?: string | null
    episode_id?: string | null
    movie_id?: string | null
    member_id: string
  }

  export type reportCreateOrConnectWithoutUserInput = {
    where: reportWhereUniqueInput
    create: XOR<reportCreateWithoutUserInput, reportUncheckedCreateWithoutUserInput>
  }

  export type collectionCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
    desc?: string | null
    type?: number
    rules?: string | null
    sort?: number
    styles?: string | null
    tvs?: tvCreateNestedManyWithoutCollectionInput
    seasons?: seasonCreateNestedManyWithoutCollectionInput
    movies?: movieCreateNestedManyWithoutCollectionInput
  }

  export type collectionUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    title: string
    desc?: string | null
    type?: number
    rules?: string | null
    sort?: number
    styles?: string | null
    tvs?: tvUncheckedCreateNestedManyWithoutCollectionInput
    seasons?: seasonUncheckedCreateNestedManyWithoutCollectionInput
    movies?: movieUncheckedCreateNestedManyWithoutCollectionInput
  }

  export type collectionCreateOrConnectWithoutUserInput = {
    where: collectionWhereUniqueInput
    create: XOR<collectionCreateWithoutUserInput, collectionUncheckedCreateWithoutUserInput>
  }

  export type subtitleCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    language: string
    movie?: movieCreateNestedOneWithoutSubtitlesInput
    episode?: episodeCreateNestedOneWithoutSubtitlesInput
    drive: driveCreateNestedOneWithoutSubtitlesInput
  }

  export type subtitleUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    file_id: string
    name: string
    language: string
    movie_id?: string | null
    episode_id?: string | null
    drive_id: string
  }

  export type subtitleCreateOrConnectWithoutUserInput = {
    where: subtitleWhereUniqueInput
    create: XOR<subtitleCreateWithoutUserInput, subtitleUncheckedCreateWithoutUserInput>
  }

  export type permissionCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    desc: string
    code: string
  }

  export type permissionUncheckedCreateWithoutUserInput = {
    id: string
    created?: Date | string
    updated?: Date | string
    desc: string
    code: string
  }

  export type permissionCreateOrConnectWithoutUserInput = {
    where: permissionWhereUniqueInput
    create: XOR<permissionCreateWithoutUserInput, permissionUncheckedCreateWithoutUserInput>
  }

  export type credentialUpsertWithoutUserInput = {
    update: XOR<credentialUpdateWithoutUserInput, credentialUncheckedUpdateWithoutUserInput>
    create: XOR<credentialCreateWithoutUserInput, credentialUncheckedCreateWithoutUserInput>
  }

  export type credentialUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
  }

  export type credentialUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    salt?: StringFieldUpdateOperationsInput | string
    verified?: BoolFieldUpdateOperationsInput | boolean
    email?: StringFieldUpdateOperationsInput | string
  }

  export type profileUpsertWithoutUserInput = {
    update: XOR<profileUpdateWithoutUserInput, profileUncheckedUpdateWithoutUserInput>
    create: XOR<profileCreateWithoutUserInput, profileUncheckedCreateWithoutUserInput>
  }

  export type profileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type profileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    nickname?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type settingsUpsertWithoutUserInput = {
    update: XOR<settingsUpdateWithoutUserInput, settingsUncheckedUpdateWithoutUserInput>
    create: XOR<settingsCreateWithoutUserInput, settingsUncheckedCreateWithoutUserInput>
  }

  export type settingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type settingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    detail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accountUpsertWithWhereUniqueWithoutUserInput = {
    where: accountWhereUniqueInput
    update: XOR<accountUpdateWithoutUserInput, accountUncheckedUpdateWithoutUserInput>
    create: XOR<accountCreateWithoutUserInput, accountUncheckedCreateWithoutUserInput>
  }

  export type accountUpdateWithWhereUniqueWithoutUserInput = {
    where: accountWhereUniqueInput
    data: XOR<accountUpdateWithoutUserInput, accountUncheckedUpdateWithoutUserInput>
  }

  export type accountUpdateManyWithWhereWithoutUserInput = {
    where: accountScalarWhereInput
    data: XOR<accountUpdateManyMutationInput, accountUncheckedUpdateManyWithoutAccountsInput>
  }

  export type accountScalarWhereInput = {
    AND?: Enumerable<accountScalarWhereInput>
    OR?: Enumerable<accountScalarWhereInput>
    NOT?: Enumerable<accountScalarWhereInput>
    id?: StringFilter | string
    type?: StringFilter | string
    provider?: StringFilter | string
    provider_account_id?: StringFilter | string
    refresh_token?: StringNullableFilter | string | null
    access_token?: StringNullableFilter | string | null
    expires_at?: IntNullableFilter | number | null
    token_type?: StringNullableFilter | string | null
    scope?: StringNullableFilter | string | null
    id_token?: StringNullableFilter | string | null
    session_state?: StringNullableFilter | string | null
    user_id?: StringFilter | string
  }

  export type driveUpsertWithWhereUniqueWithoutUserInput = {
    where: driveWhereUniqueInput
    update: XOR<driveUpdateWithoutUserInput, driveUncheckedUpdateWithoutUserInput>
    create: XOR<driveCreateWithoutUserInput, driveUncheckedCreateWithoutUserInput>
  }

  export type driveUpdateWithWhereUniqueWithoutUserInput = {
    where: driveWhereUniqueInput
    data: XOR<driveUpdateWithoutUserInput, driveUncheckedUpdateWithoutUserInput>
  }

  export type driveUpdateManyWithWhereWithoutUserInput = {
    where: driveScalarWhereInput
    data: XOR<driveUpdateManyMutationInput, driveUncheckedUpdateManyWithoutDrivesInput>
  }

  export type tvUpsertWithWhereUniqueWithoutUserInput = {
    where: tvWhereUniqueInput
    update: XOR<tvUpdateWithoutUserInput, tvUncheckedUpdateWithoutUserInput>
    create: XOR<tvCreateWithoutUserInput, tvUncheckedCreateWithoutUserInput>
  }

  export type tvUpdateWithWhereUniqueWithoutUserInput = {
    where: tvWhereUniqueInput
    data: XOR<tvUpdateWithoutUserInput, tvUncheckedUpdateWithoutUserInput>
  }

  export type tvUpdateManyWithWhereWithoutUserInput = {
    where: tvScalarWhereInput
    data: XOR<tvUpdateManyMutationInput, tvUncheckedUpdateManyWithoutTvInput>
  }

  export type seasonUpsertWithWhereUniqueWithoutUserInput = {
    where: seasonWhereUniqueInput
    update: XOR<seasonUpdateWithoutUserInput, seasonUncheckedUpdateWithoutUserInput>
    create: XOR<seasonCreateWithoutUserInput, seasonUncheckedCreateWithoutUserInput>
  }

  export type seasonUpdateWithWhereUniqueWithoutUserInput = {
    where: seasonWhereUniqueInput
    data: XOR<seasonUpdateWithoutUserInput, seasonUncheckedUpdateWithoutUserInput>
  }

  export type seasonUpdateManyWithWhereWithoutUserInput = {
    where: seasonScalarWhereInput
    data: XOR<seasonUpdateManyMutationInput, seasonUncheckedUpdateManyWithoutSeasonsInput>
  }

  export type episodeUpsertWithWhereUniqueWithoutUserInput = {
    where: episodeWhereUniqueInput
    update: XOR<episodeUpdateWithoutUserInput, episodeUncheckedUpdateWithoutUserInput>
    create: XOR<episodeCreateWithoutUserInput, episodeUncheckedCreateWithoutUserInput>
  }

  export type episodeUpdateWithWhereUniqueWithoutUserInput = {
    where: episodeWhereUniqueInput
    data: XOR<episodeUpdateWithoutUserInput, episodeUncheckedUpdateWithoutUserInput>
  }

  export type episodeUpdateManyWithWhereWithoutUserInput = {
    where: episodeScalarWhereInput
    data: XOR<episodeUpdateManyMutationInput, episodeUncheckedUpdateManyWithoutEpisodeInput>
  }

  export type movieUpsertWithWhereUniqueWithoutUserInput = {
    where: movieWhereUniqueInput
    update: XOR<movieUpdateWithoutUserInput, movieUncheckedUpdateWithoutUserInput>
    create: XOR<movieCreateWithoutUserInput, movieUncheckedCreateWithoutUserInput>
  }

  export type movieUpdateWithWhereUniqueWithoutUserInput = {
    where: movieWhereUniqueInput
    data: XOR<movieUpdateWithoutUserInput, movieUncheckedUpdateWithoutUserInput>
  }

  export type movieUpdateManyWithWhereWithoutUserInput = {
    where: movieScalarWhereInput
    data: XOR<movieUpdateManyMutationInput, movieUncheckedUpdateManyWithoutMovieInput>
  }

  export type parsed_tvUpsertWithWhereUniqueWithoutUserInput = {
    where: parsed_tvWhereUniqueInput
    update: XOR<parsed_tvUpdateWithoutUserInput, parsed_tvUncheckedUpdateWithoutUserInput>
    create: XOR<parsed_tvCreateWithoutUserInput, parsed_tvUncheckedCreateWithoutUserInput>
  }

  export type parsed_tvUpdateWithWhereUniqueWithoutUserInput = {
    where: parsed_tvWhereUniqueInput
    data: XOR<parsed_tvUpdateWithoutUserInput, parsed_tvUncheckedUpdateWithoutUserInput>
  }

  export type parsed_tvUpdateManyWithWhereWithoutUserInput = {
    where: parsed_tvScalarWhereInput
    data: XOR<parsed_tvUpdateManyMutationInput, parsed_tvUncheckedUpdateManyWithoutParsed_tvsInput>
  }

  export type parsed_seasonUpsertWithWhereUniqueWithoutUserInput = {
    where: parsed_seasonWhereUniqueInput
    update: XOR<parsed_seasonUpdateWithoutUserInput, parsed_seasonUncheckedUpdateWithoutUserInput>
    create: XOR<parsed_seasonCreateWithoutUserInput, parsed_seasonUncheckedCreateWithoutUserInput>
  }

  export type parsed_seasonUpdateWithWhereUniqueWithoutUserInput = {
    where: parsed_seasonWhereUniqueInput
    data: XOR<parsed_seasonUpdateWithoutUserInput, parsed_seasonUncheckedUpdateWithoutUserInput>
  }

  export type parsed_seasonUpdateManyWithWhereWithoutUserInput = {
    where: parsed_seasonScalarWhereInput
    data: XOR<parsed_seasonUpdateManyMutationInput, parsed_seasonUncheckedUpdateManyWithoutParsed_seasonsInput>
  }

  export type parsed_episodeUpsertWithWhereUniqueWithoutUserInput = {
    where: parsed_episodeWhereUniqueInput
    update: XOR<parsed_episodeUpdateWithoutUserInput, parsed_episodeUncheckedUpdateWithoutUserInput>
    create: XOR<parsed_episodeCreateWithoutUserInput, parsed_episodeUncheckedCreateWithoutUserInput>
  }

  export type parsed_episodeUpdateWithWhereUniqueWithoutUserInput = {
    where: parsed_episodeWhereUniqueInput
    data: XOR<parsed_episodeUpdateWithoutUserInput, parsed_episodeUncheckedUpdateWithoutUserInput>
  }

  export type parsed_episodeUpdateManyWithWhereWithoutUserInput = {
    where: parsed_episodeScalarWhereInput
    data: XOR<parsed_episodeUpdateManyMutationInput, parsed_episodeUncheckedUpdateManyWithoutParsed_episodesInput>
  }

  export type parsed_movieUpsertWithWhereUniqueWithoutUserInput = {
    where: parsed_movieWhereUniqueInput
    update: XOR<parsed_movieUpdateWithoutUserInput, parsed_movieUncheckedUpdateWithoutUserInput>
    create: XOR<parsed_movieCreateWithoutUserInput, parsed_movieUncheckedCreateWithoutUserInput>
  }

  export type parsed_movieUpdateWithWhereUniqueWithoutUserInput = {
    where: parsed_movieWhereUniqueInput
    data: XOR<parsed_movieUpdateWithoutUserInput, parsed_movieUncheckedUpdateWithoutUserInput>
  }

  export type parsed_movieUpdateManyWithWhereWithoutUserInput = {
    where: parsed_movieScalarWhereInput
    data: XOR<parsed_movieUpdateManyMutationInput, parsed_movieUncheckedUpdateManyWithoutParsed_moviesInput>
  }

  export type incomplete_tvUpsertWithWhereUniqueWithoutUserInput = {
    where: incomplete_tvWhereUniqueInput
    update: XOR<incomplete_tvUpdateWithoutUserInput, incomplete_tvUncheckedUpdateWithoutUserInput>
    create: XOR<incomplete_tvCreateWithoutUserInput, incomplete_tvUncheckedCreateWithoutUserInput>
  }

  export type incomplete_tvUpdateWithWhereUniqueWithoutUserInput = {
    where: incomplete_tvWhereUniqueInput
    data: XOR<incomplete_tvUpdateWithoutUserInput, incomplete_tvUncheckedUpdateWithoutUserInput>
  }

  export type incomplete_tvUpdateManyWithWhereWithoutUserInput = {
    where: incomplete_tvScalarWhereInput
    data: XOR<incomplete_tvUpdateManyMutationInput, incomplete_tvUncheckedUpdateManyWithoutTv_need_completeInput>
  }

  export type incomplete_tvScalarWhereInput = {
    AND?: Enumerable<incomplete_tvScalarWhereInput>
    OR?: Enumerable<incomplete_tvScalarWhereInput>
    NOT?: Enumerable<incomplete_tvScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    episode_count?: FloatNullableFilter | number | null
    cur_count?: FloatNullableFilter | number | null
    user_id?: StringFilter | string
  }

  export type async_taskUpsertWithWhereUniqueWithoutUserInput = {
    where: async_taskWhereUniqueInput
    update: XOR<async_taskUpdateWithoutUserInput, async_taskUncheckedUpdateWithoutUserInput>
    create: XOR<async_taskCreateWithoutUserInput, async_taskUncheckedCreateWithoutUserInput>
  }

  export type async_taskUpdateWithWhereUniqueWithoutUserInput = {
    where: async_taskWhereUniqueInput
    data: XOR<async_taskUpdateWithoutUserInput, async_taskUncheckedUpdateWithoutUserInput>
  }

  export type async_taskUpdateManyWithWhereWithoutUserInput = {
    where: async_taskScalarWhereInput
    data: XOR<async_taskUpdateManyMutationInput, async_taskUncheckedUpdateManyWithoutAsync_taskInput>
  }

  export type async_taskScalarWhereInput = {
    AND?: Enumerable<async_taskScalarWhereInput>
    OR?: Enumerable<async_taskScalarWhereInput>
    NOT?: Enumerable<async_taskScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    type?: IntNullableFilter | number | null
    desc?: StringNullableFilter | string | null
    status?: IntNullableFilter | number | null
    need_stop?: IntNullableFilter | number | null
    error?: StringNullableFilter | string | null
    output_id?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type fileUpsertWithWhereUniqueWithoutUserInput = {
    where: fileWhereUniqueInput
    update: XOR<fileUpdateWithoutUserInput, fileUncheckedUpdateWithoutUserInput>
    create: XOR<fileCreateWithoutUserInput, fileUncheckedCreateWithoutUserInput>
  }

  export type fileUpdateWithWhereUniqueWithoutUserInput = {
    where: fileWhereUniqueInput
    data: XOR<fileUpdateWithoutUserInput, fileUncheckedUpdateWithoutUserInput>
  }

  export type fileUpdateManyWithWhereWithoutUserInput = {
    where: fileScalarWhereInput
    data: XOR<fileUpdateManyMutationInput, fileUncheckedUpdateManyWithoutFilesInput>
  }

  export type memberUpsertWithWhereUniqueWithoutUserInput = {
    where: memberWhereUniqueInput
    update: XOR<memberUpdateWithoutUserInput, memberUncheckedUpdateWithoutUserInput>
    create: XOR<memberCreateWithoutUserInput, memberUncheckedCreateWithoutUserInput>
  }

  export type memberUpdateWithWhereUniqueWithoutUserInput = {
    where: memberWhereUniqueInput
    data: XOR<memberUpdateWithoutUserInput, memberUncheckedUpdateWithoutUserInput>
  }

  export type memberUpdateManyWithWhereWithoutUserInput = {
    where: memberScalarWhereInput
    data: XOR<memberUpdateManyMutationInput, memberUncheckedUpdateManyWithoutMembersInput>
  }

  export type shared_fileUpsertWithWhereUniqueWithoutUserInput = {
    where: shared_fileWhereUniqueInput
    update: XOR<shared_fileUpdateWithoutUserInput, shared_fileUncheckedUpdateWithoutUserInput>
    create: XOR<shared_fileCreateWithoutUserInput, shared_fileUncheckedCreateWithoutUserInput>
  }

  export type shared_fileUpdateWithWhereUniqueWithoutUserInput = {
    where: shared_fileWhereUniqueInput
    data: XOR<shared_fileUpdateWithoutUserInput, shared_fileUncheckedUpdateWithoutUserInput>
  }

  export type shared_fileUpdateManyWithWhereWithoutUserInput = {
    where: shared_fileScalarWhereInput
    data: XOR<shared_fileUpdateManyMutationInput, shared_fileUncheckedUpdateManyWithoutShared_filesInput>
  }

  export type shared_fileScalarWhereInput = {
    AND?: Enumerable<shared_fileScalarWhereInput>
    OR?: Enumerable<shared_fileScalarWhereInput>
    NOT?: Enumerable<shared_fileScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    title?: StringNullableFilter | string | null
    url?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type shared_file_in_progressUpsertWithWhereUniqueWithoutUserInput = {
    where: shared_file_in_progressWhereUniqueInput
    update: XOR<shared_file_in_progressUpdateWithoutUserInput, shared_file_in_progressUncheckedUpdateWithoutUserInput>
    create: XOR<shared_file_in_progressCreateWithoutUserInput, shared_file_in_progressUncheckedCreateWithoutUserInput>
  }

  export type shared_file_in_progressUpdateWithWhereUniqueWithoutUserInput = {
    where: shared_file_in_progressWhereUniqueInput
    data: XOR<shared_file_in_progressUpdateWithoutUserInput, shared_file_in_progressUncheckedUpdateWithoutUserInput>
  }

  export type shared_file_in_progressUpdateManyWithWhereWithoutUserInput = {
    where: shared_file_in_progressScalarWhereInput
    data: XOR<shared_file_in_progressUpdateManyMutationInput, shared_file_in_progressUncheckedUpdateManyWithoutShared_file_in_progressInput>
  }

  export type tmp_fileUpsertWithWhereUniqueWithoutUserInput = {
    where: tmp_fileWhereUniqueInput
    update: XOR<tmp_fileUpdateWithoutUserInput, tmp_fileUncheckedUpdateWithoutUserInput>
    create: XOR<tmp_fileCreateWithoutUserInput, tmp_fileUncheckedCreateWithoutUserInput>
  }

  export type tmp_fileUpdateWithWhereUniqueWithoutUserInput = {
    where: tmp_fileWhereUniqueInput
    data: XOR<tmp_fileUpdateWithoutUserInput, tmp_fileUncheckedUpdateWithoutUserInput>
  }

  export type tmp_fileUpdateManyWithWhereWithoutUserInput = {
    where: tmp_fileScalarWhereInput
    data: XOR<tmp_fileUpdateManyMutationInput, tmp_fileUncheckedUpdateManyWithoutTmp_filesInput>
  }

  export type bind_for_parsed_tvUpsertWithWhereUniqueWithoutUserInput = {
    where: bind_for_parsed_tvWhereUniqueInput
    update: XOR<bind_for_parsed_tvUpdateWithoutUserInput, bind_for_parsed_tvUncheckedUpdateWithoutUserInput>
    create: XOR<bind_for_parsed_tvCreateWithoutUserInput, bind_for_parsed_tvUncheckedCreateWithoutUserInput>
  }

  export type bind_for_parsed_tvUpdateWithWhereUniqueWithoutUserInput = {
    where: bind_for_parsed_tvWhereUniqueInput
    data: XOR<bind_for_parsed_tvUpdateWithoutUserInput, bind_for_parsed_tvUncheckedUpdateWithoutUserInput>
  }

  export type bind_for_parsed_tvUpdateManyWithWhereWithoutUserInput = {
    where: bind_for_parsed_tvScalarWhereInput
    data: XOR<bind_for_parsed_tvUpdateManyMutationInput, bind_for_parsed_tvUncheckedUpdateManyWithoutSync_tasksInput>
  }

  export type notificationUpsertWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    update: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
    create: XOR<notificationCreateWithoutUserInput, notificationUncheckedCreateWithoutUserInput>
  }

  export type notificationUpdateWithWhereUniqueWithoutUserInput = {
    where: notificationWhereUniqueInput
    data: XOR<notificationUpdateWithoutUserInput, notificationUncheckedUpdateWithoutUserInput>
  }

  export type notificationUpdateManyWithWhereWithoutUserInput = {
    where: notificationScalarWhereInput
    data: XOR<notificationUpdateManyMutationInput, notificationUncheckedUpdateManyWithoutNotificationsInput>
  }

  export type notificationScalarWhereInput = {
    AND?: Enumerable<notificationScalarWhereInput>
    OR?: Enumerable<notificationScalarWhereInput>
    NOT?: Enumerable<notificationScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    unique_id?: StringFilter | string
    content?: StringNullableFilter | string | null
    type?: IntNullableFilter | number | null
    status?: IntNullableFilter | number | null
    is_delete?: IntNullableFilter | number | null
    user_id?: StringFilter | string
  }

  export type outputUpsertWithWhereUniqueWithoutUserInput = {
    where: outputWhereUniqueInput
    update: XOR<outputUpdateWithoutUserInput, outputUncheckedUpdateWithoutUserInput>
    create: XOR<outputCreateWithoutUserInput, outputUncheckedCreateWithoutUserInput>
  }

  export type outputUpdateWithWhereUniqueWithoutUserInput = {
    where: outputWhereUniqueInput
    data: XOR<outputUpdateWithoutUserInput, outputUncheckedUpdateWithoutUserInput>
  }

  export type outputUpdateManyWithWhereWithoutUserInput = {
    where: outputScalarWhereInput
    data: XOR<outputUpdateManyMutationInput, outputUncheckedUpdateManyWithoutOutputsInput>
  }

  export type outputScalarWhereInput = {
    AND?: Enumerable<outputScalarWhereInput>
    OR?: Enumerable<outputScalarWhereInput>
    NOT?: Enumerable<outputScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    user_id?: StringFilter | string
  }

  export type reportUpsertWithWhereUniqueWithoutUserInput = {
    where: reportWhereUniqueInput
    update: XOR<reportUpdateWithoutUserInput, reportUncheckedUpdateWithoutUserInput>
    create: XOR<reportCreateWithoutUserInput, reportUncheckedCreateWithoutUserInput>
  }

  export type reportUpdateWithWhereUniqueWithoutUserInput = {
    where: reportWhereUniqueInput
    data: XOR<reportUpdateWithoutUserInput, reportUncheckedUpdateWithoutUserInput>
  }

  export type reportUpdateManyWithWhereWithoutUserInput = {
    where: reportScalarWhereInput
    data: XOR<reportUpdateManyMutationInput, reportUncheckedUpdateManyWithoutReportsInput>
  }

  export type collectionUpsertWithWhereUniqueWithoutUserInput = {
    where: collectionWhereUniqueInput
    update: XOR<collectionUpdateWithoutUserInput, collectionUncheckedUpdateWithoutUserInput>
    create: XOR<collectionCreateWithoutUserInput, collectionUncheckedCreateWithoutUserInput>
  }

  export type collectionUpdateWithWhereUniqueWithoutUserInput = {
    where: collectionWhereUniqueInput
    data: XOR<collectionUpdateWithoutUserInput, collectionUncheckedUpdateWithoutUserInput>
  }

  export type collectionUpdateManyWithWhereWithoutUserInput = {
    where: collectionScalarWhereInput
    data: XOR<collectionUpdateManyMutationInput, collectionUncheckedUpdateManyWithoutCollectionsInput>
  }

  export type collectionScalarWhereInput = {
    AND?: Enumerable<collectionScalarWhereInput>
    OR?: Enumerable<collectionScalarWhereInput>
    NOT?: Enumerable<collectionScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    title?: StringFilter | string
    desc?: StringNullableFilter | string | null
    type?: IntFilter | number
    rules?: StringNullableFilter | string | null
    sort?: IntFilter | number
    styles?: StringNullableFilter | string | null
    user_id?: StringFilter | string
  }

  export type subtitleUpsertWithWhereUniqueWithoutUserInput = {
    where: subtitleWhereUniqueInput
    update: XOR<subtitleUpdateWithoutUserInput, subtitleUncheckedUpdateWithoutUserInput>
    create: XOR<subtitleCreateWithoutUserInput, subtitleUncheckedCreateWithoutUserInput>
  }

  export type subtitleUpdateWithWhereUniqueWithoutUserInput = {
    where: subtitleWhereUniqueInput
    data: XOR<subtitleUpdateWithoutUserInput, subtitleUncheckedUpdateWithoutUserInput>
  }

  export type subtitleUpdateManyWithWhereWithoutUserInput = {
    where: subtitleScalarWhereInput
    data: XOR<subtitleUpdateManyMutationInput, subtitleUncheckedUpdateManyWithoutSubtitlesInput>
  }

  export type permissionUpsertWithWhereUniqueWithoutUserInput = {
    where: permissionWhereUniqueInput
    update: XOR<permissionUpdateWithoutUserInput, permissionUncheckedUpdateWithoutUserInput>
    create: XOR<permissionCreateWithoutUserInput, permissionUncheckedCreateWithoutUserInput>
  }

  export type permissionUpdateWithWhereUniqueWithoutUserInput = {
    where: permissionWhereUniqueInput
    data: XOR<permissionUpdateWithoutUserInput, permissionUncheckedUpdateWithoutUserInput>
  }

  export type permissionUpdateManyWithWhereWithoutUserInput = {
    where: permissionScalarWhereInput
    data: XOR<permissionUpdateManyMutationInput, permissionUncheckedUpdateManyWithoutPermissionInput>
  }

  export type permissionScalarWhereInput = {
    AND?: Enumerable<permissionScalarWhereInput>
    OR?: Enumerable<permissionScalarWhereInput>
    NOT?: Enumerable<permissionScalarWhereInput>
    id?: StringFilter | string
    created?: DateTimeFilter | Date | string
    updated?: DateTimeFilter | Date | string
    desc?: StringFilter | string
    code?: StringFilter | string
    user_id?: StringFilter | string
  }

  export type parsed_tvUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv?: tvUpdateOneWithoutParsed_tvsNestedInput
    user?: userUpdateOneRequiredWithoutParsed_tvsNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutParsed_tvNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutParsed_tvNestedInput
  }

  export type parsed_tvUncheckedUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutParsed_tvNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutParsed_tvNestedInput
  }

  export type parsed_tvUncheckedUpdateManyWithoutParsed_tvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_seasonUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season?: seasonUpdateOneWithoutParsed_seasonNestedInput
    parsed_tv?: parsed_tvUpdateOneRequiredWithoutParsed_seasonsNestedInput
    user?: userUpdateOneRequiredWithoutParsed_seasonsNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutParsed_seasonNestedInput
  }

  export type parsed_seasonUncheckedUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutParsed_seasonNestedInput
  }

  export type parsed_seasonUncheckedUpdateManyWithoutParsed_seasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_episodeUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode?: episodeUpdateOneWithoutParsed_episodesNestedInput
    parsed_tv?: parsed_tvUpdateOneRequiredWithoutParsed_episodesNestedInput
    parsed_season?: parsed_seasonUpdateOneRequiredWithoutParsed_episodesNestedInput
    user?: userUpdateOneRequiredWithoutParsed_episodesNestedInput
  }

  export type parsed_episodeUncheckedUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    parsed_season_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_episodeUncheckedUpdateManyWithoutParsed_episodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    parsed_season_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type drive_check_inUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    checked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type drive_check_inUncheckedUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    checked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type drive_check_inUncheckedUpdateManyWithoutDrive_check_inInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    checked_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type fileUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    user?: userUpdateOneRequiredWithoutFilesNestedInput
  }

  export type fileUncheckedUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type fileUncheckedUpdateManyWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type tmp_fileUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableFloatFieldUpdateOperationsInput | number | null
    parent_paths?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutTmp_filesNestedInput
  }

  export type tmp_fileUncheckedUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableFloatFieldUpdateOperationsInput | number | null
    parent_paths?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type tmp_fileUncheckedUpdateManyWithoutTmp_filesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableFloatFieldUpdateOperationsInput | number | null
    parent_paths?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_movieUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: movieUpdateOneWithoutParsed_moviesNestedInput
    user?: userUpdateOneRequiredWithoutParsed_moviesNestedInput
  }

  export type parsed_movieUncheckedUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_movieUncheckedUpdateManyWithoutParsed_moviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type shared_file_in_progressUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user?: userUpdateOneRequiredWithoutShared_file_in_progressNestedInput
  }

  export type shared_file_in_progressUncheckedUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type shared_file_in_progressUncheckedUpdateManyWithoutShared_file_in_progressInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type subtitleUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    movie?: movieUpdateOneWithoutSubtitlesNestedInput
    episode?: episodeUpdateOneWithoutSubtitlesNestedInput
    user?: userUpdateOneRequiredWithoutSubtitlesNestedInput
  }

  export type subtitleUncheckedUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type subtitleUncheckedUpdateManyWithoutSubtitlesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type bind_for_parsed_tvUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id_link_resource?: StringFieldUpdateOperationsInput | string
    file_name_link_resource?: StringFieldUpdateOperationsInput | string
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    season?: seasonUpdateOneWithoutSync_tasksNestedInput
    user?: userUpdateOneRequiredWithoutSync_tasksNestedInput
  }

  export type bind_for_parsed_tvUncheckedUpdateWithoutDriveInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id_link_resource?: StringFieldUpdateOperationsInput | string
    file_name_link_resource?: StringFieldUpdateOperationsInput | string
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type bind_for_parsed_tvUncheckedUpdateManyWithoutSync_tasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id_link_resource?: StringFieldUpdateOperationsInput | string
    file_name_link_resource?: StringFieldUpdateOperationsInput | string
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type driveUpdateWithoutDrive_tokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    user?: userUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutDrive_tokenInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateManyWithoutDrivesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type tvUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    collection?: collectionUpdateOneWithoutTvsNestedInput
    user?: userUpdateOneRequiredWithoutTvNestedInput
    seasons?: seasonUpdateManyWithoutTvNestedInput
    episodes?: episodeUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutTvNestedInput
    reports?: reportUpdateManyWithoutTvNestedInput
  }

  export type tvUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    seasons?: seasonUncheckedUpdateManyWithoutTvNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutTvNestedInput
    reports?: reportUncheckedUpdateManyWithoutTvNestedInput
  }

  export type tvUncheckedUpdateManyWithoutTvsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type tv_profile_quickUpdateWithoutTv_profileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type tv_profile_quickUncheckedUpdateWithoutTv_profileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type tv_profile_quickUncheckedUpdateManyWithoutSnapshotsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
  }

  export type seasonUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    collection?: collectionUpdateOneWithoutSeasonsNestedInput
    tv?: tvUpdateOneRequiredWithoutSeasonsNestedInput
    user?: userUpdateOneRequiredWithoutSeasonsNestedInput
    parsed_season?: parsed_seasonUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUpdateManyWithoutSeasonNestedInput
    reports?: reportUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_season?: parsed_seasonUncheckedUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutSeasonNestedInput
    reports?: reportUncheckedUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUncheckedUpdateManyWithoutSeasonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type episodeUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    tv?: tvUpdateOneRequiredWithoutEpisodesNestedInput
    season?: seasonUpdateOneRequiredWithoutEpisodesNestedInput
    user?: userUpdateOneRequiredWithoutEpisodeNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUpdateManyWithoutEpisodeNestedInput
    reports?: reportUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    tv_id?: StringFieldUpdateOperationsInput | string
    season_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutEpisodeNestedInput
    reports?: reportUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUncheckedUpdateManyWithoutEpisodesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    tv_id?: StringFieldUpdateOperationsInput | string
    season_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type movieUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: userUpdateOneRequiredWithoutMovieNestedInput
    collection?: collectionUpdateOneWithoutMoviesNestedInput
    play_histories?: play_historyUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutMovieNestedInput
    reports?: reportUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUpdateManyWithoutMovieNestedInput
  }

  export type movieUncheckedUpdateWithoutProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    play_histories?: play_historyUncheckedUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutMovieNestedInput
    reports?: reportUncheckedUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type movieUncheckedUpdateManyWithoutMoviesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    user_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parsed_episodeUpdateWithoutParsed_tvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode?: episodeUpdateOneWithoutParsed_episodesNestedInput
    parsed_season?: parsed_seasonUpdateOneRequiredWithoutParsed_episodesNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_episodesNestedInput
    user?: userUpdateOneRequiredWithoutParsed_episodesNestedInput
  }

  export type parsed_episodeUncheckedUpdateWithoutParsed_tvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_season_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_seasonUpdateWithoutParsed_tvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season?: seasonUpdateOneWithoutParsed_seasonNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_seasonsNestedInput
    user?: userUpdateOneRequiredWithoutParsed_seasonsNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutParsed_seasonNestedInput
  }

  export type parsed_seasonUncheckedUpdateWithoutParsed_tvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutParsed_seasonNestedInput
  }

  export type parsed_episodeUpdateWithoutParsed_seasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode?: episodeUpdateOneWithoutParsed_episodesNestedInput
    parsed_tv?: parsed_tvUpdateOneRequiredWithoutParsed_episodesNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_episodesNestedInput
    user?: userUpdateOneRequiredWithoutParsed_episodesNestedInput
  }

  export type parsed_episodeUncheckedUpdateWithoutParsed_seasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type seasonUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile?: season_profileUpdateOneRequiredWithoutSeasonsNestedInput
    collection?: collectionUpdateOneWithoutSeasonsNestedInput
    user?: userUpdateOneRequiredWithoutSeasonsNestedInput
    parsed_season?: parsed_seasonUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUpdateManyWithoutSeasonNestedInput
    reports?: reportUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUncheckedUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_season?: parsed_seasonUncheckedUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutSeasonNestedInput
    reports?: reportUncheckedUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type episodeUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile?: episode_profileUpdateOneRequiredWithoutEpisodesNestedInput
    season?: seasonUpdateOneRequiredWithoutEpisodesNestedInput
    user?: userUpdateOneRequiredWithoutEpisodeNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUpdateManyWithoutEpisodeNestedInput
    reports?: reportUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUncheckedUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    season_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutEpisodeNestedInput
    reports?: reportUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type play_historyUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    season?: seasonUpdateOneWithoutPlay_historiesNestedInput
    episode?: episodeUpdateOneWithoutPlay_historiesNestedInput
    movie?: movieUpdateOneWithoutPlay_historiesNestedInput
    member?: memberUpdateOneRequiredWithoutPlay_historiesNestedInput
  }

  export type play_historyUncheckedUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type play_historyUncheckedUpdateManyWithoutPlay_historiesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_tvUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    drive?: driveUpdateOneRequiredWithoutParsed_tvsNestedInput
    user?: userUpdateOneRequiredWithoutParsed_tvsNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutParsed_tvNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutParsed_tvNestedInput
  }

  export type parsed_tvUncheckedUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutParsed_tvNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutParsed_tvNestedInput
  }

  export type reportUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    season?: seasonUpdateOneWithoutReportsNestedInput
    episode?: episodeUpdateOneWithoutReportsNestedInput
    movie?: movieUpdateOneWithoutReportsNestedInput
    member?: memberUpdateOneRequiredWithoutReportsNestedInput
    user?: userUpdateOneRequiredWithoutReportsNestedInput
  }

  export type reportUncheckedUpdateWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type reportUncheckedUpdateManyWithoutReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_seasonUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv?: parsed_tvUpdateOneRequiredWithoutParsed_seasonsNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_seasonsNestedInput
    user?: userUpdateOneRequiredWithoutParsed_seasonsNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutParsed_seasonNestedInput
  }

  export type parsed_seasonUncheckedUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutParsed_seasonNestedInput
  }

  export type parsed_seasonUncheckedUpdateManyWithoutParsed_seasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type play_historyUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv?: tvUpdateOneWithoutPlay_historiesNestedInput
    episode?: episodeUpdateOneWithoutPlay_historiesNestedInput
    movie?: movieUpdateOneWithoutPlay_historiesNestedInput
    member?: memberUpdateOneRequiredWithoutPlay_historiesNestedInput
  }

  export type play_historyUncheckedUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type episodeUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile?: episode_profileUpdateOneRequiredWithoutEpisodesNestedInput
    tv?: tvUpdateOneRequiredWithoutEpisodesNestedInput
    user?: userUpdateOneRequiredWithoutEpisodeNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUpdateManyWithoutEpisodeNestedInput
    reports?: reportUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUncheckedUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutEpisodeNestedInput
    reports?: reportUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type reportUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv?: tvUpdateOneWithoutReportsNestedInput
    episode?: episodeUpdateOneWithoutReportsNestedInput
    movie?: movieUpdateOneWithoutReportsNestedInput
    member?: memberUpdateOneRequiredWithoutReportsNestedInput
    user?: userUpdateOneRequiredWithoutReportsNestedInput
  }

  export type reportUncheckedUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type bind_for_parsed_tvUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id_link_resource?: StringFieldUpdateOperationsInput | string
    file_name_link_resource?: StringFieldUpdateOperationsInput | string
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    drive?: driveUpdateOneRequiredWithoutSync_tasksNestedInput
    user?: userUpdateOneRequiredWithoutSync_tasksNestedInput
  }

  export type bind_for_parsed_tvUncheckedUpdateWithoutSeasonInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id_link_resource?: StringFieldUpdateOperationsInput | string
    file_name_link_resource?: StringFieldUpdateOperationsInput | string
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_episodeUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    parsed_tv?: parsed_tvUpdateOneRequiredWithoutParsed_episodesNestedInput
    parsed_season?: parsed_seasonUpdateOneRequiredWithoutParsed_episodesNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_episodesNestedInput
    user?: userUpdateOneRequiredWithoutParsed_episodesNestedInput
  }

  export type parsed_episodeUncheckedUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    parsed_season_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type play_historyUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv?: tvUpdateOneWithoutPlay_historiesNestedInput
    season?: seasonUpdateOneWithoutPlay_historiesNestedInput
    movie?: movieUpdateOneWithoutPlay_historiesNestedInput
    member?: memberUpdateOneRequiredWithoutPlay_historiesNestedInput
  }

  export type play_historyUncheckedUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type reportUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv?: tvUpdateOneWithoutReportsNestedInput
    season?: seasonUpdateOneWithoutReportsNestedInput
    movie?: movieUpdateOneWithoutReportsNestedInput
    member?: memberUpdateOneRequiredWithoutReportsNestedInput
    user?: userUpdateOneRequiredWithoutReportsNestedInput
  }

  export type reportUncheckedUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type subtitleUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    movie?: movieUpdateOneWithoutSubtitlesNestedInput
    drive?: driveUpdateOneRequiredWithoutSubtitlesNestedInput
    user?: userUpdateOneRequiredWithoutSubtitlesNestedInput
  }

  export type subtitleUncheckedUpdateWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type play_historyUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv?: tvUpdateOneWithoutPlay_historiesNestedInput
    season?: seasonUpdateOneWithoutPlay_historiesNestedInput
    episode?: episodeUpdateOneWithoutPlay_historiesNestedInput
    member?: memberUpdateOneRequiredWithoutPlay_historiesNestedInput
  }

  export type play_historyUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_movieUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    drive?: driveUpdateOneRequiredWithoutParsed_moviesNestedInput
    user?: userUpdateOneRequiredWithoutParsed_moviesNestedInput
  }

  export type parsed_movieUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type reportUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv?: tvUpdateOneWithoutReportsNestedInput
    season?: seasonUpdateOneWithoutReportsNestedInput
    episode?: episodeUpdateOneWithoutReportsNestedInput
    member?: memberUpdateOneRequiredWithoutReportsNestedInput
    user?: userUpdateOneRequiredWithoutReportsNestedInput
  }

  export type reportUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type subtitleUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    episode?: episodeUpdateOneWithoutSubtitlesNestedInput
    drive?: driveUpdateOneRequiredWithoutSubtitlesNestedInput
    user?: userUpdateOneRequiredWithoutSubtitlesNestedInput
  }

  export type subtitleUncheckedUpdateWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type tvUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: tv_profileUpdateOneRequiredWithoutTvsNestedInput
    user?: userUpdateOneRequiredWithoutTvNestedInput
    seasons?: seasonUpdateManyWithoutTvNestedInput
    episodes?: episodeUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutTvNestedInput
    reports?: reportUpdateManyWithoutTvNestedInput
  }

  export type tvUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    seasons?: seasonUncheckedUpdateManyWithoutTvNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutTvNestedInput
    reports?: reportUncheckedUpdateManyWithoutTvNestedInput
  }

  export type seasonUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile?: season_profileUpdateOneRequiredWithoutSeasonsNestedInput
    tv?: tvUpdateOneRequiredWithoutSeasonsNestedInput
    user?: userUpdateOneRequiredWithoutSeasonsNestedInput
    parsed_season?: parsed_seasonUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUpdateManyWithoutSeasonNestedInput
    reports?: reportUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    tv_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    parsed_season?: parsed_seasonUncheckedUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutSeasonNestedInput
    reports?: reportUncheckedUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type movieUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: movie_profileUpdateOneRequiredWithoutMoviesNestedInput
    user?: userUpdateOneRequiredWithoutMovieNestedInput
    play_histories?: play_historyUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutMovieNestedInput
    reports?: reportUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUpdateManyWithoutMovieNestedInput
  }

  export type movieUncheckedUpdateWithoutCollectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    play_histories?: play_historyUncheckedUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutMovieNestedInput
    reports?: reportUncheckedUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type output_lineUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type output_lineUncheckedUpdateWithoutOutputInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type output_lineUncheckedUpdateManyWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    content?: StringFieldUpdateOperationsInput | string
  }

  export type member_tokenUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    used?: NullableFloatFieldUpdateOperationsInput | number | null
    expired_at?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type member_tokenUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    used?: NullableFloatFieldUpdateOperationsInput | number | null
    expired_at?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type member_tokenUncheckedUpdateManyWithoutMember_tokensInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    token?: StringFieldUpdateOperationsInput | string
    used?: NullableFloatFieldUpdateOperationsInput | number | null
    expired_at?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type play_historyUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv?: tvUpdateOneWithoutPlay_historiesNestedInput
    season?: seasonUpdateOneWithoutPlay_historiesNestedInput
    episode?: episodeUpdateOneWithoutPlay_historiesNestedInput
    movie?: movieUpdateOneWithoutPlay_historiesNestedInput
  }

  export type play_historyUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    duration?: NullableFloatFieldUpdateOperationsInput | number | null
    current_time?: NullableFloatFieldUpdateOperationsInput | number | null
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type reportUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv?: tvUpdateOneWithoutReportsNestedInput
    season?: seasonUpdateOneWithoutReportsNestedInput
    episode?: episodeUpdateOneWithoutReportsNestedInput
    movie?: movieUpdateOneWithoutReportsNestedInput
    user?: userUpdateOneRequiredWithoutReportsNestedInput
  }

  export type reportUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type memberUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    user?: userUpdateOneRequiredWithoutMembersNestedInput
    member_setting?: member_settingUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUpdateManyWithoutMemberNestedInput
    reports?: reportUpdateManyWithoutMemberNestedInput
    invitees?: memberUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUpdateManyWithoutMemberNestedInput
  }

  export type memberUncheckedUpdateWithoutInviterInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
    member_setting?: member_settingUncheckedUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUncheckedUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutMemberNestedInput
    reports?: reportUncheckedUpdateManyWithoutMemberNestedInput
    invitees?: memberUncheckedUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type memberUncheckedUpdateManyWithoutInviteesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    user_id?: StringFieldUpdateOperationsInput | string
  }

  export type member_notificationUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type member_notificationUncheckedUpdateWithoutMemberInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type member_notificationUncheckedUpdateManyWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type accountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type accountUncheckedUpdateManyWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    provider_account_id?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type driveUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token?: drive_tokenUpdateOneRequiredWithoutDrivesNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUpdateManyWithoutDriveNestedInput
    files?: fileUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutDriveNestedInput
  }

  export type driveUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    name?: StringFieldUpdateOperationsInput | string
    remark?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: StringFieldUpdateOperationsInput | string
    profile?: StringFieldUpdateOperationsInput | string
    total_size?: NullableFloatFieldUpdateOperationsInput | number | null
    used_size?: NullableFloatFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    latest_analysis?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    root_folder_name?: NullableStringFieldUpdateOperationsInput | string | null
    root_folder_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_token_id?: StringFieldUpdateOperationsInput | string
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutDriveNestedInput
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutDriveNestedInput
    drive_check_in?: drive_check_inUncheckedUpdateManyWithoutDriveNestedInput
    files?: fileUncheckedUpdateManyWithoutDriveNestedInput
    tmp_files?: tmp_fileUncheckedUpdateManyWithoutDriveNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutDriveNestedInput
    shared_file_in_progress?: shared_file_in_progressUncheckedUpdateManyWithoutDriveNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutDriveNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutDriveNestedInput
  }

  export type tvUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile?: tv_profileUpdateOneRequiredWithoutTvsNestedInput
    collection?: collectionUpdateOneWithoutTvsNestedInput
    seasons?: seasonUpdateManyWithoutTvNestedInput
    episodes?: episodeUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUpdateManyWithoutTvNestedInput
    reports?: reportUpdateManyWithoutTvNestedInput
  }

  export type tvUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    seasons?: seasonUncheckedUpdateManyWithoutTvNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutTvNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutTvNestedInput
    parsed_tvs?: parsed_tvUncheckedUpdateManyWithoutTvNestedInput
    reports?: reportUncheckedUpdateManyWithoutTvNestedInput
  }

  export type tvUncheckedUpdateManyWithoutTvInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    hidden?: NullableIntFieldUpdateOperationsInput | number | null
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type seasonUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile?: season_profileUpdateOneRequiredWithoutSeasonsNestedInput
    collection?: collectionUpdateOneWithoutSeasonsNestedInput
    tv?: tvUpdateOneRequiredWithoutSeasonsNestedInput
    parsed_season?: parsed_seasonUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUpdateManyWithoutSeasonNestedInput
    reports?: reportUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUpdateManyWithoutSeasonNestedInput
  }

  export type seasonUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_text?: StringFieldUpdateOperationsInput | string
    season_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    tv_id?: StringFieldUpdateOperationsInput | string
    parsed_season?: parsed_seasonUncheckedUpdateManyWithoutSeasonNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutSeasonNestedInput
    episodes?: episodeUncheckedUpdateManyWithoutSeasonNestedInput
    reports?: reportUncheckedUpdateManyWithoutSeasonNestedInput
    sync_tasks?: bind_for_parsed_tvUncheckedUpdateManyWithoutSeasonNestedInput
  }

  export type episodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile?: episode_profileUpdateOneRequiredWithoutEpisodesNestedInput
    tv?: tvUpdateOneRequiredWithoutEpisodesNestedInput
    season?: seasonUpdateOneRequiredWithoutEpisodesNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUpdateManyWithoutEpisodeNestedInput
    reports?: reportUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    tv_id?: StringFieldUpdateOperationsInput | string
    season_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutEpisodeNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutEpisodeNestedInput
    reports?: reportUncheckedUpdateManyWithoutEpisodeNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutEpisodeNestedInput
  }

  export type episodeUncheckedUpdateManyWithoutEpisodeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_text?: StringFieldUpdateOperationsInput | string
    season_text?: StringFieldUpdateOperationsInput | string
    episode_number?: IntFieldUpdateOperationsInput | number
    profile_id?: StringFieldUpdateOperationsInput | string
    tv_id?: StringFieldUpdateOperationsInput | string
    season_id?: StringFieldUpdateOperationsInput | string
  }

  export type movieUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile?: movie_profileUpdateOneRequiredWithoutMoviesNestedInput
    collection?: collectionUpdateOneWithoutMoviesNestedInput
    play_histories?: play_historyUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUpdateManyWithoutMovieNestedInput
    reports?: reportUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUpdateManyWithoutMovieNestedInput
  }

  export type movieUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
    play_histories?: play_historyUncheckedUpdateManyWithoutMovieNestedInput
    parsed_movies?: parsed_movieUncheckedUpdateManyWithoutMovieNestedInput
    reports?: reportUncheckedUpdateManyWithoutMovieNestedInput
    subtitles?: subtitleUncheckedUpdateManyWithoutMovieNestedInput
  }

  export type movieUncheckedUpdateManyWithoutMovieInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    profile_id?: StringFieldUpdateOperationsInput | string
    collection_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type parsed_tvUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv?: tvUpdateOneWithoutParsed_tvsNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_tvsNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutParsed_tvNestedInput
    parsed_seasons?: parsed_seasonUpdateManyWithoutParsed_tvNestedInput
  }

  export type parsed_tvUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    tmdb_id?: NullableIntFieldUpdateOperationsInput | number | null
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutParsed_tvNestedInput
    parsed_seasons?: parsed_seasonUncheckedUpdateManyWithoutParsed_tvNestedInput
  }

  export type parsed_seasonUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season?: seasonUpdateOneWithoutParsed_seasonNestedInput
    parsed_tv?: parsed_tvUpdateOneRequiredWithoutParsed_seasonsNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_seasonsNestedInput
    parsed_episodes?: parsed_episodeUpdateManyWithoutParsed_seasonNestedInput
  }

  export type parsed_seasonUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    season_number?: StringFieldUpdateOperationsInput | string
    file_id?: NullableStringFieldUpdateOperationsInput | string | null
    file_name?: NullableStringFieldUpdateOperationsInput | string | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    correct_season_number?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
    parsed_episodes?: parsed_episodeUncheckedUpdateManyWithoutParsed_seasonNestedInput
  }

  export type parsed_episodeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode?: episodeUpdateOneWithoutParsed_episodesNestedInput
    parsed_tv?: parsed_tvUpdateOneRequiredWithoutParsed_episodesNestedInput
    parsed_season?: parsed_seasonUpdateOneRequiredWithoutParsed_episodesNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_episodesNestedInput
  }

  export type parsed_episodeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_number?: StringFieldUpdateOperationsInput | string
    season_number?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    parsed_tv_id?: StringFieldUpdateOperationsInput | string
    parsed_season_id?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
  }

  export type parsed_movieUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    movie?: movieUpdateOneWithoutParsed_moviesNestedInput
    drive?: driveUpdateOneRequiredWithoutParsed_moviesNestedInput
  }

  export type parsed_movieUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    original_name?: NullableStringFieldUpdateOperationsInput | string | null
    correct_name?: NullableStringFieldUpdateOperationsInput | string | null
    file_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    can_search?: NullableIntFieldUpdateOperationsInput | number | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
  }

  export type incomplete_tvUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_count?: NullableFloatFieldUpdateOperationsInput | number | null
    cur_count?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type incomplete_tvUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_count?: NullableFloatFieldUpdateOperationsInput | number | null
    cur_count?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type incomplete_tvUncheckedUpdateManyWithoutTv_need_completeInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    episode_count?: NullableFloatFieldUpdateOperationsInput | number | null
    cur_count?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type async_taskUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    need_stop?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    output?: outputUpdateOneRequiredWithoutAsync_taskNestedInput
  }

  export type async_taskUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    need_stop?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    output_id?: StringFieldUpdateOperationsInput | string
  }

  export type async_taskUncheckedUpdateManyWithoutAsync_taskInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    type?: NullableIntFieldUpdateOperationsInput | number | null
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    need_stop?: NullableIntFieldUpdateOperationsInput | number | null
    error?: NullableStringFieldUpdateOperationsInput | string | null
    output_id?: StringFieldUpdateOperationsInput | string
  }

  export type fileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    drive?: driveUpdateOneRequiredWithoutFilesNestedInput
  }

  export type fileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    parent_file_id?: StringFieldUpdateOperationsInput | string
    parent_paths?: StringFieldUpdateOperationsInput | string
    type?: IntFieldUpdateOperationsInput | number
    size?: NullableFloatFieldUpdateOperationsInput | number | null
    drive_id?: StringFieldUpdateOperationsInput | string
  }

  export type memberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter?: memberUpdateOneWithoutInviteesNestedInput
    member_setting?: member_settingUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUpdateManyWithoutMemberNestedInput
    reports?: reportUpdateManyWithoutMemberNestedInput
    invitees?: memberUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUpdateManyWithoutMemberNestedInput
  }

  export type memberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_setting?: member_settingUncheckedUpdateOneWithoutMemberNestedInput
    member_tokens?: member_tokenUncheckedUpdateManyWithoutMemberNestedInput
    play_histories?: play_historyUncheckedUpdateManyWithoutMemberNestedInput
    reports?: reportUncheckedUpdateManyWithoutMemberNestedInput
    invitees?: memberUncheckedUpdateManyWithoutInviterNestedInput
    notifications?: member_notificationUncheckedUpdateManyWithoutMemberNestedInput
  }

  export type memberUncheckedUpdateManyWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    name?: NullableStringFieldUpdateOperationsInput | string | null
    avatar?: NullableStringFieldUpdateOperationsInput | string | null
    remark?: StringFieldUpdateOperationsInput | string
    permission?: NullableStringFieldUpdateOperationsInput | string | null
    disabled?: NullableIntFieldUpdateOperationsInput | number | null
    delete?: NullableIntFieldUpdateOperationsInput | number | null
    inviter_id?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type shared_fileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type shared_fileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type shared_fileUncheckedUpdateManyWithoutShared_filesInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: NullableStringFieldUpdateOperationsInput | string | null
    url?: StringFieldUpdateOperationsInput | string
  }

  export type shared_file_in_progressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    drive?: driveUpdateOneRequiredWithoutShared_file_in_progressNestedInput
  }

  export type shared_file_in_progressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
  }

  export type tmp_fileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableFloatFieldUpdateOperationsInput | number | null
    parent_paths?: StringFieldUpdateOperationsInput | string
    drive?: driveUpdateOneRequiredWithoutTmp_filesNestedInput
  }

  export type tmp_fileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    name?: StringFieldUpdateOperationsInput | string
    type?: NullableFloatFieldUpdateOperationsInput | number | null
    parent_paths?: StringFieldUpdateOperationsInput | string
    drive_id?: StringFieldUpdateOperationsInput | string
  }

  export type bind_for_parsed_tvUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id_link_resource?: StringFieldUpdateOperationsInput | string
    file_name_link_resource?: StringFieldUpdateOperationsInput | string
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    season?: seasonUpdateOneWithoutSync_tasksNestedInput
    drive?: driveUpdateOneRequiredWithoutSync_tasksNestedInput
  }

  export type bind_for_parsed_tvUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    url?: StringFieldUpdateOperationsInput | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    file_id_link_resource?: StringFieldUpdateOperationsInput | string
    file_name_link_resource?: StringFieldUpdateOperationsInput | string
    in_production?: NullableIntFieldUpdateOperationsInput | number | null
    invalid?: NullableIntFieldUpdateOperationsInput | number | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
  }

  export type notificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type notificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type notificationUncheckedUpdateManyWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    unique_id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    type?: NullableIntFieldUpdateOperationsInput | number | null
    status?: NullableIntFieldUpdateOperationsInput | number | null
    is_delete?: NullableIntFieldUpdateOperationsInput | number | null
  }

  export type outputUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: output_lineUpdateManyWithoutOutputNestedInput
    async_task?: async_taskUpdateOneWithoutOutputNestedInput
  }

  export type outputUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: output_lineUncheckedUpdateManyWithoutOutputNestedInput
    async_task?: async_taskUncheckedUpdateOneWithoutOutputNestedInput
  }

  export type outputUncheckedUpdateManyWithoutOutputsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type reportUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv?: tvUpdateOneWithoutReportsNestedInput
    season?: seasonUpdateOneWithoutReportsNestedInput
    episode?: episodeUpdateOneWithoutReportsNestedInput
    movie?: movieUpdateOneWithoutReportsNestedInput
    member?: memberUpdateOneRequiredWithoutReportsNestedInput
  }

  export type reportUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: IntFieldUpdateOperationsInput | number
    data?: StringFieldUpdateOperationsInput | string
    answer?: StringFieldUpdateOperationsInput | string
    tv_id?: NullableStringFieldUpdateOperationsInput | string | null
    season_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    member_id?: StringFieldUpdateOperationsInput | string
  }

  export type collectionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
    tvs?: tvUpdateManyWithoutCollectionNestedInput
    seasons?: seasonUpdateManyWithoutCollectionNestedInput
    movies?: movieUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
    tvs?: tvUncheckedUpdateManyWithoutCollectionNestedInput
    seasons?: seasonUncheckedUpdateManyWithoutCollectionNestedInput
    movies?: movieUncheckedUpdateManyWithoutCollectionNestedInput
  }

  export type collectionUncheckedUpdateManyWithoutCollectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    title?: StringFieldUpdateOperationsInput | string
    desc?: NullableStringFieldUpdateOperationsInput | string | null
    type?: IntFieldUpdateOperationsInput | number
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    sort?: IntFieldUpdateOperationsInput | number
    styles?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type subtitleUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    movie?: movieUpdateOneWithoutSubtitlesNestedInput
    episode?: episodeUpdateOneWithoutSubtitlesNestedInput
    drive?: driveUpdateOneRequiredWithoutSubtitlesNestedInput
  }

  export type subtitleUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    file_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    movie_id?: NullableStringFieldUpdateOperationsInput | string | null
    episode_id?: NullableStringFieldUpdateOperationsInput | string | null
    drive_id?: StringFieldUpdateOperationsInput | string
  }

  export type permissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type permissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type permissionUncheckedUpdateManyWithoutPermissionInput = {
    id?: StringFieldUpdateOperationsInput | string
    created?: DateTimeFieldUpdateOperationsInput | Date | string
    updated?: DateTimeFieldUpdateOperationsInput | Date | string
    desc?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}